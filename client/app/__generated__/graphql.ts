/* DO NOT EDIT! this file was generated by graphql-codegen */
/* eslint-disable */
import { GraphQLClient } from 'graphql-request';
import * as Dom from 'graphql-request/dist/types.dom';
import gql from 'graphql-tag';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  DateTime: any;
};

export type AddProviderInput = {
  groups: Array<Scalars['Int']>;
  name: Scalars['String'];
  official: Scalars['Boolean'];
  people: Array<Scalars['Int']>;
  url: Scalars['String'];
};

export type Alias = {
  __typename?: 'Alias';
  createdAt: Scalars['DateTime'];
  id: Scalars['Int'];
  name: Scalars['String'];
  updatedAt: Scalars['DateTime'];
};

export type AliasListRelationFilter = {
  every?: InputMaybe<AliasWhereInput>;
  none?: InputMaybe<AliasWhereInput>;
  some?: InputMaybe<AliasWhereInput>;
};

export type AliasOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type AliasOrderByWithRelationInput = {
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  name?: InputMaybe<SortOrder>;
  person?: InputMaybe<PersonOrderByWithRelationInput>;
  personId?: InputMaybe<SortOrder>;
  preferredAliasOf?: InputMaybe<PersonOrderByWithRelationInput>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type AliasPersonAliasCompoundUniqueInput = {
  name: Scalars['String'];
  personId: Scalars['Int'];
};

export type AliasWhereInput = {
  AND?: InputMaybe<Array<AliasWhereInput>>;
  NOT?: InputMaybe<Array<AliasWhereInput>>;
  OR?: InputMaybe<Array<AliasWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<IntFilter>;
  name?: InputMaybe<StringFilter>;
  person?: InputMaybe<PersonWhereInput>;
  personId?: InputMaybe<IntFilter>;
  preferredAliasOf?: InputMaybe<PersonWhereInput>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type AliasWhereUniqueInput = {
  id?: InputMaybe<Scalars['Int']>;
  personAlias?: InputMaybe<AliasPersonAliasCompoundUniqueInput>;
};

export type Appearance = {
  __typename?: 'Appearance';
  addedBy?: Maybe<User>;
  createdAt: Scalars['DateTime'];
  faces: Array<Face>;
  id: Scalars['Int'];
  image: Image;
  person: Person;
  tags: Array<AppearanceTag>;
  updatedAt: Scalars['DateTime'];
};


export type AppearanceFacesArgs = {
  cursor?: InputMaybe<FaceWhereUniqueInput>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
};


export type AppearanceTagsArgs = {
  cursor?: InputMaybe<AppearanceTagWhereUniqueInput>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
};

export type AppearanceCount = {
  __typename?: 'AppearanceCount';
  count: Scalars['Int'];
  group: Group;
};

export type AppearanceListRelationFilter = {
  every?: InputMaybe<AppearanceWhereInput>;
  none?: InputMaybe<AppearanceWhereInput>;
  some?: InputMaybe<AppearanceWhereInput>;
};

export type AppearanceOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type AppearancePersonIdImageIdCompoundUniqueInput = {
  imageId: Scalars['Int'];
  personId: Scalars['Int'];
};

export type AppearanceTag = {
  __typename?: 'AppearanceTag';
  addedBy?: Maybe<User>;
  appearance: Appearance;
  createdAt: Scalars['DateTime'];
  tag: Tag;
  updatedAt: Scalars['DateTime'];
};

export type AppearanceTagAppearanceTagCompoundUniqueInput = {
  appearanceId: Scalars['Int'];
  tagId: Scalars['Int'];
};

export type AppearanceTagListRelationFilter = {
  every?: InputMaybe<AppearanceTagWhereInput>;
  none?: InputMaybe<AppearanceTagWhereInput>;
  some?: InputMaybe<AppearanceTagWhereInput>;
};

export type AppearanceTagOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type AppearanceTagWhereInput = {
  AND?: InputMaybe<Array<AppearanceTagWhereInput>>;
  Image?: InputMaybe<ImageWhereInput>;
  NOT?: InputMaybe<Array<AppearanceTagWhereInput>>;
  OR?: InputMaybe<Array<AppearanceTagWhereInput>>;
  addedBy?: InputMaybe<UserWhereInput>;
  addedById?: InputMaybe<IntNullableFilter>;
  appearance?: InputMaybe<AppearanceWhereInput>;
  appearanceId?: InputMaybe<IntFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<IntFilter>;
  imageId?: InputMaybe<IntNullableFilter>;
  tag?: InputMaybe<TagWhereInput>;
  tagId?: InputMaybe<IntFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type AppearanceTagWhereUniqueInput = {
  appearanceTag?: InputMaybe<AppearanceTagAppearanceTagCompoundUniqueInput>;
  id?: InputMaybe<Scalars['Int']>;
};

export type AppearanceWhereInput = {
  AND?: InputMaybe<Array<AppearanceWhereInput>>;
  NOT?: InputMaybe<Array<AppearanceWhereInput>>;
  OR?: InputMaybe<Array<AppearanceWhereInput>>;
  addedBy?: InputMaybe<UserWhereInput>;
  addedById?: InputMaybe<IntNullableFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  faces?: InputMaybe<FaceListRelationFilter>;
  id?: InputMaybe<IntFilter>;
  image?: InputMaybe<ImageWhereInput>;
  imageId?: InputMaybe<IntFilter>;
  person?: InputMaybe<PersonWhereInput>;
  personId?: InputMaybe<IntFilter>;
  tags?: InputMaybe<AppearanceTagListRelationFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type AppearanceWhereUniqueInput = {
  id?: InputMaybe<Scalars['Int']>;
  personId_imageId?: InputMaybe<AppearancePersonIdImageIdCompoundUniqueInput>;
};

export type BoolFilter = {
  equals?: InputMaybe<Scalars['Boolean']>;
  not?: InputMaybe<NestedBoolFilter>;
};

export type DateTimeFilter = {
  equals?: InputMaybe<Scalars['DateTime']>;
  gt?: InputMaybe<Scalars['DateTime']>;
  gte?: InputMaybe<Scalars['DateTime']>;
  in?: InputMaybe<Array<Scalars['DateTime']>>;
  lt?: InputMaybe<Scalars['DateTime']>;
  lte?: InputMaybe<Scalars['DateTime']>;
  not?: InputMaybe<NestedDateTimeFilter>;
  notIn?: InputMaybe<Array<Scalars['DateTime']>>;
};

export type DateTimeNullableFilter = {
  equals?: InputMaybe<Scalars['DateTime']>;
  gt?: InputMaybe<Scalars['DateTime']>;
  gte?: InputMaybe<Scalars['DateTime']>;
  in?: InputMaybe<Array<Scalars['DateTime']>>;
  lt?: InputMaybe<Scalars['DateTime']>;
  lte?: InputMaybe<Scalars['DateTime']>;
  not?: InputMaybe<NestedDateTimeNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['DateTime']>>;
};

export type DiscoveredImage = {
  __typename?: 'DiscoveredImage';
  approvedImage?: Maybe<Image>;
  createdAt: Scalars['DateTime'];
  duplicateImage?: Maybe<Image>;
  id: Scalars['Int'];
  providerType: Scalars['String'];
  referenceUrl?: Maybe<Scalars['String']>;
  /** A smaller thumbnail of the image */
  thumbnail: Scalars['String'];
  uniqueIdentifier: Scalars['String'];
  updatedAt: Scalars['DateTime'];
  url: Scalars['String'];
  verdict?: Maybe<DiscoveredImageVerdict>;
  /** The vote cast by the currently logged in user */
  vote?: Maybe<DiscoveredImageVote>;
  /** Votes cast by all users */
  votes: Array<DiscoveredImageVote>;
};


export type DiscoveredImageVotesArgs = {
  cursor?: InputMaybe<DiscoveredImageVoteWhereUniqueInput>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<DiscoveredImageVoteWhereInput>;
};

export type DiscoveredImageListRelationFilter = {
  every?: InputMaybe<DiscoveredImageWhereInput>;
  none?: InputMaybe<DiscoveredImageWhereInput>;
  some?: InputMaybe<DiscoveredImageWhereInput>;
};

export type DiscoveredImageOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type DiscoveredImageOrderByWithRelationInput = {
  createdAt?: InputMaybe<SortOrder>;
  duplicateDiscoveredImage?: InputMaybe<DiscoveredImageOrderByWithRelationInput>;
  duplicateDiscoveredImageId?: InputMaybe<SortOrder>;
  duplicateDiscoveredImages?: InputMaybe<DiscoveredImageOrderByRelationAggregateInput>;
  duplicateImage?: InputMaybe<ImageOrderByWithRelationInput>;
  duplicateImageId?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  image?: InputMaybe<ImageOrderByWithRelationInput>;
  imageId?: InputMaybe<SortOrder>;
  mediaType?: InputMaybe<SortOrder>;
  post?: InputMaybe<DiscoveredPostOrderByWithRelationInput>;
  postId?: InputMaybe<SortOrder>;
  providerType?: InputMaybe<SortOrder>;
  referenceUrl?: InputMaybe<SortOrder>;
  uniqueIdentifier?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  url?: InputMaybe<SortOrder>;
  verdict?: InputMaybe<DiscoveredImageVerdictOrderByWithRelationInput>;
  votes?: InputMaybe<DiscoveredImageVoteOrderByRelationAggregateInput>;
};

export type DiscoveredImageProviderTypeUniqueIdentifierCompoundUniqueInput = {
  providerType: Scalars['String'];
  uniqueIdentifier: Scalars['String'];
};

export type DiscoveredImageVerdict = {
  __typename?: 'DiscoveredImageVerdict';
  createdAt: Scalars['DateTime'];
  id: Scalars['Int'];
  reason?: Maybe<Scalars['String']>;
  verdict: Scalars['String'];
};

export type DiscoveredImageVerdictOrderByWithRelationInput = {
  createdAt?: InputMaybe<SortOrder>;
  discoveredImage?: InputMaybe<DiscoveredImageOrderByWithRelationInput>;
  discoveredImageId?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  reason?: InputMaybe<SortOrder>;
  verdict?: InputMaybe<SortOrder>;
};

export type DiscoveredImageVerdictWhereInput = {
  AND?: InputMaybe<Array<DiscoveredImageVerdictWhereInput>>;
  NOT?: InputMaybe<Array<DiscoveredImageVerdictWhereInput>>;
  OR?: InputMaybe<Array<DiscoveredImageVerdictWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  discoveredImage?: InputMaybe<DiscoveredImageWhereInput>;
  discoveredImageId?: InputMaybe<IntFilter>;
  id?: InputMaybe<IntFilter>;
  reason?: InputMaybe<StringNullableFilter>;
  verdict?: InputMaybe<StringFilter>;
};

export type DiscoveredImageVote = {
  __typename?: 'DiscoveredImageVote';
  createdAt: Scalars['DateTime'];
  id: Scalars['Int'];
  reason?: Maybe<Scalars['String']>;
  updatedAt: Scalars['DateTime'];
  user: User;
  verdict: Scalars['String'];
};

export type DiscoveredImageVoteListRelationFilter = {
  every?: InputMaybe<DiscoveredImageVoteWhereInput>;
  none?: InputMaybe<DiscoveredImageVoteWhereInput>;
  some?: InputMaybe<DiscoveredImageVoteWhereInput>;
};

export type DiscoveredImageVoteOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type DiscoveredImageVoteUserVoteCompoundUniqueInput = {
  discoveredImageId: Scalars['Int'];
  userId: Scalars['Int'];
};

export type DiscoveredImageVoteWhereInput = {
  AND?: InputMaybe<Array<DiscoveredImageVoteWhereInput>>;
  NOT?: InputMaybe<Array<DiscoveredImageVoteWhereInput>>;
  OR?: InputMaybe<Array<DiscoveredImageVoteWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  discoveredImage?: InputMaybe<DiscoveredImageWhereInput>;
  discoveredImageId?: InputMaybe<IntFilter>;
  id?: InputMaybe<IntFilter>;
  reason?: InputMaybe<StringNullableFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  user?: InputMaybe<UserWhereInput>;
  userId?: InputMaybe<IntFilter>;
  verdict?: InputMaybe<StringFilter>;
  xp?: InputMaybe<IntFilter>;
};

export type DiscoveredImageVoteWhereUniqueInput = {
  id?: InputMaybe<Scalars['Int']>;
  userVote?: InputMaybe<DiscoveredImageVoteUserVoteCompoundUniqueInput>;
};

export type DiscoveredImageWhereInput = {
  AND?: InputMaybe<Array<DiscoveredImageWhereInput>>;
  NOT?: InputMaybe<Array<DiscoveredImageWhereInput>>;
  OR?: InputMaybe<Array<DiscoveredImageWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  duplicateDiscoveredImage?: InputMaybe<DiscoveredImageWhereInput>;
  duplicateDiscoveredImageId?: InputMaybe<IntNullableFilter>;
  duplicateDiscoveredImages?: InputMaybe<DiscoveredImageListRelationFilter>;
  duplicateImage?: InputMaybe<ImageWhereInput>;
  duplicateImageId?: InputMaybe<IntNullableFilter>;
  id?: InputMaybe<IntFilter>;
  image?: InputMaybe<ImageWhereInput>;
  imageId?: InputMaybe<IntNullableFilter>;
  mediaType?: InputMaybe<StringFilter>;
  post?: InputMaybe<DiscoveredPostWhereInput>;
  postId?: InputMaybe<IntNullableFilter>;
  providerType?: InputMaybe<StringFilter>;
  referenceUrl?: InputMaybe<StringNullableFilter>;
  uniqueIdentifier?: InputMaybe<StringFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  url?: InputMaybe<StringFilter>;
  verdict?: InputMaybe<DiscoveredImageVerdictWhereInput>;
  votes?: InputMaybe<DiscoveredImageVoteListRelationFilter>;
};

export type DiscoveredImageWhereUniqueInput = {
  id?: InputMaybe<Scalars['Int']>;
  imageId?: InputMaybe<Scalars['Int']>;
  providerType_uniqueIdentifier?: InputMaybe<DiscoveredImageProviderTypeUniqueIdentifierCompoundUniqueInput>;
};

export type DiscoveredPost = {
  __typename?: 'DiscoveredPost';
  accountAvatarUrl?: Maybe<Scalars['String']>;
  accountName: Scalars['String'];
  body?: Maybe<Scalars['String']>;
  createdAt: Scalars['DateTime'];
  id: Scalars['Int'];
  images: Array<DiscoveredImage>;
  originalPostDate?: Maybe<Scalars['DateTime']>;
  postUrl?: Maybe<Scalars['String']>;
  providerType: Scalars['String'];
  /** Groups who are associated with the social media account that created this post. */
  referencingGroups: Array<Group>;
  /** People who are associated with the social media account that created this post. */
  referencingPeople: Array<Person>;
  uniqueIdentifier: Scalars['String'];
  updatedAt: Scalars['DateTime'];
};


export type DiscoveredPostImagesArgs = {
  cursor?: InputMaybe<DiscoveredImageWhereUniqueInput>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
};

export type DiscoveredPostDiscoveredProviderCompoundUniqueInput = {
  providerType: Scalars['String'];
  uniqueIdentifier: Scalars['String'];
};

export type DiscoveredPostOrderByWithRelationInput = {
  accountAvatarUrl?: InputMaybe<SortOrder>;
  accountName?: InputMaybe<SortOrder>;
  body?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  discoveredImages?: InputMaybe<DiscoveredImageOrderByRelationAggregateInput>;
  id?: InputMaybe<SortOrder>;
  official?: InputMaybe<SortOrder>;
  originalPostDate?: InputMaybe<SortOrder>;
  postUrl?: InputMaybe<SortOrder>;
  providerType?: InputMaybe<SortOrder>;
  referencingGroups?: InputMaybe<SortOrder>;
  referencingPeople?: InputMaybe<SortOrder>;
  uniqueIdentifier?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type DiscoveredPostWhereInput = {
  AND?: InputMaybe<Array<DiscoveredPostWhereInput>>;
  NOT?: InputMaybe<Array<DiscoveredPostWhereInput>>;
  OR?: InputMaybe<Array<DiscoveredPostWhereInput>>;
  accountAvatarUrl?: InputMaybe<StringNullableFilter>;
  accountName?: InputMaybe<StringFilter>;
  body?: InputMaybe<StringNullableFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  discoveredImages?: InputMaybe<DiscoveredImageListRelationFilter>;
  id?: InputMaybe<IntFilter>;
  official?: InputMaybe<BoolFilter>;
  originalPostDate?: InputMaybe<DateTimeNullableFilter>;
  postUrl?: InputMaybe<StringNullableFilter>;
  providerType?: InputMaybe<StringFilter>;
  referencingGroups?: InputMaybe<IntNullableListFilter>;
  referencingPeople?: InputMaybe<IntNullableListFilter>;
  uniqueIdentifier?: InputMaybe<StringFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type DiscoveredPostWhereUniqueInput = {
  discoveredProvider?: InputMaybe<DiscoveredPostDiscoveredProviderCompoundUniqueInput>;
  id?: InputMaybe<Scalars['Int']>;
};

/** The list of providers that supply images for the discovery feed */
export type DiscoveryProvider = {
  __typename?: 'DiscoveryProvider';
  destination: Scalars['String'];
  name?: Maybe<Scalars['String']>;
  official: Scalars['Boolean'];
  provider: Scalars['String'];
  url: Scalars['String'];
  /** The number of days remaining until this provider is checked for updates again */
  waitDays: Scalars['Int'];
};

export type DiscoveryStatistic = {
  __typename?: 'DiscoveryStatistic';
  count: Scalars['Int'];
  verdict: Scalars['String'];
};

export type EnumFaceSourceFilter = {
  equals?: InputMaybe<FaceSource>;
  in?: InputMaybe<Array<FaceSource>>;
  not?: InputMaybe<NestedEnumFaceSourceFilter>;
  notIn?: InputMaybe<Array<FaceSource>>;
};

export type EnumGameParticipantKindFilter = {
  equals?: InputMaybe<GameParticipantKind>;
  in?: InputMaybe<Array<GameParticipantKind>>;
  not?: InputMaybe<NestedEnumGameParticipantKindFilter>;
  notIn?: InputMaybe<Array<GameParticipantKind>>;
};

export type EnumGenderNullableFilter = {
  equals?: InputMaybe<Gender>;
  in?: InputMaybe<Array<Gender>>;
  not?: InputMaybe<NestedEnumGenderNullableFilter>;
  notIn?: InputMaybe<Array<Gender>>;
};

export type EnumGuessingGameHintsFilter = {
  equals?: InputMaybe<GuessingGameHints>;
  in?: InputMaybe<Array<GuessingGameHints>>;
  not?: InputMaybe<NestedEnumGuessingGameHintsFilter>;
  notIn?: InputMaybe<Array<GuessingGameHints>>;
};

export type EnumImageReportActionNullableFilter = {
  equals?: InputMaybe<ImageReportAction>;
  in?: InputMaybe<Array<ImageReportAction>>;
  not?: InputMaybe<NestedEnumImageReportActionNullableFilter>;
  notIn?: InputMaybe<Array<ImageReportAction>>;
};

export type EnumMimeTypeFilter = {
  equals?: InputMaybe<MimeType>;
  in?: InputMaybe<Array<MimeType>>;
  not?: InputMaybe<NestedEnumMimeTypeFilter>;
  notIn?: InputMaybe<Array<MimeType>>;
};

export type EnumRestrictionKindFilter = {
  equals?: InputMaybe<RestrictionKind>;
  in?: InputMaybe<Array<RestrictionKind>>;
  not?: InputMaybe<NestedEnumRestrictionKindFilter>;
  notIn?: InputMaybe<Array<RestrictionKind>>;
};

export type EnumTagSourceFilter = {
  equals?: InputMaybe<TagSource>;
  in?: InputMaybe<Array<TagSource>>;
  not?: InputMaybe<NestedEnumTagSourceFilter>;
  notIn?: InputMaybe<Array<TagSource>>;
};

export type EnumUploadDestinationFilter = {
  equals?: InputMaybe<UploadDestination>;
  in?: InputMaybe<Array<UploadDestination>>;
  not?: InputMaybe<NestedEnumUploadDestinationFilter>;
  notIn?: InputMaybe<Array<UploadDestination>>;
};

export type EnumUploadTypeFilter = {
  equals?: InputMaybe<UploadType>;
  in?: InputMaybe<Array<UploadType>>;
  not?: InputMaybe<NestedEnumUploadTypeFilter>;
  notIn?: InputMaybe<Array<UploadType>>;
};

export type Face = {
  __typename?: 'Face';
  addedBy?: Maybe<User>;
  appearance?: Maybe<Appearance>;
  createdAt: Scalars['DateTime'];
  height: Scalars['Float'];
  id: Scalars['Int'];
  image: Image;
  /** @deprecated No longer supported */
  score: Scalars['Float'];
  source: FaceSource;
  updatedAt: Scalars['DateTime'];
  width: Scalars['Float'];
  x: Scalars['Float'];
  y: Scalars['Float'];
};

export type FaceListRelationFilter = {
  every?: InputMaybe<FaceWhereInput>;
  none?: InputMaybe<FaceWhereInput>;
  some?: InputMaybe<FaceWhereInput>;
};

export type FaceOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export enum FaceSource {
  Manual = 'Manual',
  Scan = 'Scan'
}

export type FaceWhereInput = {
  AND?: InputMaybe<Array<FaceWhereInput>>;
  NOT?: InputMaybe<Array<FaceWhereInput>>;
  OR?: InputMaybe<Array<FaceWhereInput>>;
  addedBy?: InputMaybe<UserWhereInput>;
  addedById?: InputMaybe<IntNullableFilter>;
  appearance?: InputMaybe<AppearanceWhereInput>;
  appearanceId?: InputMaybe<IntNullableFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  height?: InputMaybe<FloatFilter>;
  id?: InputMaybe<IntFilter>;
  image?: InputMaybe<ImageWhereInput>;
  imageId?: InputMaybe<IntFilter>;
  person?: InputMaybe<PersonWhereInput>;
  personId?: InputMaybe<IntNullableFilter>;
  score?: InputMaybe<FloatFilter>;
  source?: InputMaybe<EnumFaceSourceFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  width?: InputMaybe<FloatFilter>;
  x?: InputMaybe<FloatFilter>;
  y?: InputMaybe<FloatFilter>;
};

export type FaceWhereUniqueInput = {
  id?: InputMaybe<Scalars['Int']>;
};

export type FloatFilter = {
  equals?: InputMaybe<Scalars['Float']>;
  gt?: InputMaybe<Scalars['Float']>;
  gte?: InputMaybe<Scalars['Float']>;
  in?: InputMaybe<Array<Scalars['Float']>>;
  lt?: InputMaybe<Scalars['Float']>;
  lte?: InputMaybe<Scalars['Float']>;
  not?: InputMaybe<NestedFloatFilter>;
  notIn?: InputMaybe<Array<Scalars['Float']>>;
};

export enum GameParticipantKind {
  Player = 'Player',
  Spectator = 'Spectator'
}

export enum Gender {
  Female = 'FEMALE',
  Male = 'MALE',
  Nonbinary = 'NONBINARY'
}

export type Group = {
  __typename?: 'Group';
  aliases: Array<GroupAlias>;
  avatar?: Maybe<Image>;
  banner?: Maybe<Image>;
  createdAt: Scalars['DateTime'];
  id: Scalars['Int'];
  members: Array<GroupMember>;
  name: Scalars['String'];
  updatedAt: Scalars['DateTime'];
};


export type GroupAliasesArgs = {
  cursor?: InputMaybe<GroupAliasWhereUniqueInput>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
};


export type GroupMembersArgs = {
  cursor?: InputMaybe<GroupMemberWhereUniqueInput>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
};

export type GroupAlias = {
  __typename?: 'GroupAlias';
  createdAt: Scalars['DateTime'];
  id: Scalars['Int'];
  name: Scalars['String'];
  updatedAt: Scalars['DateTime'];
};

export type GroupAliasListRelationFilter = {
  every?: InputMaybe<GroupAliasWhereInput>;
  none?: InputMaybe<GroupAliasWhereInput>;
  some?: InputMaybe<GroupAliasWhereInput>;
};

export type GroupAliasOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type GroupAliasWhereInput = {
  AND?: InputMaybe<Array<GroupAliasWhereInput>>;
  NOT?: InputMaybe<Array<GroupAliasWhereInput>>;
  OR?: InputMaybe<Array<GroupAliasWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  group?: InputMaybe<GroupWhereInput>;
  groupId?: InputMaybe<IntFilter>;
  id?: InputMaybe<IntFilter>;
  name?: InputMaybe<StringFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type GroupAliasWhereUniqueInput = {
  id?: InputMaybe<Scalars['Int']>;
};

export type GroupMember = {
  __typename?: 'GroupMember';
  createdAt: Scalars['DateTime'];
  endDate?: Maybe<Scalars['DateTime']>;
  group: Group;
  id: Scalars['Int'];
  person: Person;
  startDate?: Maybe<Scalars['DateTime']>;
  updatedAt: Scalars['DateTime'];
};

export type GroupMemberGroupIdPersonIdCompoundUniqueInput = {
  groupId: Scalars['Int'];
  personId: Scalars['Int'];
};

export type GroupMemberListRelationFilter = {
  every?: InputMaybe<GroupMemberWhereInput>;
  none?: InputMaybe<GroupMemberWhereInput>;
  some?: InputMaybe<GroupMemberWhereInput>;
};

export type GroupMemberOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type GroupMemberOrderByWithRelationInput = {
  createdAt?: InputMaybe<SortOrder>;
  endDate?: InputMaybe<SortOrder>;
  group?: InputMaybe<GroupOrderByWithRelationInput>;
  groupId?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  person?: InputMaybe<PersonOrderByWithRelationInput>;
  personId?: InputMaybe<SortOrder>;
  preferredMemberships_?: InputMaybe<PersonOrderByRelationAggregateInput>;
  startDate?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type GroupMemberWhereInput = {
  AND?: InputMaybe<Array<GroupMemberWhereInput>>;
  NOT?: InputMaybe<Array<GroupMemberWhereInput>>;
  OR?: InputMaybe<Array<GroupMemberWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  endDate?: InputMaybe<DateTimeNullableFilter>;
  group?: InputMaybe<GroupWhereInput>;
  groupId?: InputMaybe<IntFilter>;
  id?: InputMaybe<IntFilter>;
  person?: InputMaybe<PersonWhereInput>;
  personId?: InputMaybe<IntFilter>;
  preferredMemberships_?: InputMaybe<PersonListRelationFilter>;
  startDate?: InputMaybe<DateTimeNullableFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type GroupMemberWhereUniqueInput = {
  groupId_personId?: InputMaybe<GroupMemberGroupIdPersonIdCompoundUniqueInput>;
  id?: InputMaybe<Scalars['Int']>;
};

export type GroupMembership = {
  endDate?: InputMaybe<Scalars['String']>;
  id: Scalars['Int'];
  startDate?: InputMaybe<Scalars['String']>;
};

export type GroupOrderByWithRelationInput = {
  aliases?: InputMaybe<GroupAliasOrderByRelationAggregateInput>;
  avatar?: InputMaybe<ImageOrderByWithRelationInput>;
  avatarId?: InputMaybe<SortOrder>;
  banner?: InputMaybe<ImageOrderByWithRelationInput>;
  bannerId?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  ireneBotId?: InputMaybe<SortOrder>;
  members?: InputMaybe<GroupMemberOrderByRelationAggregateInput>;
  name?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type GroupWhereInput = {
  AND?: InputMaybe<Array<GroupWhereInput>>;
  NOT?: InputMaybe<Array<GroupWhereInput>>;
  OR?: InputMaybe<Array<GroupWhereInput>>;
  aliases?: InputMaybe<GroupAliasListRelationFilter>;
  avatar?: InputMaybe<ImageWhereInput>;
  avatarId?: InputMaybe<IntNullableFilter>;
  banner?: InputMaybe<ImageWhereInput>;
  bannerId?: InputMaybe<IntNullableFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<IntFilter>;
  ireneBotId?: InputMaybe<IntNullableFilter>;
  members?: InputMaybe<GroupMemberListRelationFilter>;
  name?: InputMaybe<StringFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type GroupWhereUniqueInput = {
  avatarId?: InputMaybe<Scalars['Int']>;
  bannerId?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['Int']>;
  ireneBotId?: InputMaybe<Scalars['Int']>;
};

export type GuessingGameGuessListRelationFilter = {
  every?: InputMaybe<GuessingGameGuessWhereInput>;
  none?: InputMaybe<GuessingGameGuessWhereInput>;
  some?: InputMaybe<GuessingGameGuessWhereInput>;
};

export type GuessingGameGuessOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type GuessingGameGuessWhereInput = {
  AND?: InputMaybe<Array<GuessingGameGuessWhereInput>>;
  NOT?: InputMaybe<Array<GuessingGameGuessWhereInput>>;
  OR?: InputMaybe<Array<GuessingGameGuessWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  guessMs?: InputMaybe<IntFilter>;
  guessedAt?: InputMaybe<DateTimeFilter>;
  hintUsed?: InputMaybe<BoolFilter>;
  id?: InputMaybe<IntFilter>;
  personGuess?: InputMaybe<PersonWhereInput>;
  personGuessId?: InputMaybe<IntNullableFilter>;
  round?: InputMaybe<GuessingGameRoundWhereInput>;
  roundId?: InputMaybe<IntFilter>;
  target?: InputMaybe<GuessingGameTargetWhereInput>;
  targetId?: InputMaybe<IntFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  user?: InputMaybe<UserWhereInput>;
  userId?: InputMaybe<IntNullableFilter>;
};

export enum GuessingGameHints {
  AlwaysOn = 'ALWAYS_ON',
  Disabled = 'DISABLED',
  Limited = 'LIMITED',
  PointCost = 'POINT_COST'
}

export type GuessingGameListRelationFilter = {
  every?: InputMaybe<GuessingGameWhereInput>;
  none?: InputMaybe<GuessingGameWhereInput>;
  some?: InputMaybe<GuessingGameWhereInput>;
};

export type GuessingGameOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type GuessingGameParticipantListRelationFilter = {
  every?: InputMaybe<GuessingGameParticipantWhereInput>;
  none?: InputMaybe<GuessingGameParticipantWhereInput>;
  some?: InputMaybe<GuessingGameParticipantWhereInput>;
};

export type GuessingGameParticipantOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type GuessingGameParticipantWhereInput = {
  AND?: InputMaybe<Array<GuessingGameParticipantWhereInput>>;
  NOT?: InputMaybe<Array<GuessingGameParticipantWhereInput>>;
  OR?: InputMaybe<Array<GuessingGameParticipantWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  game?: InputMaybe<GuessingGameWhereInput>;
  gameId?: InputMaybe<IntFilter>;
  id?: InputMaybe<IntFilter>;
  type?: InputMaybe<EnumGameParticipantKindFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  user?: InputMaybe<UserWhereInput>;
  userId?: InputMaybe<IntNullableFilter>;
};

export type GuessingGameRoundListRelationFilter = {
  every?: InputMaybe<GuessingGameRoundWhereInput>;
  none?: InputMaybe<GuessingGameRoundWhereInput>;
  some?: InputMaybe<GuessingGameRoundWhereInput>;
};

export type GuessingGameRoundWhereInput = {
  AND?: InputMaybe<Array<GuessingGameRoundWhereInput>>;
  NOT?: InputMaybe<Array<GuessingGameRoundWhereInput>>;
  OR?: InputMaybe<Array<GuessingGameRoundWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  game?: InputMaybe<GuessingGameWhereInput>;
  gameId?: InputMaybe<IntFilter>;
  guesses?: InputMaybe<GuessingGameGuessListRelationFilter>;
  id?: InputMaybe<IntFilter>;
  startDate?: InputMaybe<DateTimeFilter>;
  startedAt?: InputMaybe<DateTimeFilter>;
  targets?: InputMaybe<GuessingGameTargetListRelationFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type GuessingGameTargetListRelationFilter = {
  every?: InputMaybe<GuessingGameTargetWhereInput>;
  none?: InputMaybe<GuessingGameTargetWhereInput>;
  some?: InputMaybe<GuessingGameTargetWhereInput>;
};

export type GuessingGameTargetOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type GuessingGameTargetWhereInput = {
  AND?: InputMaybe<Array<GuessingGameTargetWhereInput>>;
  NOT?: InputMaybe<Array<GuessingGameTargetWhereInput>>;
  OR?: InputMaybe<Array<GuessingGameTargetWhereInput>>;
  answer?: InputMaybe<PersonWhereInput>;
  answerId?: InputMaybe<IntNullableFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  guesses?: InputMaybe<GuessingGameGuessListRelationFilter>;
  id?: InputMaybe<IntFilter>;
  round?: InputMaybe<GuessingGameRoundWhereInput>;
  roundId?: InputMaybe<IntFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type GuessingGameWhereInput = {
  AND?: InputMaybe<Array<GuessingGameWhereInput>>;
  NOT?: InputMaybe<Array<GuessingGameWhereInput>>;
  OR?: InputMaybe<Array<GuessingGameWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  finishDate?: InputMaybe<DateTimeFilter>;
  hints?: InputMaybe<EnumGuessingGameHintsFilter>;
  id?: InputMaybe<IntFilter>;
  name?: InputMaybe<StringFilter>;
  owner?: InputMaybe<UserWhereInput>;
  ownerId?: InputMaybe<IntFilter>;
  participants?: InputMaybe<GuessingGameParticipantListRelationFilter>;
  rounds?: InputMaybe<GuessingGameRoundListRelationFilter>;
  secondsPerRound?: InputMaybe<IntFilter>;
  startDate?: InputMaybe<DateTimeFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type Homepage = {
  __typename?: 'Homepage';
  trending: Array<Array<HomepageTrendingPerson>>;
};

export type HomepageTrendingPerson = {
  __typename?: 'HomepageTrendingPerson';
  person: Person;
};

export type Image = {
  __typename?: 'Image';
  appearanceTags: Array<AppearanceTag>;
  appearances: Array<Appearance>;
  /** The aspect ratio of the image */
  aspectRatio: Scalars['Float'];
  bytes: Scalars['Int'];
  caption?: Maybe<Scalars['String']>;
  /** A graph of connections people in this image share with others based on images they appear together in up to a depth of 4 */
  connections: ImageConnections;
  createdAt: Scalars['DateTime'];
  destination: UploadDestination;
  faceScanDate?: Maybe<Scalars['DateTime']>;
  /** The name the image file was uploaded with. */
  fileName?: Maybe<Scalars['String']>;
  /** Human readable file size. Use `bytes` for a number representation. */
  fileSize: Scalars['String'];
  /** The center of focus for the image. Calculated based on the position of the faces in the image. */
  focus: ImageCoordinate;
  /** SHA256 checksum of the image. */
  hash: Scalars['String'];
  /** Height of the image in pixels. */
  height: Scalars['Int'];
  hiddenAt?: Maybe<Scalars['DateTime']>;
  id: Scalars['Int'];
  imageTags: Array<ImageTag>;
  ireneBotId?: Maybe<Scalars['Int']>;
  /** @deprecated Unused field, all images are SFW */
  isNsfw: Scalars['Boolean'];
  /** False if not logged in */
  liked?: Maybe<Scalars['Boolean']>;
  /** The IANA media type of the image. */
  mimetype: MimeType;
  /** Dominant colors in the image in decimal format, sorted by frequency. */
  palette: Array<Scalars['Int']>;
  /** The visibility status of the image. */
  public: Scalars['Boolean'];
  /** Direct link to the image on the CDN */
  rawUrl: Scalars['String'];
  reported: Scalars['Boolean'];
  /** The unique url identifier of the image. */
  slug: Scalars['String'];
  /** The url the image was taken from (if applicable). Not guaranteed to be a direct image url. */
  source?: Maybe<Scalars['String']>;
  thumbnail: Thumbnail;
  unknownFaces: Array<Face>;
  uploadType: UploadType;
  uploadedBy?: Maybe<User>;
  /** Link to the image on the site */
  url: Scalars['String'];
  views: Scalars['Int'];
  /** Width of the image in pixels. */
  width: Scalars['Int'];
};


export type ImageAppearanceTagsArgs = {
  cursor?: InputMaybe<AppearanceTagWhereUniqueInput>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
};


export type ImageAppearancesArgs = {
  cursor?: InputMaybe<AppearanceWhereUniqueInput>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
};


export type ImageConnectionsArgs = {
  depth?: Scalars['Int'];
};


export type ImageImageTagsArgs = {
  cursor?: InputMaybe<ImageTagWhereUniqueInput>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
};

export enum ImageConnectionEdge {
  ImageToPerson = 'IMAGE_TO_PERSON',
  PersonToImage = 'PERSON_TO_IMAGE'
}

export type ImageConnections = {
  __typename?: 'ImageConnections';
  edges: Array<ImageEdge>;
  images: Array<Image>;
  people: Array<Person>;
};

/** A coordinate representing a position on an image */
export type ImageCoordinate = {
  __typename?: 'ImageCoordinate';
  x: Scalars['Int'];
  y: Scalars['Int'];
};

export type ImageEdge = {
  __typename?: 'ImageEdge';
  from: Scalars['Int'];
  to: Scalars['Int'];
  type?: Maybe<ImageConnectionEdge>;
};

export type ImageLikeListRelationFilter = {
  every?: InputMaybe<ImageLikeWhereInput>;
  none?: InputMaybe<ImageLikeWhereInput>;
  some?: InputMaybe<ImageLikeWhereInput>;
};

export type ImageLikeOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type ImageLikeWhereInput = {
  AND?: InputMaybe<Array<ImageLikeWhereInput>>;
  NOT?: InputMaybe<Array<ImageLikeWhereInput>>;
  OR?: InputMaybe<Array<ImageLikeWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<IntFilter>;
  image?: InputMaybe<ImageWhereInput>;
  imageId?: InputMaybe<IntFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  user?: InputMaybe<UserWhereInput>;
  userId?: InputMaybe<IntFilter>;
};

export type ImageListRelationFilter = {
  every?: InputMaybe<ImageWhereInput>;
  none?: InputMaybe<ImageWhereInput>;
  some?: InputMaybe<ImageWhereInput>;
};

export type ImageOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type ImageOrderByWithRelationInput = {
  appearanceTags?: InputMaybe<AppearanceTagOrderByRelationAggregateInput>;
  appearances?: InputMaybe<AppearanceOrderByRelationAggregateInput>;
  bytes?: InputMaybe<SortOrder>;
  caption?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  destination?: InputMaybe<SortOrder>;
  discoverySource?: InputMaybe<DiscoveredImageOrderByWithRelationInput>;
  faceScanDate?: InputMaybe<SortOrder>;
  faceScanRequestDate?: InputMaybe<SortOrder>;
  faces?: InputMaybe<FaceOrderByRelationAggregateInput>;
  fileName?: InputMaybe<SortOrder>;
  groupAvatarOf?: InputMaybe<GroupOrderByWithRelationInput>;
  groupBannerOf?: InputMaybe<GroupOrderByWithRelationInput>;
  hash?: InputMaybe<SortOrder>;
  height?: InputMaybe<SortOrder>;
  hiddenAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  imageTags?: InputMaybe<ImageTagOrderByRelationAggregateInput>;
  ireneBotId?: InputMaybe<SortOrder>;
  isNsfw?: InputMaybe<SortOrder>;
  likes?: InputMaybe<ImageLikeOrderByRelationAggregateInput>;
  mimetype?: InputMaybe<SortOrder>;
  pHash?: InputMaybe<SortOrder>;
  palette?: InputMaybe<SortOrder>;
  personAvatarOf?: InputMaybe<PersonOrderByWithRelationInput>;
  personBannerOf?: InputMaybe<PersonOrderByWithRelationInput>;
  potentialDuplicates?: InputMaybe<DiscoveredImageOrderByRelationAggregateInput>;
  public?: InputMaybe<SortOrder>;
  reports?: InputMaybe<ImageReportOrderByRelationAggregateInput>;
  slug?: InputMaybe<SortOrder>;
  source?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
  uploadType?: InputMaybe<SortOrder>;
  user?: InputMaybe<UserOrderByWithRelationInput>;
  userAvatarOf?: InputMaybe<UserOrderByWithRelationInput>;
  userBannerOf?: InputMaybe<UserOrderByWithRelationInput>;
  userId?: InputMaybe<SortOrder>;
  views?: InputMaybe<SortOrder>;
  width?: InputMaybe<SortOrder>;
  xp?: InputMaybe<SortOrder>;
};

export type ImageReport = {
  __typename?: 'ImageReport';
  action?: Maybe<ImageReportAction>;
  actionedAt?: Maybe<Scalars['DateTime']>;
  createdAt: Scalars['DateTime'];
  id: Scalars['Int'];
  image: Image;
  reason?: Maybe<Scalars['String']>;
  reportedBy: User;
  updatedAt: Scalars['DateTime'];
};

export enum ImageReportAction {
  DeleteImage = 'DELETE_IMAGE',
  Dismiss = 'DISMISS',
  HideImage = 'HIDE_IMAGE',
  Other = 'OTHER',
  RestrictUser = 'RESTRICT_USER'
}

export type ImageReportImageReportUserCompoundUniqueInput = {
  imageId: Scalars['Int'];
  reportedById: Scalars['Int'];
};

export type ImageReportListRelationFilter = {
  every?: InputMaybe<ImageReportWhereInput>;
  none?: InputMaybe<ImageReportWhereInput>;
  some?: InputMaybe<ImageReportWhereInput>;
};

export type ImageReportOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type ImageReportOrderByWithRelationInput = {
  action?: InputMaybe<SortOrder>;
  actionedAt?: InputMaybe<SortOrder>;
  actionedBy?: InputMaybe<UserOrderByWithRelationInput>;
  actionedById?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  id?: InputMaybe<SortOrder>;
  image?: InputMaybe<ImageOrderByWithRelationInput>;
  imageId?: InputMaybe<SortOrder>;
  reason?: InputMaybe<SortOrder>;
  reportedBy?: InputMaybe<UserOrderByWithRelationInput>;
  reportedById?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type ImageReportWhereInput = {
  AND?: InputMaybe<Array<ImageReportWhereInput>>;
  NOT?: InputMaybe<Array<ImageReportWhereInput>>;
  OR?: InputMaybe<Array<ImageReportWhereInput>>;
  action?: InputMaybe<EnumImageReportActionNullableFilter>;
  actionedAt?: InputMaybe<DateTimeNullableFilter>;
  actionedBy?: InputMaybe<UserWhereInput>;
  actionedById?: InputMaybe<IntNullableFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<IntFilter>;
  image?: InputMaybe<ImageWhereInput>;
  imageId?: InputMaybe<IntFilter>;
  reason?: InputMaybe<StringNullableFilter>;
  reportedBy?: InputMaybe<UserWhereInput>;
  reportedById?: InputMaybe<IntFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type ImageReportWhereUniqueInput = {
  id?: InputMaybe<Scalars['Int']>;
  imageReportUser?: InputMaybe<ImageReportImageReportUserCompoundUniqueInput>;
};

export type ImageTag = {
  __typename?: 'ImageTag';
  addedBy?: Maybe<User>;
  createdAt: Scalars['DateTime'];
  image: Image;
  tag: Tag;
  updatedAt: Scalars['DateTime'];
};

export type ImageTagImageTagCompoundUniqueInput = {
  imageId: Scalars['Int'];
  tagId: Scalars['Int'];
};

export type ImageTagListRelationFilter = {
  every?: InputMaybe<ImageTagWhereInput>;
  none?: InputMaybe<ImageTagWhereInput>;
  some?: InputMaybe<ImageTagWhereInput>;
};

export type ImageTagOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type ImageTagWhereInput = {
  AND?: InputMaybe<Array<ImageTagWhereInput>>;
  NOT?: InputMaybe<Array<ImageTagWhereInput>>;
  OR?: InputMaybe<Array<ImageTagWhereInput>>;
  addedBy?: InputMaybe<UserWhereInput>;
  addedById?: InputMaybe<IntNullableFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<IntFilter>;
  image?: InputMaybe<ImageWhereInput>;
  imageId?: InputMaybe<IntFilter>;
  tag?: InputMaybe<TagWhereInput>;
  tagId?: InputMaybe<IntFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type ImageTagWhereUniqueInput = {
  id?: InputMaybe<Scalars['Int']>;
  imageTag?: InputMaybe<ImageTagImageTagCompoundUniqueInput>;
};

export type ImageWhereInput = {
  AND?: InputMaybe<Array<ImageWhereInput>>;
  NOT?: InputMaybe<Array<ImageWhereInput>>;
  OR?: InputMaybe<Array<ImageWhereInput>>;
  appearanceTags?: InputMaybe<AppearanceTagListRelationFilter>;
  appearances?: InputMaybe<AppearanceListRelationFilter>;
  bytes?: InputMaybe<IntFilter>;
  caption?: InputMaybe<StringNullableFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  destination?: InputMaybe<EnumUploadDestinationFilter>;
  discoverySource?: InputMaybe<DiscoveredImageWhereInput>;
  faceScanDate?: InputMaybe<DateTimeNullableFilter>;
  faceScanRequestDate?: InputMaybe<DateTimeNullableFilter>;
  faces?: InputMaybe<FaceListRelationFilter>;
  fileName?: InputMaybe<StringNullableFilter>;
  groupAvatarOf?: InputMaybe<GroupWhereInput>;
  groupBannerOf?: InputMaybe<GroupWhereInput>;
  hash?: InputMaybe<StringFilter>;
  height?: InputMaybe<IntFilter>;
  hiddenAt?: InputMaybe<DateTimeNullableFilter>;
  id?: InputMaybe<IntFilter>;
  imageTags?: InputMaybe<ImageTagListRelationFilter>;
  ireneBotId?: InputMaybe<IntNullableFilter>;
  isNsfw?: InputMaybe<BoolFilter>;
  likes?: InputMaybe<ImageLikeListRelationFilter>;
  mimetype?: InputMaybe<EnumMimeTypeFilter>;
  pHash?: InputMaybe<StringNullableFilter>;
  palette?: InputMaybe<IntNullableListFilter>;
  personAvatarOf?: InputMaybe<PersonWhereInput>;
  personBannerOf?: InputMaybe<PersonWhereInput>;
  potentialDuplicates?: InputMaybe<DiscoveredImageListRelationFilter>;
  public?: InputMaybe<BoolFilter>;
  reports?: InputMaybe<ImageReportListRelationFilter>;
  slug?: InputMaybe<StringFilter>;
  source?: InputMaybe<StringNullableFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  uploadType?: InputMaybe<EnumUploadTypeFilter>;
  user?: InputMaybe<UserWhereInput>;
  userAvatarOf?: InputMaybe<UserWhereInput>;
  userBannerOf?: InputMaybe<UserWhereInput>;
  userId?: InputMaybe<IntNullableFilter>;
  views?: InputMaybe<IntFilter>;
  width?: InputMaybe<IntFilter>;
  xp?: InputMaybe<IntFilter>;
};

export type ImageWhereUniqueInput = {
  id?: InputMaybe<Scalars['Int']>;
  ireneBotId?: InputMaybe<Scalars['Int']>;
  slug?: InputMaybe<Scalars['String']>;
};

export type IntFilter = {
  equals?: InputMaybe<Scalars['Int']>;
  gt?: InputMaybe<Scalars['Int']>;
  gte?: InputMaybe<Scalars['Int']>;
  in?: InputMaybe<Array<Scalars['Int']>>;
  lt?: InputMaybe<Scalars['Int']>;
  lte?: InputMaybe<Scalars['Int']>;
  not?: InputMaybe<NestedIntFilter>;
  notIn?: InputMaybe<Array<Scalars['Int']>>;
};

export type IntNullableFilter = {
  equals?: InputMaybe<Scalars['Int']>;
  gt?: InputMaybe<Scalars['Int']>;
  gte?: InputMaybe<Scalars['Int']>;
  in?: InputMaybe<Array<Scalars['Int']>>;
  lt?: InputMaybe<Scalars['Int']>;
  lte?: InputMaybe<Scalars['Int']>;
  not?: InputMaybe<NestedIntNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['Int']>>;
};

export type IntNullableListFilter = {
  equals?: InputMaybe<Array<Scalars['Int']>>;
  has?: InputMaybe<Scalars['Int']>;
  hasEvery?: InputMaybe<Array<Scalars['Int']>>;
  hasSome?: InputMaybe<Array<Scalars['Int']>>;
  isEmpty?: InputMaybe<Scalars['Boolean']>;
};

export type LeaderboardUser = {
  __typename?: 'LeaderboardUser';
  rank: Scalars['Int'];
  user: User;
  xp: Scalars['Int'];
};

export enum MimeType {
  Avif = 'AVIF',
  Gif = 'GIF',
  Jpg = 'JPG',
  Mp4 = 'MP4',
  Png = 'PNG',
  Svg = 'SVG',
  Webm = 'WEBM',
  Webp = 'WEBP'
}

export type Mutation = {
  __typename?: 'Mutation';
  /** Add an appearance relation on an image. */
  addAppearance: Appearance;
  addProvider: Scalars['String'];
  createAppearanceTag: AppearanceTag;
  createImageTag: ImageTag;
  createTag: Tag;
  deleteAppearanceTag?: Maybe<AppearanceTag>;
  deleteImageTag?: Maybe<ImageTag>;
  discoveredImageVote: DiscoveredImageVote;
  /** Vote using the same verdict on all images in a post */
  discoveredPostVote: Array<DiscoveredImage>;
  /** Action on an image reported by a user. Only usable by moderators */
  imageReportAction?: Maybe<ImageReport>;
  /** Attach an existing face to an apperance. */
  linkFace: Appearance;
  /** Removes an appearance from an image */
  removeAppearance: Appearance;
  reportImage?: Maybe<ImageReport>;
  /** Queue an image to get scanned for faces */
  scanFaces: QueueInfo;
  toggleLike: Image;
  /** Unlinks an existing face from an appearance. This dissociates the face from the appearance but does not remove the face data */
  unlinkFace: Scalars['Int'];
  updatePerson?: Maybe<Person>;
};


export type MutationAddAppearanceArgs = {
  imageId: Scalars['Int'];
  personId: Scalars['Int'];
};


export type MutationAddProviderArgs = {
  provider: AddProviderInput;
};


export type MutationCreateAppearanceTagArgs = {
  appearanceId: Scalars['Int'];
  name: Scalars['String'];
};


export type MutationCreateImageTagArgs = {
  imageId: Scalars['Int'];
  name: Scalars['String'];
};


export type MutationCreateTagArgs = {
  name: Scalars['String'];
};


export type MutationDeleteAppearanceTagArgs = {
  appearanceId: Scalars['Int'];
  name: Scalars['String'];
};


export type MutationDeleteImageTagArgs = {
  imageId: Scalars['Int'];
  name: Scalars['String'];
};


export type MutationDiscoveredImageVoteArgs = {
  imageId: Scalars['Int'];
  reason?: InputMaybe<Scalars['String']>;
  verdict: Scalars['String'];
};


export type MutationDiscoveredPostVoteArgs = {
  postId: Scalars['Int'];
  reason?: InputMaybe<Scalars['String']>;
  verdict: Scalars['String'];
};


export type MutationImageReportActionArgs = {
  action: ImageReportAction;
  reportId: Scalars['Int'];
};


export type MutationLinkFaceArgs = {
  appearanceId: Scalars['Int'];
  faceId: Scalars['Int'];
};


export type MutationRemoveAppearanceArgs = {
  appearanceId: Scalars['Int'];
};


export type MutationReportImageArgs = {
  imageId: Scalars['Int'];
  reason?: InputMaybe<Scalars['String']>;
};


export type MutationScanFacesArgs = {
  slug: Scalars['String'];
};


export type MutationToggleLikeArgs = {
  imageId: Scalars['Int'];
};


export type MutationUnlinkFaceArgs = {
  appearanceId: Scalars['Int'];
  faceId: Scalars['Int'];
};


export type MutationUpdatePersonArgs = {
  id: Scalars['Int'];
  update: UpdatePersonInputs;
};

export type NestedBoolFilter = {
  equals?: InputMaybe<Scalars['Boolean']>;
  not?: InputMaybe<NestedBoolFilter>;
};

export type NestedDateTimeFilter = {
  equals?: InputMaybe<Scalars['DateTime']>;
  gt?: InputMaybe<Scalars['DateTime']>;
  gte?: InputMaybe<Scalars['DateTime']>;
  in?: InputMaybe<Array<Scalars['DateTime']>>;
  lt?: InputMaybe<Scalars['DateTime']>;
  lte?: InputMaybe<Scalars['DateTime']>;
  not?: InputMaybe<NestedDateTimeFilter>;
  notIn?: InputMaybe<Array<Scalars['DateTime']>>;
};

export type NestedDateTimeNullableFilter = {
  equals?: InputMaybe<Scalars['DateTime']>;
  gt?: InputMaybe<Scalars['DateTime']>;
  gte?: InputMaybe<Scalars['DateTime']>;
  in?: InputMaybe<Array<Scalars['DateTime']>>;
  lt?: InputMaybe<Scalars['DateTime']>;
  lte?: InputMaybe<Scalars['DateTime']>;
  not?: InputMaybe<NestedDateTimeNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['DateTime']>>;
};

export type NestedEnumFaceSourceFilter = {
  equals?: InputMaybe<FaceSource>;
  in?: InputMaybe<Array<FaceSource>>;
  not?: InputMaybe<NestedEnumFaceSourceFilter>;
  notIn?: InputMaybe<Array<FaceSource>>;
};

export type NestedEnumGameParticipantKindFilter = {
  equals?: InputMaybe<GameParticipantKind>;
  in?: InputMaybe<Array<GameParticipantKind>>;
  not?: InputMaybe<NestedEnumGameParticipantKindFilter>;
  notIn?: InputMaybe<Array<GameParticipantKind>>;
};

export type NestedEnumGenderNullableFilter = {
  equals?: InputMaybe<Gender>;
  in?: InputMaybe<Array<Gender>>;
  not?: InputMaybe<NestedEnumGenderNullableFilter>;
  notIn?: InputMaybe<Array<Gender>>;
};

export type NestedEnumGuessingGameHintsFilter = {
  equals?: InputMaybe<GuessingGameHints>;
  in?: InputMaybe<Array<GuessingGameHints>>;
  not?: InputMaybe<NestedEnumGuessingGameHintsFilter>;
  notIn?: InputMaybe<Array<GuessingGameHints>>;
};

export type NestedEnumImageReportActionNullableFilter = {
  equals?: InputMaybe<ImageReportAction>;
  in?: InputMaybe<Array<ImageReportAction>>;
  not?: InputMaybe<NestedEnumImageReportActionNullableFilter>;
  notIn?: InputMaybe<Array<ImageReportAction>>;
};

export type NestedEnumMimeTypeFilter = {
  equals?: InputMaybe<MimeType>;
  in?: InputMaybe<Array<MimeType>>;
  not?: InputMaybe<NestedEnumMimeTypeFilter>;
  notIn?: InputMaybe<Array<MimeType>>;
};

export type NestedEnumRestrictionKindFilter = {
  equals?: InputMaybe<RestrictionKind>;
  in?: InputMaybe<Array<RestrictionKind>>;
  not?: InputMaybe<NestedEnumRestrictionKindFilter>;
  notIn?: InputMaybe<Array<RestrictionKind>>;
};

export type NestedEnumTagSourceFilter = {
  equals?: InputMaybe<TagSource>;
  in?: InputMaybe<Array<TagSource>>;
  not?: InputMaybe<NestedEnumTagSourceFilter>;
  notIn?: InputMaybe<Array<TagSource>>;
};

export type NestedEnumUploadDestinationFilter = {
  equals?: InputMaybe<UploadDestination>;
  in?: InputMaybe<Array<UploadDestination>>;
  not?: InputMaybe<NestedEnumUploadDestinationFilter>;
  notIn?: InputMaybe<Array<UploadDestination>>;
};

export type NestedEnumUploadTypeFilter = {
  equals?: InputMaybe<UploadType>;
  in?: InputMaybe<Array<UploadType>>;
  not?: InputMaybe<NestedEnumUploadTypeFilter>;
  notIn?: InputMaybe<Array<UploadType>>;
};

export type NestedFloatFilter = {
  equals?: InputMaybe<Scalars['Float']>;
  gt?: InputMaybe<Scalars['Float']>;
  gte?: InputMaybe<Scalars['Float']>;
  in?: InputMaybe<Array<Scalars['Float']>>;
  lt?: InputMaybe<Scalars['Float']>;
  lte?: InputMaybe<Scalars['Float']>;
  not?: InputMaybe<NestedFloatFilter>;
  notIn?: InputMaybe<Array<Scalars['Float']>>;
};

export type NestedIntFilter = {
  equals?: InputMaybe<Scalars['Int']>;
  gt?: InputMaybe<Scalars['Int']>;
  gte?: InputMaybe<Scalars['Int']>;
  in?: InputMaybe<Array<Scalars['Int']>>;
  lt?: InputMaybe<Scalars['Int']>;
  lte?: InputMaybe<Scalars['Int']>;
  not?: InputMaybe<NestedIntFilter>;
  notIn?: InputMaybe<Array<Scalars['Int']>>;
};

export type NestedIntNullableFilter = {
  equals?: InputMaybe<Scalars['Int']>;
  gt?: InputMaybe<Scalars['Int']>;
  gte?: InputMaybe<Scalars['Int']>;
  in?: InputMaybe<Array<Scalars['Int']>>;
  lt?: InputMaybe<Scalars['Int']>;
  lte?: InputMaybe<Scalars['Int']>;
  not?: InputMaybe<NestedIntNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['Int']>>;
};

export type NestedStringFilter = {
  contains?: InputMaybe<Scalars['String']>;
  endsWith?: InputMaybe<Scalars['String']>;
  equals?: InputMaybe<Scalars['String']>;
  gt?: InputMaybe<Scalars['String']>;
  gte?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<Array<Scalars['String']>>;
  lt?: InputMaybe<Scalars['String']>;
  lte?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<NestedStringFilter>;
  notIn?: InputMaybe<Array<Scalars['String']>>;
  startsWith?: InputMaybe<Scalars['String']>;
};

export type NestedStringNullableFilter = {
  contains?: InputMaybe<Scalars['String']>;
  endsWith?: InputMaybe<Scalars['String']>;
  equals?: InputMaybe<Scalars['String']>;
  gt?: InputMaybe<Scalars['String']>;
  gte?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<Array<Scalars['String']>>;
  lt?: InputMaybe<Scalars['String']>;
  lte?: InputMaybe<Scalars['String']>;
  not?: InputMaybe<NestedStringNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['String']>>;
  startsWith?: InputMaybe<Scalars['String']>;
};

export type Person = {
  __typename?: 'Person';
  aliases: Array<Alias>;
  appearances: Array<Appearance>;
  avatar?: Maybe<Image>;
  banner?: Maybe<Image>;
  birthDate?: Maybe<Scalars['DateTime']>;
  createdAt: Scalars['DateTime'];
  faces: Array<Face>;
  id: Scalars['Int'];
  memberOf: Array<GroupMember>;
  name: Scalars['String'];
  preferredAlias?: Maybe<Alias>;
  preferredMembership?: Maybe<GroupMember>;
  updatedAt: Scalars['DateTime'];
};


export type PersonAliasesArgs = {
  cursor?: InputMaybe<AliasWhereUniqueInput>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
};


export type PersonAppearancesArgs = {
  cursor?: InputMaybe<AppearanceWhereUniqueInput>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
};


export type PersonFacesArgs = {
  cursor?: InputMaybe<FaceWhereUniqueInput>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
};


export type PersonMemberOfArgs = {
  cursor?: InputMaybe<GroupMemberWhereUniqueInput>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
};

export type PersonListRelationFilter = {
  every?: InputMaybe<PersonWhereInput>;
  none?: InputMaybe<PersonWhereInput>;
  some?: InputMaybe<PersonWhereInput>;
};

export type PersonOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type PersonOrderByWithRelationInput = {
  aliases?: InputMaybe<AliasOrderByRelationAggregateInput>;
  appearances?: InputMaybe<AppearanceOrderByRelationAggregateInput>;
  appearsIn?: InputMaybe<FaceOrderByRelationAggregateInput>;
  avatar?: InputMaybe<ImageOrderByWithRelationInput>;
  avatarId?: InputMaybe<SortOrder>;
  banner?: InputMaybe<ImageOrderByWithRelationInput>;
  bannerId?: InputMaybe<SortOrder>;
  birthDate?: InputMaybe<SortOrder>;
  createdAt?: InputMaybe<SortOrder>;
  description?: InputMaybe<SortOrder>;
  gender?: InputMaybe<SortOrder>;
  guessingGameGuesses?: InputMaybe<GuessingGameGuessOrderByRelationAggregateInput>;
  guessingGameTargets?: InputMaybe<GuessingGameTargetOrderByRelationAggregateInput>;
  id?: InputMaybe<SortOrder>;
  ireneBotId?: InputMaybe<SortOrder>;
  memberOf?: InputMaybe<GroupMemberOrderByRelationAggregateInput>;
  name?: InputMaybe<SortOrder>;
  preferredAlias?: InputMaybe<AliasOrderByWithRelationInput>;
  preferredAliasId?: InputMaybe<SortOrder>;
  preferredMembership?: InputMaybe<GroupMemberOrderByWithRelationInput>;
  preferredMembershipId?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type PersonWhereInput = {
  AND?: InputMaybe<Array<PersonWhereInput>>;
  NOT?: InputMaybe<Array<PersonWhereInput>>;
  OR?: InputMaybe<Array<PersonWhereInput>>;
  aliases?: InputMaybe<AliasListRelationFilter>;
  appearances?: InputMaybe<AppearanceListRelationFilter>;
  appearsIn?: InputMaybe<FaceListRelationFilter>;
  avatar?: InputMaybe<ImageWhereInput>;
  avatarId?: InputMaybe<IntNullableFilter>;
  banner?: InputMaybe<ImageWhereInput>;
  bannerId?: InputMaybe<IntNullableFilter>;
  birthDate?: InputMaybe<DateTimeNullableFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  description?: InputMaybe<StringNullableFilter>;
  gender?: InputMaybe<EnumGenderNullableFilter>;
  guessingGameGuesses?: InputMaybe<GuessingGameGuessListRelationFilter>;
  guessingGameTargets?: InputMaybe<GuessingGameTargetListRelationFilter>;
  id?: InputMaybe<IntFilter>;
  ireneBotId?: InputMaybe<IntNullableFilter>;
  memberOf?: InputMaybe<GroupMemberListRelationFilter>;
  name?: InputMaybe<StringFilter>;
  preferredAlias?: InputMaybe<AliasWhereInput>;
  preferredAliasId?: InputMaybe<IntNullableFilter>;
  preferredMembership?: InputMaybe<GroupMemberWhereInput>;
  preferredMembershipId?: InputMaybe<IntNullableFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type PersonWhereUniqueInput = {
  avatarId?: InputMaybe<Scalars['Int']>;
  bannerId?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['Int']>;
  ireneBotId?: InputMaybe<Scalars['Int']>;
  preferredAliasId?: InputMaybe<Scalars['Int']>;
};

/** Statistics associated with each provider */
export type ProviderStatistic = {
  __typename?: 'ProviderStatistic';
  createdAt?: Maybe<Scalars['DateTime']>;
  defaultName?: Maybe<Scalars['String']>;
  destination: Scalars['String'];
  discoveredImages: Scalars['Int'];
  enabled: Scalars['Boolean'];
  lastPost?: Maybe<Scalars['DateTime']>;
  lastScrape?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  official: Scalars['Boolean'];
  priority: Scalars['Float'];
  scrapeCount: Scalars['Int'];
  tokens: Scalars['Float'];
  url: Scalars['String'];
};

export type Query = {
  __typename?: 'Query';
  countAppearances: Array<AppearanceCount>;
  discoveredImages: Array<DiscoveredImage>;
  discoveredPosts: Array<DiscoveredPost>;
  discoveryFeed: Array<DiscoveredPost>;
  discoveryHistory: Array<DiscoveredPost>;
  discoveryLeaderboard: Array<LeaderboardUser>;
  discoveryProviders: Array<ProviderStatistic>;
  discoverySchedule: Array<DiscoveryProvider>;
  discoveryStats: Array<DiscoveryStatistic>;
  group?: Maybe<Group>;
  groups: Array<Group>;
  /** Find a single image by its slug. */
  image?: Maybe<Image>;
  imageConnections?: Maybe<ImageConnections>;
  imageReports: Array<ImageReport>;
  images: Array<Image>;
  me?: Maybe<User>;
  notifications: UserNotifications;
  people: Array<Person>;
  person?: Maybe<Person>;
  user?: Maybe<User>;
};


export type QueryCountAppearancesArgs = {
  groups: Array<Scalars['Int']>;
};


export type QueryDiscoveredImagesArgs = {
  cursor?: InputMaybe<DiscoveredImageWhereUniqueInput>;
  orderBy?: InputMaybe<Array<DiscoveredImageOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<DiscoveredImageWhereInput>;
};


export type QueryDiscoveredPostsArgs = {
  cursor?: InputMaybe<DiscoveredPostWhereUniqueInput>;
  orderBy?: InputMaybe<Array<DiscoveredPostOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<DiscoveredPostWhereInput>;
};


export type QueryDiscoveryFeedArgs = {
  groupIds: Array<Scalars['Int']>;
  peopleIds: Array<Scalars['Int']>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
};


export type QueryDiscoveryHistoryArgs = {
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
};


export type QueryDiscoveryLeaderboardArgs = {
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
};


export type QueryGroupArgs = {
  where: GroupWhereUniqueInput;
};


export type QueryGroupsArgs = {
  cursor?: InputMaybe<GroupWhereUniqueInput>;
  orderBy?: InputMaybe<Array<GroupOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<GroupWhereInput>;
};


export type QueryImageArgs = {
  slug: Scalars['String'];
};


export type QueryImageConnectionsArgs = {
  depth?: Scalars['Int'];
  slug: Scalars['String'];
};


export type QueryImageReportsArgs = {
  cursor?: InputMaybe<ImageReportWhereUniqueInput>;
  orderBy?: InputMaybe<Array<ImageReportOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ImageReportWhereInput>;
};


export type QueryImagesArgs = {
  cursor?: InputMaybe<ImageWhereUniqueInput>;
  orderBy?: InputMaybe<Array<ImageOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ImageWhereInput>;
};


export type QueryPeopleArgs = {
  cursor?: InputMaybe<PersonWhereUniqueInput>;
  orderBy?: InputMaybe<Array<PersonOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<PersonWhereInput>;
};


export type QueryPersonArgs = {
  where: PersonWhereUniqueInput;
};


export type QueryUserArgs = {
  id?: InputMaybe<Scalars['Int']>;
};

export enum QueryMode {
  Default = 'default',
  Insensitive = 'insensitive'
}

export type QueueInfo = {
  __typename?: 'QueueInfo';
  queueSize: Scalars['Int'];
};

export enum RestrictionKind {
  NoImageReport = 'NO_IMAGE_REPORT'
}

export type Role = {
  __typename?: 'Role';
  createdAt: Scalars['DateTime'];
  name: Scalars['String'];
};

export type RoleListRelationFilter = {
  every?: InputMaybe<RoleWhereInput>;
  none?: InputMaybe<RoleWhereInput>;
  some?: InputMaybe<RoleWhereInput>;
};

export type RoleOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type RoleWhereInput = {
  AND?: InputMaybe<Array<RoleWhereInput>>;
  NOT?: InputMaybe<Array<RoleWhereInput>>;
  OR?: InputMaybe<Array<RoleWhereInput>>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<IntFilter>;
  name?: InputMaybe<StringFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  user?: InputMaybe<UserWhereInput>;
  userId?: InputMaybe<IntFilter>;
};

export enum SortOrder {
  Asc = 'asc',
  Desc = 'desc'
}

export type StringFilter = {
  contains?: InputMaybe<Scalars['String']>;
  endsWith?: InputMaybe<Scalars['String']>;
  equals?: InputMaybe<Scalars['String']>;
  gt?: InputMaybe<Scalars['String']>;
  gte?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<Array<Scalars['String']>>;
  lt?: InputMaybe<Scalars['String']>;
  lte?: InputMaybe<Scalars['String']>;
  mode?: InputMaybe<QueryMode>;
  not?: InputMaybe<NestedStringFilter>;
  notIn?: InputMaybe<Array<Scalars['String']>>;
  startsWith?: InputMaybe<Scalars['String']>;
};

export type StringNullableFilter = {
  contains?: InputMaybe<Scalars['String']>;
  endsWith?: InputMaybe<Scalars['String']>;
  equals?: InputMaybe<Scalars['String']>;
  gt?: InputMaybe<Scalars['String']>;
  gte?: InputMaybe<Scalars['String']>;
  in?: InputMaybe<Array<Scalars['String']>>;
  lt?: InputMaybe<Scalars['String']>;
  lte?: InputMaybe<Scalars['String']>;
  mode?: InputMaybe<QueryMode>;
  not?: InputMaybe<NestedStringNullableFilter>;
  notIn?: InputMaybe<Array<Scalars['String']>>;
  startsWith?: InputMaybe<Scalars['String']>;
};

export type Tag = {
  __typename?: 'Tag';
  addedBy?: Maybe<User>;
  aliases: Array<TagAlias>;
  category?: Maybe<TagCategory>;
  createdAt: Scalars['DateTime'];
  name: Scalars['String'];
  source: TagSource;
};


export type TagAliasesArgs = {
  cursor?: InputMaybe<TagAliasWhereUniqueInput>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
};

export type TagAlias = {
  __typename?: 'TagAlias';
  addedBy?: Maybe<User>;
  createdAt: Scalars['DateTime'];
  name: Scalars['String'];
  tag: Tag;
  updatedAt: Scalars['DateTime'];
};

export type TagAliasAliasTagCompoundUniqueInput = {
  name: Scalars['String'];
  tagId: Scalars['Int'];
};

export type TagAliasListRelationFilter = {
  every?: InputMaybe<TagAliasWhereInput>;
  none?: InputMaybe<TagAliasWhereInput>;
  some?: InputMaybe<TagAliasWhereInput>;
};

export type TagAliasOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type TagAliasWhereInput = {
  AND?: InputMaybe<Array<TagAliasWhereInput>>;
  NOT?: InputMaybe<Array<TagAliasWhereInput>>;
  OR?: InputMaybe<Array<TagAliasWhereInput>>;
  addedBy?: InputMaybe<UserWhereInput>;
  addedById?: InputMaybe<IntNullableFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<IntFilter>;
  name?: InputMaybe<StringFilter>;
  tag?: InputMaybe<TagWhereInput>;
  tagId?: InputMaybe<IntFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type TagAliasWhereUniqueInput = {
  aliasTag?: InputMaybe<TagAliasAliasTagCompoundUniqueInput>;
  id?: InputMaybe<Scalars['Int']>;
};

export type TagCategory = {
  __typename?: 'TagCategory';
  addedBy?: Maybe<User>;
  createdAt: Scalars['DateTime'];
  name: Scalars['String'];
  updatedAt: Scalars['DateTime'];
};

export type TagCategoryListRelationFilter = {
  every?: InputMaybe<TagCategoryWhereInput>;
  none?: InputMaybe<TagCategoryWhereInput>;
  some?: InputMaybe<TagCategoryWhereInput>;
};

export type TagCategoryOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type TagCategoryWhereInput = {
  AND?: InputMaybe<Array<TagCategoryWhereInput>>;
  NOT?: InputMaybe<Array<TagCategoryWhereInput>>;
  OR?: InputMaybe<Array<TagCategoryWhereInput>>;
  addedBy?: InputMaybe<UserWhereInput>;
  addedById?: InputMaybe<IntNullableFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<IntFilter>;
  name?: InputMaybe<StringFilter>;
  tags?: InputMaybe<TagListRelationFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type TagListRelationFilter = {
  every?: InputMaybe<TagWhereInput>;
  none?: InputMaybe<TagWhereInput>;
  some?: InputMaybe<TagWhereInput>;
};

export type TagOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export enum TagSource {
  User = 'USER'
}

export type TagWhereInput = {
  AND?: InputMaybe<Array<TagWhereInput>>;
  NOT?: InputMaybe<Array<TagWhereInput>>;
  OR?: InputMaybe<Array<TagWhereInput>>;
  addedBy?: InputMaybe<UserWhereInput>;
  addedById?: InputMaybe<IntNullableFilter>;
  aliases?: InputMaybe<TagAliasListRelationFilter>;
  appearances?: InputMaybe<AppearanceTagListRelationFilter>;
  category?: InputMaybe<TagCategoryWhereInput>;
  categoryId?: InputMaybe<IntNullableFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<IntFilter>;
  images?: InputMaybe<ImageTagListRelationFilter>;
  name?: InputMaybe<StringFilter>;
  source?: InputMaybe<EnumTagSourceFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

/** Preview urls of an image */
export type Thumbnail = {
  __typename?: 'Thumbnail';
  large: Scalars['String'];
  medium: Scalars['String'];
  small: Scalars['String'];
};

export type UpdatePersonInputs = {
  aliases: Array<Scalars['String']>;
  avatarId?: InputMaybe<Scalars['Int']>;
  bannerId?: InputMaybe<Scalars['Int']>;
  birthDate?: InputMaybe<Scalars['DateTime']>;
  description?: InputMaybe<Scalars['String']>;
  gender?: InputMaybe<Gender>;
  groups: Array<GroupMembership>;
  name: Scalars['String'];
  preferredAliasId?: InputMaybe<Scalars['Int']>;
  preferredMembershipId?: InputMaybe<Scalars['Int']>;
};

export enum UploadDestination {
  Local = 'Local',
  S3 = 'S3'
}

export enum UploadType {
  AutoDiscovery = 'AUTO_DISCOVERY',
  Token = 'TOKEN',
  Website = 'WEBSITE'
}

export type User = {
  __typename?: 'User';
  avatar?: Maybe<Scalars['String']>;
  bot: Scalars['Boolean'];
  createdAt: Scalars['DateTime'];
  id: Scalars['Int'];
  images: Array<Image>;
  name?: Maybe<Scalars['String']>;
  roles: Array<Role>;
  xp?: Maybe<Scalars['Int']>;
};


export type UserImagesArgs = {
  cursor?: InputMaybe<ImageWhereUniqueInput>;
  orderBy?: InputMaybe<Array<ImageOrderByWithRelationInput>>;
  skip?: InputMaybe<Scalars['Int']>;
  take?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ImageWhereInput>;
};

export type UserNotifications = {
  __typename?: 'UserNotifications';
  unreadReports?: Maybe<Scalars['Int']>;
};

export type UserOrderByWithRelationInput = {
  DiscoveredImageVote?: InputMaybe<DiscoveredImageVoteOrderByRelationAggregateInput>;
  actionedReportedImages?: InputMaybe<ImageReportOrderByRelationAggregateInput>;
  appearanceTags?: InputMaybe<AppearanceTagOrderByRelationAggregateInput>;
  avatar?: InputMaybe<ImageOrderByWithRelationInput>;
  avatarId?: InputMaybe<SortOrder>;
  banner?: InputMaybe<ImageOrderByWithRelationInput>;
  bannerId?: InputMaybe<SortOrder>;
  bot?: InputMaybe<SortOrder>;
  cratedTags?: InputMaybe<TagOrderByRelationAggregateInput>;
  createdAt?: InputMaybe<SortOrder>;
  email?: InputMaybe<SortOrder>;
  emailVerified?: InputMaybe<SortOrder>;
  guessingGameGuesses?: InputMaybe<GuessingGameGuessOrderByRelationAggregateInput>;
  guessingGameParticipations?: InputMaybe<GuessingGameParticipantOrderByRelationAggregateInput>;
  guessingGamesHosted?: InputMaybe<GuessingGameOrderByRelationAggregateInput>;
  id?: InputMaybe<SortOrder>;
  image?: InputMaybe<SortOrder>;
  imageLikes?: InputMaybe<ImageLikeOrderByRelationAggregateInput>;
  imageTags?: InputMaybe<ImageTagOrderByRelationAggregateInput>;
  images?: InputMaybe<ImageOrderByRelationAggregateInput>;
  markedFaces?: InputMaybe<FaceOrderByRelationAggregateInput>;
  name?: InputMaybe<SortOrder>;
  placedRestrictions?: InputMaybe<UserRestrictionOrderByRelationAggregateInput>;
  reportedImages?: InputMaybe<ImageReportOrderByRelationAggregateInput>;
  restrictions?: InputMaybe<UserRestrictionOrderByRelationAggregateInput>;
  roles?: InputMaybe<RoleOrderByRelationAggregateInput>;
  tagAliases?: InputMaybe<TagAliasOrderByRelationAggregateInput>;
  tagCategories?: InputMaybe<TagCategoryOrderByRelationAggregateInput>;
  taggedAppearances?: InputMaybe<AppearanceOrderByRelationAggregateInput>;
  token?: InputMaybe<SortOrder>;
  updatedAt?: InputMaybe<SortOrder>;
};

export type UserRestrictionListRelationFilter = {
  every?: InputMaybe<UserRestrictionWhereInput>;
  none?: InputMaybe<UserRestrictionWhereInput>;
  some?: InputMaybe<UserRestrictionWhereInput>;
};

export type UserRestrictionOrderByRelationAggregateInput = {
  _count?: InputMaybe<SortOrder>;
};

export type UserRestrictionWhereInput = {
  AND?: InputMaybe<Array<UserRestrictionWhereInput>>;
  NOT?: InputMaybe<Array<UserRestrictionWhereInput>>;
  OR?: InputMaybe<Array<UserRestrictionWhereInput>>;
  addedBy?: InputMaybe<UserWhereInput>;
  addedById?: InputMaybe<IntNullableFilter>;
  associatedEntityId?: InputMaybe<IntNullableFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  id?: InputMaybe<IntFilter>;
  restriction?: InputMaybe<EnumRestrictionKindFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
  user?: InputMaybe<UserWhereInput>;
  userId?: InputMaybe<IntFilter>;
};

export type UserWhereInput = {
  AND?: InputMaybe<Array<UserWhereInput>>;
  DiscoveredImageVote?: InputMaybe<DiscoveredImageVoteListRelationFilter>;
  NOT?: InputMaybe<Array<UserWhereInput>>;
  OR?: InputMaybe<Array<UserWhereInput>>;
  actionedReportedImages?: InputMaybe<ImageReportListRelationFilter>;
  appearanceTags?: InputMaybe<AppearanceTagListRelationFilter>;
  avatar?: InputMaybe<ImageWhereInput>;
  avatarId?: InputMaybe<IntNullableFilter>;
  banner?: InputMaybe<ImageWhereInput>;
  bannerId?: InputMaybe<IntNullableFilter>;
  bot?: InputMaybe<BoolFilter>;
  cratedTags?: InputMaybe<TagListRelationFilter>;
  createdAt?: InputMaybe<DateTimeFilter>;
  email?: InputMaybe<StringNullableFilter>;
  emailVerified?: InputMaybe<DateTimeNullableFilter>;
  guessingGameGuesses?: InputMaybe<GuessingGameGuessListRelationFilter>;
  guessingGameParticipations?: InputMaybe<GuessingGameParticipantListRelationFilter>;
  guessingGamesHosted?: InputMaybe<GuessingGameListRelationFilter>;
  id?: InputMaybe<IntFilter>;
  image?: InputMaybe<StringNullableFilter>;
  imageLikes?: InputMaybe<ImageLikeListRelationFilter>;
  imageTags?: InputMaybe<ImageTagListRelationFilter>;
  images?: InputMaybe<ImageListRelationFilter>;
  markedFaces?: InputMaybe<FaceListRelationFilter>;
  name?: InputMaybe<StringNullableFilter>;
  placedRestrictions?: InputMaybe<UserRestrictionListRelationFilter>;
  reportedImages?: InputMaybe<ImageReportListRelationFilter>;
  restrictions?: InputMaybe<UserRestrictionListRelationFilter>;
  roles?: InputMaybe<RoleListRelationFilter>;
  tagAliases?: InputMaybe<TagAliasListRelationFilter>;
  tagCategories?: InputMaybe<TagCategoryListRelationFilter>;
  taggedAppearances?: InputMaybe<AppearanceListRelationFilter>;
  token?: InputMaybe<StringNullableFilter>;
  updatedAt?: InputMaybe<DateTimeFilter>;
};

export type PersonGridDataFragment = { __typename?: 'Person', id: number, name: string, avatar?: { __typename?: 'Image', thumbnail: { __typename?: 'Thumbnail', medium: string } } | null, preferredMembership?: { __typename?: 'GroupMember', group: { __typename?: 'Group', name: string } } | null, preferredAlias?: { __typename?: 'Alias', name: string } | null };

export type BrowsePageIdolsWithFilterQueryVariables = Exact<{
  skip: Scalars['Int'];
  take: Scalars['Int'];
  groups: Array<Scalars['Int']> | Scalars['Int'];
}>;


export type BrowsePageIdolsWithFilterQuery = { __typename?: 'Query', people: Array<{ __typename?: 'Person', id: number, name: string, avatar?: { __typename?: 'Image', thumbnail: { __typename?: 'Thumbnail', medium: string } } | null, preferredMembership?: { __typename?: 'GroupMember', group: { __typename?: 'Group', name: string } } | null, preferredAlias?: { __typename?: 'Alias', name: string } | null }> };

export type BrowsePageIdolsQueryVariables = Exact<{
  skip: Scalars['Int'];
  take: Scalars['Int'];
}>;


export type BrowsePageIdolsQuery = { __typename?: 'Query', people: Array<{ __typename?: 'Person', id: number, name: string, avatar?: { __typename?: 'Image', thumbnail: { __typename?: 'Thumbnail', medium: string } } | null, preferredMembership?: { __typename?: 'GroupMember', group: { __typename?: 'Group', name: string } } | null, preferredAlias?: { __typename?: 'Alias', name: string } | null }> };

export type BrowsePageQueryVariables = Exact<{
  take: Scalars['Int'];
  skip?: InputMaybe<Scalars['Int']>;
}>;


export type BrowsePageQuery = { __typename?: 'Query', images: Array<{ __typename?: 'Image', id: number, slug: string, url: string, height: number, width: number, rawUrl: string, aspectRatio: number, createdAt: any, focus: { __typename?: 'ImageCoordinate', x: number, y: number }, thumbnail: { __typename?: 'Thumbnail', small: string }, uploadedBy?: { __typename?: 'User', id: number, name?: string | null } | null, appearances: Array<{ __typename?: 'Appearance', id: number, person: { __typename?: 'Person', name: string } }> }> };

export type AddAppearanceTagMutationVariables = Exact<{
  name: Scalars['String'];
  appearanceId: Scalars['Int'];
}>;


export type AddAppearanceTagMutation = { __typename?: 'Mutation', createAppearanceTag: { __typename?: 'AppearanceTag', tag: { __typename?: 'Tag', name: string } } };

export type DeleteAppearanceTagMutationVariables = Exact<{
  name: Scalars['String'];
  appearanceId: Scalars['Int'];
}>;


export type DeleteAppearanceTagMutation = { __typename?: 'Mutation', deleteAppearanceTag?: { __typename?: 'AppearanceTag', tag: { __typename?: 'Tag', name: string } } | null };

export type PersonImagesQueryVariables = Exact<{
  id: Scalars['Int'];
  skip: Scalars['Int'];
  take: Scalars['Int'];
}>;


export type PersonImagesQuery = { __typename?: 'Query', images: Array<{ __typename?: 'Image', id: number, slug: string, url: string, height: number, width: number, rawUrl: string, aspectRatio: number, createdAt: any, focus: { __typename?: 'ImageCoordinate', x: number, y: number }, thumbnail: { __typename?: 'Thumbnail', small: string }, uploadedBy?: { __typename?: 'User', id: number, name?: string | null } | null, appearances: Array<{ __typename?: 'Appearance', id: number, person: { __typename?: 'Person', name: string } }> }> };

export type PersonEditDataQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type PersonEditDataQuery = { __typename?: 'Query', person?: { __typename?: 'Person', birthDate?: any | null, memberOf: Array<{ __typename?: 'GroupMember', group: { __typename?: 'Group', id: number, name: string } }>, preferredMembership?: { __typename?: 'GroupMember', group: { __typename?: 'Group', id: number, name: string } } | null, aliases: Array<{ __typename?: 'Alias', name: string }>, preferredAlias?: { __typename?: 'Alias', name: string } | null, banner?: { __typename?: 'Image', id: number, rawUrl: string, thumbnail: { __typename?: 'Thumbnail', medium: string } } | null, avatar?: { __typename?: 'Image', id: number, rawUrl: string, thumbnail: { __typename?: 'Thumbnail', medium: string } } | null } | null };

export type PersonEditMutationVariables = Exact<{
  id: Scalars['Int'];
  input: UpdatePersonInputs;
}>;


export type PersonEditMutation = { __typename?: 'Mutation', updatePerson?: { __typename?: 'Person', id: number, name: string, birthDate?: any | null, appearances: Array<{ __typename?: 'Appearance', id: number, image: { __typename?: 'Image', id: number, slug: string, url: string, height: number, width: number, rawUrl: string, aspectRatio: number, createdAt: any, focus: { __typename?: 'ImageCoordinate', x: number, y: number }, thumbnail: { __typename?: 'Thumbnail', small: string }, uploadedBy?: { __typename?: 'User', id: number, name?: string | null } | null, appearances: Array<{ __typename?: 'Appearance', id: number, person: { __typename?: 'Person', name: string } }> } }>, memberOf: Array<{ __typename?: 'GroupMember', id: number, startDate?: any | null, group: { __typename?: 'Group', id: number, name: string, avatar?: { __typename?: 'Image', width: number, height: number, focus: { __typename?: 'ImageCoordinate', x: number, y: number }, thumbnail: { __typename?: 'Thumbnail', small: string } } | null } }>, preferredMembership?: { __typename?: 'GroupMember', id: number, startDate?: any | null, group: { __typename?: 'Group', id: number, name: string, avatar?: { __typename?: 'Image', width: number, height: number, focus: { __typename?: 'ImageCoordinate', x: number, y: number }, thumbnail: { __typename?: 'Thumbnail', small: string } } | null } } | null, aliases: Array<{ __typename?: 'Alias', id: number, name: string }>, avatar?: { __typename?: 'Image', width: number, height: number, id: number, focus: { __typename?: 'ImageCoordinate', x: number, y: number }, thumbnail: { __typename?: 'Thumbnail', small: string } } | null, preferredAlias?: { __typename?: 'Alias', id: number, name: string } | null, banner?: { __typename?: 'Image', id: number, rawUrl: string, width: number, height: number, focus: { __typename?: 'ImageCoordinate', x: number, y: number } } | null } | null };

export type AddProviderMutationVariables = Exact<{
  provider: AddProviderInput;
}>;


export type AddProviderMutation = { __typename?: 'Mutation', addProvider: string };

export type DiscoveryProvidersQueryVariables = Exact<{ [key: string]: never; }>;


export type DiscoveryProvidersQuery = { __typename?: 'Query', discoveryProviders: Array<{ __typename?: 'ProviderStatistic', name: string, destination: string, defaultName?: string | null, enabled: boolean, lastScrape?: any | null, scrapeCount: number, lastPost?: any | null, discoveredImages: number, official: boolean, url: string, createdAt?: any | null }> };

export type DiscoveryLeaderboardQueryVariables = Exact<{ [key: string]: never; }>;


export type DiscoveryLeaderboardQuery = { __typename?: 'Query', discoveryLeaderboard: Array<{ __typename?: 'LeaderboardUser', rank: number, xp: number, user: { __typename?: 'User', id: number, avatar?: string | null, name?: string | null, bot: boolean } }> };

export type DiscoveryHistoryQueryVariables = Exact<{
  take: Scalars['Int'];
  skip?: Scalars['Int'];
}>;


export type DiscoveryHistoryQuery = { __typename?: 'Query', discoveryHistory: Array<{ __typename?: 'DiscoveredPost', id: number, providerType: string, uniqueIdentifier: string, body?: string | null, accountName: string, accountAvatarUrl?: string | null, postUrl?: string | null, createdAt: any, originalPostDate?: any | null, referencingGroups: Array<{ __typename?: 'Group', id: number, name: string }>, images: Array<{ __typename?: 'DiscoveredImage', thumbnail: string, url: string, id: number, vote?: { __typename?: 'DiscoveredImageVote', verdict: string } | null, duplicateImage?: { __typename?: 'Image', url: string, rawUrl: string } | null }> }> };

export type ReportImageMutationVariables = Exact<{
  imageId: Scalars['Int'];
  reason?: InputMaybe<Scalars['String']>;
}>;


export type ReportImageMutation = { __typename?: 'Mutation', reportImage?: { __typename?: 'ImageReport', id: number } | null };

export type ImageReportActionMutationVariables = Exact<{
  id: Scalars['Int'];
  action: ImageReportAction;
}>;


export type ImageReportActionMutation = { __typename?: 'Mutation', imageReportAction?: { __typename?: 'ImageReport', id: number } | null };

export type ImageReportsQueryVariables = Exact<{ [key: string]: never; }>;


export type ImageReportsQuery = { __typename?: 'Query', imageReports: Array<{ __typename?: 'ImageReport', id: number, reason?: string | null, createdAt: any, image: { __typename?: 'Image', id: number, url: string, slug: string, width: number, height: number, thumbnail: { __typename?: 'Thumbnail', medium: string } }, reportedBy: { __typename?: 'User', avatar?: string | null, name?: string | null } }> };

export type OnePersonRelationshipImageFragment = { __typename?: 'Image', id: number, thumbnail: { __typename?: 'Thumbnail', small: string } };

export type OnePersonRelationshipMembershipFragment = { __typename?: 'GroupMember', id: number, startDate?: any | null, group: { __typename?: 'Group', id: number, name: string, avatar?: { __typename?: 'Image', width: number, height: number, focus: { __typename?: 'ImageCoordinate', x: number, y: number }, thumbnail: { __typename?: 'Thumbnail', small: string } } | null } };

export type OnePersonQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type OnePersonQuery = { __typename?: 'Query', person?: { __typename?: 'Person', id: number, name: string, birthDate?: any | null, appearances: Array<{ __typename?: 'Appearance', id: number, image: { __typename?: 'Image', id: number, slug: string, url: string, height: number, width: number, rawUrl: string, aspectRatio: number, createdAt: any, focus: { __typename?: 'ImageCoordinate', x: number, y: number }, thumbnail: { __typename?: 'Thumbnail', small: string }, uploadedBy?: { __typename?: 'User', id: number, name?: string | null } | null, appearances: Array<{ __typename?: 'Appearance', id: number, person: { __typename?: 'Person', name: string } }> } }>, memberOf: Array<{ __typename?: 'GroupMember', id: number, startDate?: any | null, group: { __typename?: 'Group', id: number, name: string, avatar?: { __typename?: 'Image', width: number, height: number, focus: { __typename?: 'ImageCoordinate', x: number, y: number }, thumbnail: { __typename?: 'Thumbnail', small: string } } | null } }>, preferredMembership?: { __typename?: 'GroupMember', id: number, startDate?: any | null, group: { __typename?: 'Group', id: number, name: string, avatar?: { __typename?: 'Image', width: number, height: number, focus: { __typename?: 'ImageCoordinate', x: number, y: number }, thumbnail: { __typename?: 'Thumbnail', small: string } } | null } } | null, aliases: Array<{ __typename?: 'Alias', id: number, name: string }>, avatar?: { __typename?: 'Image', width: number, height: number, id: number, focus: { __typename?: 'ImageCoordinate', x: number, y: number }, thumbnail: { __typename?: 'Thumbnail', small: string } } | null, preferredAlias?: { __typename?: 'Alias', id: number, name: string } | null, banner?: { __typename?: 'Image', id: number, rawUrl: string, width: number, height: number, focus: { __typename?: 'ImageCoordinate', x: number, y: number } } | null } | null };

export type AddToQueueMutationVariables = Exact<{
  slug: Scalars['String'];
}>;


export type AddToQueueMutation = { __typename?: 'Mutation', scanFaces: { __typename?: 'QueueInfo', queueSize: number } };

export type UserDataQueryVariables = Exact<{ [key: string]: never; }>;


export type UserDataQuery = { __typename?: 'Query', me?: { __typename?: 'User', id: number, name?: string | null, avatar?: string | null, xp?: number | null, createdAt: any, roles: Array<{ __typename?: 'Role', name: string }> } | null };

export type AppearanceDataFragment = { __typename?: 'Appearance', id: number, person: { __typename?: 'Person', id: number, name: string, preferredAlias?: { __typename?: 'Alias', name: string } | null } };

export type DiscoveryPostListableFragment = { __typename?: 'DiscoveredPost', id: number, providerType: string, uniqueIdentifier: string, body?: string | null, accountName: string, accountAvatarUrl?: string | null, postUrl?: string | null, createdAt: any, originalPostDate?: any | null, referencingGroups: Array<{ __typename?: 'Group', id: number, name: string }>, images: Array<{ __typename?: 'DiscoveredImage', thumbnail: string, url: string, id: number, vote?: { __typename?: 'DiscoveredImageVote', verdict: string } | null, duplicateImage?: { __typename?: 'Image', url: string, rawUrl: string } | null }> };

export type FaceDataFragment = { __typename?: 'Face', id: number, x: number, y: number, width: number, height: number };

export type GridImageFragment = { __typename?: 'Image', id: number, slug: string, url: string, height: number, width: number, rawUrl: string, aspectRatio: number, createdAt: any, focus: { __typename?: 'ImageCoordinate', x: number, y: number }, thumbnail: { __typename?: 'Thumbnail', small: string }, uploadedBy?: { __typename?: 'User', id: number, name?: string | null } | null, appearances: Array<{ __typename?: 'Appearance', id: number, person: { __typename?: 'Person', name: string } }> };

export type FocusFragment = { __typename?: 'Image', width: number, height: number, focus: { __typename?: 'ImageCoordinate', x: number, y: number } };

export type ImageDataFragment = { __typename?: 'Image', id: number, height: number, width: number, url: string, rawUrl: string, createdAt: any, caption?: string | null, public: boolean, source?: string | null, slug: string, bytes: number, mimetype: MimeType, palette: Array<number>, destination: UploadDestination, imageTags: Array<{ __typename?: 'ImageTag', tag: { __typename?: 'Tag', name: string } }> };

export type UserDataFragment = { __typename?: 'User', id: number, name?: string | null, avatar?: string | null, bot: boolean };

export type UserRoleDataFragment = { __typename?: 'Role', name: string };

export type AppearanceWithFacesFragment = { __typename?: 'Appearance', id: number, faces: Array<{ __typename?: 'Face', id: number, x: number, y: number, width: number, height: number }>, person: { __typename?: 'Person', name: string, preferredAlias?: { __typename?: 'Alias', name: string } | null }, tags: Array<{ __typename?: 'AppearanceTag', tag: { __typename?: 'Tag', name: string } }> };

export type AddAppearanceMutationVariables = Exact<{
  imageId: Scalars['Int'];
  personId: Scalars['Int'];
}>;


export type AddAppearanceMutation = { __typename?: 'Mutation', appearance: { __typename?: 'Appearance', id: number, faces: Array<{ __typename?: 'Face', id: number, x: number, y: number, width: number, height: number }>, person: { __typename?: 'Person', name: string, preferredAlias?: { __typename?: 'Alias', name: string } | null }, tags: Array<{ __typename?: 'AppearanceTag', tag: { __typename?: 'Tag', name: string } }> } };

export type RemoveAppearanceMutationVariables = Exact<{
  appearanceId: Scalars['Int'];
}>;


export type RemoveAppearanceMutation = { __typename?: 'Mutation', appearance: { __typename?: 'Appearance', id: number } };

export type LinkFaceMutationVariables = Exact<{
  appearanceId: Scalars['Int'];
  faceId: Scalars['Int'];
}>;


export type LinkFaceMutation = { __typename?: 'Mutation', appearance: { __typename?: 'Appearance', id: number, faces: Array<{ __typename?: 'Face', id: number, x: number, y: number, width: number, height: number }>, person: { __typename?: 'Person', name: string, preferredAlias?: { __typename?: 'Alias', name: string } | null }, tags: Array<{ __typename?: 'AppearanceTag', tag: { __typename?: 'Tag', name: string } }> } };

export type UnlinkFaceMutationVariables = Exact<{
  appearanceId: Scalars['Int'];
  faceId: Scalars['Int'];
}>;


export type UnlinkFaceMutation = { __typename?: 'Mutation', unlinkFace: number };

export type DiscoveryScheduleQueryVariables = Exact<{ [key: string]: never; }>;


export type DiscoveryScheduleQuery = { __typename?: 'Query', discoverySchedule: Array<{ __typename?: 'DiscoveryProvider', destination: string, name?: string | null, waitDays: number, url: string, provider: string, official: boolean }> };

export type DiscoveryStatsQueryVariables = Exact<{ [key: string]: never; }>;


export type DiscoveryStatsQuery = { __typename?: 'Query', discoveryStats: Array<{ __typename?: 'DiscoveryStatistic', count: number, verdict: string }> };

export type GroupMembersQueryVariables = Exact<{
  groupId: Scalars['Int'];
}>;


export type GroupMembersQuery = { __typename?: 'Query', group?: { __typename?: 'Group', members: Array<{ __typename?: 'GroupMember', startDate?: any | null, endDate?: any | null, person: { __typename?: 'Person', name: string, aliases: Array<{ __typename?: 'Alias', name: string }>, avatar?: { __typename?: 'Image', thumbnail: { __typename?: 'Thumbnail', small: string } } | null } }> } | null };

export type OneGroupQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type OneGroupQuery = { __typename?: 'Query', group?: { __typename?: 'Group', id: number, name: string, aliases: Array<{ __typename?: 'GroupAlias', name: string }>, banner?: { __typename?: 'Image', rawUrl: string } | null } | null };

export type HomepageImagesQueryVariables = Exact<{
  take: Scalars['Int'];
  skip: Scalars['Int'];
}>;


export type HomepageImagesQuery = { __typename?: 'Query', images: Array<{ __typename?: 'Image', id: number, slug: string, url: string, height: number, width: number, rawUrl: string, aspectRatio: number, createdAt: any, focus: { __typename?: 'ImageCoordinate', x: number, y: number }, thumbnail: { __typename?: 'Thumbnail', small: string }, uploadedBy?: { __typename?: 'User', id: number, name?: string | null } | null, appearances: Array<{ __typename?: 'Appearance', id: number, person: { __typename?: 'Person', name: string } }> }> };

export type OneImageQueryVariables = Exact<{
  slug: Scalars['String'];
}>;


export type OneImageQuery = { __typename?: 'Query', image?: { __typename?: 'Image', mimetype: MimeType, liked?: boolean | null, faceScanDate?: any | null, public: boolean, reported: boolean, hiddenAt?: any | null, id: number, height: number, width: number, url: string, rawUrl: string, createdAt: any, caption?: string | null, source?: string | null, slug: string, bytes: number, palette: Array<number>, destination: UploadDestination, unknownFaces: Array<{ __typename?: 'Face', id: number, x: number, y: number, width: number, height: number, appearance?: { __typename?: 'Appearance', id: number, person: { __typename?: 'Person', id: number, name: string, preferredAlias?: { __typename?: 'Alias', name: string } | null } } | null }>, appearances: Array<{ __typename?: 'Appearance', id: number, person: { __typename?: 'Person', id: number, name: string, preferredAlias?: { __typename?: 'Alias', name: string } | null }, tags: Array<{ __typename?: 'AppearanceTag', tag: { __typename?: 'Tag', name: string } }>, faces: Array<{ __typename?: 'Face', id: number, x: number, y: number, width: number, height: number }> }>, uploadedBy?: { __typename?: 'User', id: number, name?: string | null, avatar?: string | null, bot: boolean, roles: Array<{ __typename?: 'Role', name: string }> } | null, imageTags: Array<{ __typename?: 'ImageTag', tag: { __typename?: 'Tag', name: string } }> } | null };

export type MeQueryVariables = Exact<{ [key: string]: never; }>;


export type MeQuery = { __typename?: 'Query', me?: { __typename?: 'User', id: number, name?: string | null, avatar?: string | null, bot: boolean, images: Array<{ __typename?: 'Image', id: number, slug: string, url: string, height: number, width: number, rawUrl: string, aspectRatio: number, createdAt: any, focus: { __typename?: 'ImageCoordinate', x: number, y: number }, thumbnail: { __typename?: 'Thumbnail', small: string }, uploadedBy?: { __typename?: 'User', id: number, name?: string | null } | null, appearances: Array<{ __typename?: 'Appearance', id: number, person: { __typename?: 'Person', name: string } }> }>, roles: Array<{ __typename?: 'Role', name: string }> } | null };

export type ToggleLikeMutationVariables = Exact<{
  id: Scalars['Int'];
}>;


export type ToggleLikeMutation = { __typename?: 'Mutation', toggleLike: { __typename?: 'Image', liked?: boolean | null } };

export const PersonGridDataFragmentDoc = gql`
    fragment PersonGridData on Person {
  id
  avatar {
    thumbnail {
      medium
    }
  }
  name
  preferredMembership {
    group {
      name
    }
  }
  preferredAlias {
    name
  }
}
    `;
export const OnePersonRelationshipImageFragmentDoc = gql`
    fragment OnePersonRelationshipImage on Image {
  id
  thumbnail {
    small
  }
}
    `;
export const OnePersonRelationshipMembershipFragmentDoc = gql`
    fragment OnePersonRelationshipMembership on GroupMember {
  id
  startDate
  group {
    id
    avatar {
      width
      height
      focus {
        x
        y
      }
      thumbnail {
        small
      }
    }
    name
  }
}
    `;
export const AppearanceDataFragmentDoc = gql`
    fragment AppearanceData on Appearance {
  id
  person {
    id
    name
    preferredAlias {
      name
    }
  }
}
    `;
export const DiscoveryPostListableFragmentDoc = gql`
    fragment DiscoveryPostListable on DiscoveredPost {
  id
  providerType
  uniqueIdentifier
  body
  accountName
  accountAvatarUrl
  postUrl
  createdAt
  originalPostDate
  referencingGroups {
    id
    name
  }
  images {
    thumbnail
    url
    id
    vote {
      verdict
    }
    duplicateImage {
      url
      rawUrl
    }
  }
}
    `;
export const GridImageFragmentDoc = gql`
    fragment GridImage on Image {
  id
  slug
  url
  height
  width
  focus {
    x
    y
  }
  thumbnail {
    small
  }
  rawUrl
  aspectRatio
  uploadedBy {
    id
    name
  }
  appearances {
    id
    person {
      name
    }
  }
  createdAt
}
    `;
export const FocusFragmentDoc = gql`
    fragment Focus on Image {
  width
  height
  focus {
    x
    y
  }
}
    `;
export const ImageDataFragmentDoc = gql`
    fragment ImageData on Image {
  id
  height
  width
  url
  rawUrl
  createdAt
  caption
  public
  source
  slug
  bytes
  mimetype
  palette
  destination
  imageTags {
    tag {
      name
    }
  }
}
    `;
export const UserDataFragmentDoc = gql`
    fragment UserData on User {
  id
  name
  avatar
  bot
}
    `;
export const UserRoleDataFragmentDoc = gql`
    fragment UserRoleData on Role {
  name
}
    `;
export const FaceDataFragmentDoc = gql`
    fragment FaceData on Face {
  id
  x
  y
  width
  height
}
    `;
export const AppearanceWithFacesFragmentDoc = gql`
    fragment AppearanceWithFaces on Appearance {
  id
  faces {
    ...FaceData
  }
  person {
    preferredAlias {
      name
    }
    name
  }
  tags {
    tag {
      name
    }
  }
}
    `;
export const BrowsePageIdolsWithFilterDocument = gql`
    query BrowsePageIdolsWithFilter($skip: Int!, $take: Int!, $groups: [Int!]!) {
  people(
    skip: $skip
    take: $take
    orderBy: [{updatedAt: asc}]
    where: {memberOf: {some: {group: {id: {in: $groups}}}}}
  ) {
    ...PersonGridData
  }
}
    ${PersonGridDataFragmentDoc}`;
export const BrowsePageIdolsDocument = gql`
    query BrowsePageIdols($skip: Int!, $take: Int!) {
  people(skip: $skip, take: $take, orderBy: [{updatedAt: asc}]) {
    ...PersonGridData
  }
}
    ${PersonGridDataFragmentDoc}`;
export const BrowsePageDocument = gql`
    query BrowsePage($take: Int!, $skip: Int) {
  images(orderBy: [{createdAt: desc}], take: $take, skip: $skip) {
    ...GridImage
  }
}
    ${GridImageFragmentDoc}`;
export const AddAppearanceTagDocument = gql`
    mutation AddAppearanceTag($name: String!, $appearanceId: Int!) {
  createAppearanceTag(name: $name, appearanceId: $appearanceId) {
    tag {
      name
    }
  }
}
    `;
export const DeleteAppearanceTagDocument = gql`
    mutation DeleteAppearanceTag($name: String!, $appearanceId: Int!) {
  deleteAppearanceTag(name: $name, appearanceId: $appearanceId) {
    tag {
      name
    }
  }
}
    `;
export const PersonImagesDocument = gql`
    query PersonImages($id: Int!, $skip: Int!, $take: Int!) {
  images(
    where: {appearances: {some: {personId: {equals: $id}}}}
    skip: $skip
    take: $take
  ) {
    ...GridImage
  }
}
    ${GridImageFragmentDoc}`;
export const PersonEditDataDocument = gql`
    query PersonEditData($id: Int!) {
  person(where: {id: $id}) {
    birthDate
    memberOf {
      group {
        id
        name
      }
    }
    preferredMembership {
      group {
        id
        name
      }
    }
    aliases {
      name
    }
    preferredAlias {
      name
    }
    banner {
      id
      rawUrl
      thumbnail {
        medium
      }
    }
    avatar {
      id
      rawUrl
      thumbnail {
        medium
      }
    }
  }
}
    `;
export const PersonEditDocument = gql`
    mutation PersonEdit($id: Int!, $input: UpdatePersonInputs!) {
  updatePerson(id: $id, update: $input) {
    id
    name
    birthDate
    appearances {
      id
      image {
        ...GridImage
      }
    }
    memberOf {
      ...OnePersonRelationshipMembership
    }
    preferredMembership {
      ...OnePersonRelationshipMembership
    }
    aliases {
      id
      name
    }
    avatar {
      ...Focus
      ...OnePersonRelationshipImage
    }
    preferredAlias {
      id
      name
    }
    banner {
      id
      ...Focus
      rawUrl
    }
  }
}
    ${GridImageFragmentDoc}
${OnePersonRelationshipMembershipFragmentDoc}
${FocusFragmentDoc}
${OnePersonRelationshipImageFragmentDoc}`;
export const AddProviderDocument = gql`
    mutation AddProvider($provider: AddProviderInput!) {
  addProvider(provider: $provider)
}
    `;
export const DiscoveryProvidersDocument = gql`
    query DiscoveryProviders {
  discoveryProviders {
    name
    destination
    defaultName
    enabled
    lastScrape
    scrapeCount
    lastPost
    discoveredImages
    official
    url
    createdAt
  }
}
    `;
export const DiscoveryLeaderboardDocument = gql`
    query DiscoveryLeaderboard {
  discoveryLeaderboard {
    rank
    xp
    user {
      id
      avatar
      name
      bot
    }
  }
}
    `;
export const DiscoveryHistoryDocument = gql`
    query DiscoveryHistory($take: Int!, $skip: Int! = 0) {
  discoveryHistory(take: $take, skip: $skip) {
    ...DiscoveryPostListable
  }
}
    ${DiscoveryPostListableFragmentDoc}`;
export const ReportImageDocument = gql`
    mutation ReportImage($imageId: Int!, $reason: String) {
  reportImage(reason: $reason, imageId: $imageId) {
    id
  }
}
    `;
export const ImageReportActionDocument = gql`
    mutation ImageReportAction($id: Int!, $action: ImageReportAction!) {
  imageReportAction(action: $action, reportId: $id) {
    id
  }
}
    `;
export const ImageReportsDocument = gql`
    query ImageReports {
  imageReports(orderBy: [{createdAt: desc}], where: {action: {equals: null}}) {
    id
    reason
    image {
      id
      url
      slug
      width
      height
      thumbnail {
        medium
      }
    }
    reportedBy {
      avatar
      name
    }
    createdAt
  }
}
    `;
export const OnePersonDocument = gql`
    query OnePerson($id: Int!) {
  person(where: {id: $id}) {
    id
    name
    birthDate
    appearances(take: 20) {
      id
      image {
        ...GridImage
      }
    }
    memberOf {
      ...OnePersonRelationshipMembership
    }
    preferredMembership {
      ...OnePersonRelationshipMembership
    }
    aliases {
      id
      name
    }
    avatar {
      ...Focus
      ...OnePersonRelationshipImage
    }
    preferredAlias {
      id
      name
    }
    banner {
      id
      ...Focus
      rawUrl
    }
  }
}
    ${GridImageFragmentDoc}
${OnePersonRelationshipMembershipFragmentDoc}
${FocusFragmentDoc}
${OnePersonRelationshipImageFragmentDoc}`;
export const AddToQueueDocument = gql`
    mutation addToQueue($slug: String!) {
  scanFaces(slug: $slug) {
    queueSize
  }
}
    `;
export const UserDataDocument = gql`
    query UserData {
  me {
    id
    name
    avatar
    xp
    createdAt
    roles {
      name
    }
  }
}
    `;
export const AddAppearanceDocument = gql`
    mutation AddAppearance($imageId: Int!, $personId: Int!) {
  appearance: addAppearance(imageId: $imageId, personId: $personId) {
    ...AppearanceWithFaces
  }
}
    ${AppearanceWithFacesFragmentDoc}
${FaceDataFragmentDoc}`;
export const RemoveAppearanceDocument = gql`
    mutation RemoveAppearance($appearanceId: Int!) {
  appearance: removeAppearance(appearanceId: $appearanceId) {
    id
  }
}
    `;
export const LinkFaceDocument = gql`
    mutation LinkFace($appearanceId: Int!, $faceId: Int!) {
  appearance: linkFace(faceId: $faceId, appearanceId: $appearanceId) {
    ...AppearanceWithFaces
  }
}
    ${AppearanceWithFacesFragmentDoc}
${FaceDataFragmentDoc}`;
export const UnlinkFaceDocument = gql`
    mutation UnlinkFace($appearanceId: Int!, $faceId: Int!) {
  unlinkFace(faceId: $faceId, appearanceId: $appearanceId)
}
    `;
export const DiscoveryScheduleDocument = gql`
    query DiscoverySchedule {
  discoverySchedule {
    destination
    name
    waitDays
    url
    provider
    official
  }
}
    `;
export const DiscoveryStatsDocument = gql`
    query DiscoveryStats {
  discoveryStats {
    count
    verdict
  }
}
    `;
export const GroupMembersDocument = gql`
    query GroupMembers($groupId: Int!) {
  group(where: {id: $groupId}) {
    members {
      startDate
      endDate
      person {
        name
        aliases {
          name
        }
        avatar {
          thumbnail {
            small
          }
        }
      }
    }
  }
}
    `;
export const OneGroupDocument = gql`
    query OneGroup($id: Int!) {
  group(where: {id: $id}) {
    id
    name
    aliases {
      name
    }
    banner {
      rawUrl
    }
  }
}
    `;
export const HomepageImagesDocument = gql`
    query HomepageImages($take: Int!, $skip: Int!) {
  images(take: $take, skip: $skip, orderBy: {createdAt: desc}) {
    ...GridImage
  }
}
    ${GridImageFragmentDoc}`;
export const OneImageDocument = gql`
    query OneImage($slug: String!) {
  image(slug: $slug) {
    mimetype
    unknownFaces {
      ...FaceData
      appearance {
        ...AppearanceData
      }
    }
    appearances {
      id
      person {
        id
        name
        preferredAlias {
          name
        }
      }
      tags {
        tag {
          name
        }
      }
      faces {
        ...FaceData
      }
    }
    liked
    uploadedBy {
      ...UserData
      roles {
        ...UserRoleData
      }
    }
    ...ImageData
    faceScanDate
    public
    reported
    hiddenAt
  }
}
    ${FaceDataFragmentDoc}
${AppearanceDataFragmentDoc}
${UserDataFragmentDoc}
${UserRoleDataFragmentDoc}
${ImageDataFragmentDoc}`;
export const MeDocument = gql`
    query Me {
  me {
    ...UserData
    images(orderBy: {createdAt: asc}) {
      ...GridImage
    }
    roles {
      ...UserRoleData
    }
  }
}
    ${UserDataFragmentDoc}
${GridImageFragmentDoc}
${UserRoleDataFragmentDoc}`;
export const ToggleLikeDocument = gql`
    mutation ToggleLike($id: Int!) {
  toggleLike(imageId: $id) {
    liked
  }
}
    `;

export type SdkFunctionWrapper = <T>(action: (requestHeaders?:Record<string, string>) => Promise<T>, operationName: string) => Promise<T>;


const defaultWrapper: SdkFunctionWrapper = (action, _operationName) => action();

export function getSdk(client: GraphQLClient, withWrapper: SdkFunctionWrapper = defaultWrapper) {
  return {
    BrowsePageIdolsWithFilter(variables: BrowsePageIdolsWithFilterQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<BrowsePageIdolsWithFilterQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<BrowsePageIdolsWithFilterQuery>(BrowsePageIdolsWithFilterDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'BrowsePageIdolsWithFilter');
    },
    BrowsePageIdols(variables: BrowsePageIdolsQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<BrowsePageIdolsQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<BrowsePageIdolsQuery>(BrowsePageIdolsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'BrowsePageIdols');
    },
    BrowsePage(variables: BrowsePageQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<BrowsePageQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<BrowsePageQuery>(BrowsePageDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'BrowsePage');
    },
    AddAppearanceTag(variables: AddAppearanceTagMutationVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<AddAppearanceTagMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<AddAppearanceTagMutation>(AddAppearanceTagDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'AddAppearanceTag');
    },
    DeleteAppearanceTag(variables: DeleteAppearanceTagMutationVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<DeleteAppearanceTagMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<DeleteAppearanceTagMutation>(DeleteAppearanceTagDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'DeleteAppearanceTag');
    },
    PersonImages(variables: PersonImagesQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<PersonImagesQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<PersonImagesQuery>(PersonImagesDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'PersonImages');
    },
    PersonEditData(variables: PersonEditDataQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<PersonEditDataQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<PersonEditDataQuery>(PersonEditDataDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'PersonEditData');
    },
    PersonEdit(variables: PersonEditMutationVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<PersonEditMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<PersonEditMutation>(PersonEditDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'PersonEdit');
    },
    AddProvider(variables: AddProviderMutationVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<AddProviderMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<AddProviderMutation>(AddProviderDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'AddProvider');
    },
    DiscoveryProviders(variables?: DiscoveryProvidersQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<DiscoveryProvidersQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<DiscoveryProvidersQuery>(DiscoveryProvidersDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'DiscoveryProviders');
    },
    DiscoveryLeaderboard(variables?: DiscoveryLeaderboardQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<DiscoveryLeaderboardQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<DiscoveryLeaderboardQuery>(DiscoveryLeaderboardDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'DiscoveryLeaderboard');
    },
    DiscoveryHistory(variables: DiscoveryHistoryQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<DiscoveryHistoryQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<DiscoveryHistoryQuery>(DiscoveryHistoryDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'DiscoveryHistory');
    },
    ReportImage(variables: ReportImageMutationVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<ReportImageMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<ReportImageMutation>(ReportImageDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'ReportImage');
    },
    ImageReportAction(variables: ImageReportActionMutationVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<ImageReportActionMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<ImageReportActionMutation>(ImageReportActionDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'ImageReportAction');
    },
    ImageReports(variables?: ImageReportsQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<ImageReportsQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<ImageReportsQuery>(ImageReportsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'ImageReports');
    },
    OnePerson(variables: OnePersonQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<OnePersonQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<OnePersonQuery>(OnePersonDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'OnePerson');
    },
    addToQueue(variables: AddToQueueMutationVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<AddToQueueMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<AddToQueueMutation>(AddToQueueDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'addToQueue');
    },
    UserData(variables?: UserDataQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<UserDataQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<UserDataQuery>(UserDataDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'UserData');
    },
    AddAppearance(variables: AddAppearanceMutationVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<AddAppearanceMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<AddAppearanceMutation>(AddAppearanceDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'AddAppearance');
    },
    RemoveAppearance(variables: RemoveAppearanceMutationVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<RemoveAppearanceMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<RemoveAppearanceMutation>(RemoveAppearanceDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'RemoveAppearance');
    },
    LinkFace(variables: LinkFaceMutationVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<LinkFaceMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<LinkFaceMutation>(LinkFaceDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'LinkFace');
    },
    UnlinkFace(variables: UnlinkFaceMutationVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<UnlinkFaceMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<UnlinkFaceMutation>(UnlinkFaceDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'UnlinkFace');
    },
    DiscoverySchedule(variables?: DiscoveryScheduleQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<DiscoveryScheduleQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<DiscoveryScheduleQuery>(DiscoveryScheduleDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'DiscoverySchedule');
    },
    DiscoveryStats(variables?: DiscoveryStatsQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<DiscoveryStatsQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<DiscoveryStatsQuery>(DiscoveryStatsDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'DiscoveryStats');
    },
    GroupMembers(variables: GroupMembersQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<GroupMembersQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<GroupMembersQuery>(GroupMembersDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'GroupMembers');
    },
    OneGroup(variables: OneGroupQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<OneGroupQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<OneGroupQuery>(OneGroupDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'OneGroup');
    },
    HomepageImages(variables: HomepageImagesQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<HomepageImagesQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<HomepageImagesQuery>(HomepageImagesDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'HomepageImages');
    },
    OneImage(variables: OneImageQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<OneImageQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<OneImageQuery>(OneImageDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'OneImage');
    },
    Me(variables?: MeQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<MeQuery> {
      return withWrapper((wrappedRequestHeaders) => client.request<MeQuery>(MeDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'Me');
    },
    ToggleLike(variables: ToggleLikeMutationVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<ToggleLikeMutation> {
      return withWrapper((wrappedRequestHeaders) => client.request<ToggleLikeMutation>(ToggleLikeDocument, variables, {...requestHeaders, ...wrappedRequestHeaders}), 'ToggleLike');
    }
  };
}
export type Sdk = ReturnType<typeof getSdk>;