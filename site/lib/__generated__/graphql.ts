/* DO NOT EDIT! this file was generated by graphql-codegen */
/* eslint-disable */
import { useQuery, UseQueryOptions, useMutation, UseMutationOptions } from 'react-query';
export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };

function fetcher<TData, TVariables>(query: string, variables?: TVariables) {
  return async (): Promise<TData> => {
    const res = await fetch(`${process.env.NEXT_PUBLIC_BASE_URL}/api/graphql` as string, {
      method: "POST",
      headers: {"Content-Type":"application/json"},
      body: JSON.stringify({ query, variables }),
    });
    
    const json = await res.json();

    if (json.errors) {
      const { message } = json.errors[0];

      throw new Error(message);
    }

    return json.data;
  }
}
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  DateTime: any;
};

export type AddProviderInput = {
  groups: Array<Scalars['Int']>;
  name: Scalars['String'];
  official: Scalars['Boolean'];
  people: Array<Scalars['Int']>;
  url: Scalars['String'];
};

export type Alias = {
  __typename?: 'Alias';
  createdAt: Scalars['DateTime'];
  id: Scalars['Int'];
  name: Scalars['String'];
  updatedAt: Scalars['DateTime'];
};

export type AliasListRelationFilter = {
  every?: Maybe<AliasWhereInput>;
  none?: Maybe<AliasWhereInput>;
  some?: Maybe<AliasWhereInput>;
};

export type AliasOrderByRelationAggregateInput = {
  _count?: Maybe<SortOrder>;
};

export type AliasOrderByWithRelationInput = {
  createdAt?: Maybe<SortOrder>;
  id?: Maybe<SortOrder>;
  name?: Maybe<SortOrder>;
  person?: Maybe<PersonOrderByWithRelationInput>;
  personId?: Maybe<SortOrder>;
  preferredAliasOf?: Maybe<PersonOrderByWithRelationInput>;
  updatedAt?: Maybe<SortOrder>;
};

export type AliasPersonAliasCompoundUniqueInput = {
  name: Scalars['String'];
  personId: Scalars['Int'];
};

export type AliasWhereInput = {
  AND?: Maybe<Array<AliasWhereInput>>;
  NOT?: Maybe<Array<AliasWhereInput>>;
  OR?: Maybe<Array<AliasWhereInput>>;
  createdAt?: Maybe<DateTimeFilter>;
  id?: Maybe<IntFilter>;
  name?: Maybe<StringFilter>;
  person?: Maybe<PersonWhereInput>;
  personId?: Maybe<IntFilter>;
  preferredAliasOf?: Maybe<PersonWhereInput>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type AliasWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
  personAlias?: Maybe<AliasPersonAliasCompoundUniqueInput>;
};

export type Appearance = {
  __typename?: 'Appearance';
  addedBy?: Maybe<User>;
  createdAt: Scalars['DateTime'];
  faces: Array<Face>;
  id: Scalars['Int'];
  image: Image;
  person: Person;
  tags: Array<AppearanceTag>;
  updatedAt: Scalars['DateTime'];
};


export type AppearanceFacesArgs = {
  cursor?: Maybe<FaceWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  take?: Maybe<Scalars['Int']>;
};


export type AppearanceTagsArgs = {
  cursor?: Maybe<AppearanceTagWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  take?: Maybe<Scalars['Int']>;
};

export type AppearanceCount = {
  __typename?: 'AppearanceCount';
  count: Scalars['Int'];
  group: Group;
};

export type AppearanceListRelationFilter = {
  every?: Maybe<AppearanceWhereInput>;
  none?: Maybe<AppearanceWhereInput>;
  some?: Maybe<AppearanceWhereInput>;
};

export type AppearanceOrderByRelationAggregateInput = {
  _count?: Maybe<SortOrder>;
};

export type AppearancePersonIdImageIdCompoundUniqueInput = {
  imageId: Scalars['Int'];
  personId: Scalars['Int'];
};

export type AppearanceTag = {
  __typename?: 'AppearanceTag';
  addedBy?: Maybe<User>;
  appearance: Appearance;
  createdAt: Scalars['DateTime'];
  tag: Tag;
  updatedAt: Scalars['DateTime'];
};

export type AppearanceTagAppearanceTagCompoundUniqueInput = {
  appearanceId: Scalars['Int'];
  tagId: Scalars['Int'];
};

export type AppearanceTagListRelationFilter = {
  every?: Maybe<AppearanceTagWhereInput>;
  none?: Maybe<AppearanceTagWhereInput>;
  some?: Maybe<AppearanceTagWhereInput>;
};

export type AppearanceTagOrderByRelationAggregateInput = {
  _count?: Maybe<SortOrder>;
};

export type AppearanceTagWhereInput = {
  AND?: Maybe<Array<AppearanceTagWhereInput>>;
  Image?: Maybe<ImageWhereInput>;
  NOT?: Maybe<Array<AppearanceTagWhereInput>>;
  OR?: Maybe<Array<AppearanceTagWhereInput>>;
  addedBy?: Maybe<UserWhereInput>;
  addedById?: Maybe<IntNullableFilter>;
  appearance?: Maybe<AppearanceWhereInput>;
  appearanceId?: Maybe<IntFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  id?: Maybe<IntFilter>;
  imageId?: Maybe<IntNullableFilter>;
  tag?: Maybe<TagWhereInput>;
  tagId?: Maybe<IntFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type AppearanceTagWhereUniqueInput = {
  appearanceTag?: Maybe<AppearanceTagAppearanceTagCompoundUniqueInput>;
  id?: Maybe<Scalars['Int']>;
};

export type AppearanceWhereInput = {
  AND?: Maybe<Array<AppearanceWhereInput>>;
  NOT?: Maybe<Array<AppearanceWhereInput>>;
  OR?: Maybe<Array<AppearanceWhereInput>>;
  addedBy?: Maybe<UserWhereInput>;
  addedById?: Maybe<IntNullableFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  faces?: Maybe<FaceListRelationFilter>;
  id?: Maybe<IntFilter>;
  image?: Maybe<ImageWhereInput>;
  imageId?: Maybe<IntFilter>;
  person?: Maybe<PersonWhereInput>;
  personId?: Maybe<IntFilter>;
  tags?: Maybe<AppearanceTagListRelationFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type AppearanceWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
  personId_imageId?: Maybe<AppearancePersonIdImageIdCompoundUniqueInput>;
};

export type BoolFilter = {
  equals?: Maybe<Scalars['Boolean']>;
  not?: Maybe<NestedBoolFilter>;
};


export type DateTimeFilter = {
  equals?: Maybe<Scalars['DateTime']>;
  gt?: Maybe<Scalars['DateTime']>;
  gte?: Maybe<Scalars['DateTime']>;
  in?: Maybe<Array<Scalars['DateTime']>>;
  lt?: Maybe<Scalars['DateTime']>;
  lte?: Maybe<Scalars['DateTime']>;
  not?: Maybe<NestedDateTimeFilter>;
  notIn?: Maybe<Array<Scalars['DateTime']>>;
};

export type DateTimeNullableFilter = {
  equals?: Maybe<Scalars['DateTime']>;
  gt?: Maybe<Scalars['DateTime']>;
  gte?: Maybe<Scalars['DateTime']>;
  in?: Maybe<Array<Scalars['DateTime']>>;
  lt?: Maybe<Scalars['DateTime']>;
  lte?: Maybe<Scalars['DateTime']>;
  not?: Maybe<NestedDateTimeNullableFilter>;
  notIn?: Maybe<Array<Scalars['DateTime']>>;
};

export type DiscoveredImage = {
  __typename?: 'DiscoveredImage';
  approvedImage?: Maybe<Image>;
  createdAt: Scalars['DateTime'];
  duplicateImage?: Maybe<Image>;
  id: Scalars['Int'];
  providerType: Scalars['String'];
  referenceUrl?: Maybe<Scalars['String']>;
  /** A smaller thumbnail of the image */
  thumbnail: Scalars['String'];
  uniqueIdentifier: Scalars['String'];
  updatedAt: Scalars['DateTime'];
  url: Scalars['String'];
  verdict?: Maybe<DiscoveredImageVerdict>;
  /** The vote cast by the currently logged in user */
  vote?: Maybe<DiscoveredImageVote>;
  /** Votes cast by all users */
  votes: Array<DiscoveredImageVote>;
};


export type DiscoveredImageVotesArgs = {
  cursor?: Maybe<DiscoveredImageVoteWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  take?: Maybe<Scalars['Int']>;
  where?: Maybe<DiscoveredImageVoteWhereInput>;
};

export type DiscoveredImageListRelationFilter = {
  every?: Maybe<DiscoveredImageWhereInput>;
  none?: Maybe<DiscoveredImageWhereInput>;
  some?: Maybe<DiscoveredImageWhereInput>;
};

export type DiscoveredImageOrderByRelationAggregateInput = {
  _count?: Maybe<SortOrder>;
};

export type DiscoveredImageOrderByWithRelationInput = {
  createdAt?: Maybe<SortOrder>;
  duplicateDiscoveredImage?: Maybe<DiscoveredImageOrderByWithRelationInput>;
  duplicateDiscoveredImageId?: Maybe<SortOrder>;
  duplicateDiscoveredImages?: Maybe<DiscoveredImageOrderByRelationAggregateInput>;
  duplicateImage?: Maybe<ImageOrderByWithRelationInput>;
  duplicateImageId?: Maybe<SortOrder>;
  id?: Maybe<SortOrder>;
  image?: Maybe<ImageOrderByWithRelationInput>;
  imageId?: Maybe<SortOrder>;
  mediaType?: Maybe<SortOrder>;
  post?: Maybe<DiscoveredPostOrderByWithRelationInput>;
  postId?: Maybe<SortOrder>;
  providerType?: Maybe<SortOrder>;
  referenceUrl?: Maybe<SortOrder>;
  uniqueIdentifier?: Maybe<SortOrder>;
  updatedAt?: Maybe<SortOrder>;
  url?: Maybe<SortOrder>;
  verdict?: Maybe<DiscoveredImageVerdictOrderByWithRelationInput>;
  votes?: Maybe<DiscoveredImageVoteOrderByRelationAggregateInput>;
};

export type DiscoveredImageProviderTypeUniqueIdentifierCompoundUniqueInput = {
  providerType: Scalars['String'];
  uniqueIdentifier: Scalars['String'];
};

export type DiscoveredImageVerdict = {
  __typename?: 'DiscoveredImageVerdict';
  createdAt: Scalars['DateTime'];
  id: Scalars['Int'];
  reason?: Maybe<Scalars['String']>;
  verdict: Scalars['String'];
};

export type DiscoveredImageVerdictOrderByWithRelationInput = {
  createdAt?: Maybe<SortOrder>;
  discoveredImage?: Maybe<DiscoveredImageOrderByWithRelationInput>;
  discoveredImageId?: Maybe<SortOrder>;
  id?: Maybe<SortOrder>;
  reason?: Maybe<SortOrder>;
  verdict?: Maybe<SortOrder>;
};

export type DiscoveredImageVerdictWhereInput = {
  AND?: Maybe<Array<DiscoveredImageVerdictWhereInput>>;
  NOT?: Maybe<Array<DiscoveredImageVerdictWhereInput>>;
  OR?: Maybe<Array<DiscoveredImageVerdictWhereInput>>;
  createdAt?: Maybe<DateTimeFilter>;
  discoveredImage?: Maybe<DiscoveredImageWhereInput>;
  discoveredImageId?: Maybe<IntFilter>;
  id?: Maybe<IntFilter>;
  reason?: Maybe<StringNullableFilter>;
  verdict?: Maybe<StringFilter>;
};

export type DiscoveredImageVote = {
  __typename?: 'DiscoveredImageVote';
  createdAt: Scalars['DateTime'];
  id: Scalars['Int'];
  reason?: Maybe<Scalars['String']>;
  updatedAt: Scalars['DateTime'];
  user: User;
  verdict: Scalars['String'];
};

export type DiscoveredImageVoteListRelationFilter = {
  every?: Maybe<DiscoveredImageVoteWhereInput>;
  none?: Maybe<DiscoveredImageVoteWhereInput>;
  some?: Maybe<DiscoveredImageVoteWhereInput>;
};

export type DiscoveredImageVoteOrderByRelationAggregateInput = {
  _count?: Maybe<SortOrder>;
};

export type DiscoveredImageVoteUserVoteCompoundUniqueInput = {
  discoveredImageId: Scalars['Int'];
  userId: Scalars['Int'];
};

export type DiscoveredImageVoteWhereInput = {
  AND?: Maybe<Array<DiscoveredImageVoteWhereInput>>;
  NOT?: Maybe<Array<DiscoveredImageVoteWhereInput>>;
  OR?: Maybe<Array<DiscoveredImageVoteWhereInput>>;
  createdAt?: Maybe<DateTimeFilter>;
  discoveredImage?: Maybe<DiscoveredImageWhereInput>;
  discoveredImageId?: Maybe<IntFilter>;
  id?: Maybe<IntFilter>;
  reason?: Maybe<StringNullableFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
  user?: Maybe<UserWhereInput>;
  userId?: Maybe<IntFilter>;
  verdict?: Maybe<StringFilter>;
  xp?: Maybe<IntFilter>;
};

export type DiscoveredImageVoteWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
  userVote?: Maybe<DiscoveredImageVoteUserVoteCompoundUniqueInput>;
};

export type DiscoveredImageWhereInput = {
  AND?: Maybe<Array<DiscoveredImageWhereInput>>;
  NOT?: Maybe<Array<DiscoveredImageWhereInput>>;
  OR?: Maybe<Array<DiscoveredImageWhereInput>>;
  createdAt?: Maybe<DateTimeFilter>;
  duplicateDiscoveredImage?: Maybe<DiscoveredImageWhereInput>;
  duplicateDiscoveredImageId?: Maybe<IntNullableFilter>;
  duplicateDiscoveredImages?: Maybe<DiscoveredImageListRelationFilter>;
  duplicateImage?: Maybe<ImageWhereInput>;
  duplicateImageId?: Maybe<IntNullableFilter>;
  id?: Maybe<IntFilter>;
  image?: Maybe<ImageWhereInput>;
  imageId?: Maybe<IntNullableFilter>;
  mediaType?: Maybe<StringFilter>;
  post?: Maybe<DiscoveredPostWhereInput>;
  postId?: Maybe<IntNullableFilter>;
  providerType?: Maybe<StringFilter>;
  referenceUrl?: Maybe<StringNullableFilter>;
  uniqueIdentifier?: Maybe<StringFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
  url?: Maybe<StringFilter>;
  verdict?: Maybe<DiscoveredImageVerdictWhereInput>;
  votes?: Maybe<DiscoveredImageVoteListRelationFilter>;
};

export type DiscoveredImageWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
  imageId?: Maybe<Scalars['Int']>;
  providerType_uniqueIdentifier?: Maybe<DiscoveredImageProviderTypeUniqueIdentifierCompoundUniqueInput>;
};

export type DiscoveredPost = {
  __typename?: 'DiscoveredPost';
  accountAvatarUrl?: Maybe<Scalars['String']>;
  accountName: Scalars['String'];
  body?: Maybe<Scalars['String']>;
  createdAt: Scalars['DateTime'];
  id: Scalars['Int'];
  images: Array<DiscoveredImage>;
  originalPostDate?: Maybe<Scalars['DateTime']>;
  postUrl?: Maybe<Scalars['String']>;
  providerType: Scalars['String'];
  /** Groups who are associated with the social media account that created this post. */
  referencingGroups: Array<Group>;
  /** People who are associated with the social media account that created this post. */
  referencingPeople: Array<Person>;
  uniqueIdentifier: Scalars['String'];
  updatedAt: Scalars['DateTime'];
};


export type DiscoveredPostImagesArgs = {
  cursor?: Maybe<DiscoveredImageWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  take?: Maybe<Scalars['Int']>;
};

export type DiscoveredPostDiscoveredProviderCompoundUniqueInput = {
  providerType: Scalars['String'];
  uniqueIdentifier: Scalars['String'];
};

export type DiscoveredPostOrderByWithRelationInput = {
  accountAvatarUrl?: Maybe<SortOrder>;
  accountName?: Maybe<SortOrder>;
  body?: Maybe<SortOrder>;
  createdAt?: Maybe<SortOrder>;
  discoveredImages?: Maybe<DiscoveredImageOrderByRelationAggregateInput>;
  id?: Maybe<SortOrder>;
  official?: Maybe<SortOrder>;
  originalPostDate?: Maybe<SortOrder>;
  postUrl?: Maybe<SortOrder>;
  providerType?: Maybe<SortOrder>;
  referencingGroups?: Maybe<SortOrder>;
  referencingPeople?: Maybe<SortOrder>;
  uniqueIdentifier?: Maybe<SortOrder>;
  updatedAt?: Maybe<SortOrder>;
};

export type DiscoveredPostWhereInput = {
  AND?: Maybe<Array<DiscoveredPostWhereInput>>;
  NOT?: Maybe<Array<DiscoveredPostWhereInput>>;
  OR?: Maybe<Array<DiscoveredPostWhereInput>>;
  accountAvatarUrl?: Maybe<StringNullableFilter>;
  accountName?: Maybe<StringFilter>;
  body?: Maybe<StringNullableFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  discoveredImages?: Maybe<DiscoveredImageListRelationFilter>;
  id?: Maybe<IntFilter>;
  official?: Maybe<BoolFilter>;
  originalPostDate?: Maybe<DateTimeNullableFilter>;
  postUrl?: Maybe<StringNullableFilter>;
  providerType?: Maybe<StringFilter>;
  referencingGroups?: Maybe<IntNullableListFilter>;
  referencingPeople?: Maybe<IntNullableListFilter>;
  uniqueIdentifier?: Maybe<StringFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type DiscoveredPostWhereUniqueInput = {
  discoveredProvider?: Maybe<DiscoveredPostDiscoveredProviderCompoundUniqueInput>;
  id?: Maybe<Scalars['Int']>;
};

/** The list of providers that supply images for the discovery feed */
export type DiscoveryProvider = {
  __typename?: 'DiscoveryProvider';
  destination: Scalars['String'];
  name?: Maybe<Scalars['String']>;
  official: Scalars['Boolean'];
  provider: Scalars['String'];
  url: Scalars['String'];
  /** The number of days remaining until this provider is checked for updates again */
  waitDays: Scalars['Int'];
};

export type DiscoveryStatistic = {
  __typename?: 'DiscoveryStatistic';
  count: Scalars['Int'];
  verdict: Scalars['String'];
};

export type EnumFaceSourceFilter = {
  equals?: Maybe<FaceSource>;
  in?: Maybe<Array<FaceSource>>;
  not?: Maybe<NestedEnumFaceSourceFilter>;
  notIn?: Maybe<Array<FaceSource>>;
};

export type EnumGenderNullableFilter = {
  equals?: Maybe<Gender>;
  in?: Maybe<Array<Gender>>;
  not?: Maybe<NestedEnumGenderNullableFilter>;
  notIn?: Maybe<Array<Gender>>;
};

export type EnumMimeTypeFilter = {
  equals?: Maybe<MimeType>;
  in?: Maybe<Array<MimeType>>;
  not?: Maybe<NestedEnumMimeTypeFilter>;
  notIn?: Maybe<Array<MimeType>>;
};

export type EnumTagSourceFilter = {
  equals?: Maybe<TagSource>;
  in?: Maybe<Array<TagSource>>;
  not?: Maybe<NestedEnumTagSourceFilter>;
  notIn?: Maybe<Array<TagSource>>;
};

export type EnumUploadTypeFilter = {
  equals?: Maybe<UploadType>;
  in?: Maybe<Array<UploadType>>;
  not?: Maybe<NestedEnumUploadTypeFilter>;
  notIn?: Maybe<Array<UploadType>>;
};

export type Face = {
  __typename?: 'Face';
  addedBy?: Maybe<User>;
  appearance?: Maybe<Appearance>;
  createdAt: Scalars['DateTime'];
  height: Scalars['Float'];
  id: Scalars['Int'];
  image: Image;
  /** @deprecated Field no longer supported */
  score: Scalars['Float'];
  source: FaceSource;
  updatedAt: Scalars['DateTime'];
  width: Scalars['Float'];
  x: Scalars['Float'];
  y: Scalars['Float'];
};

export type FaceListRelationFilter = {
  every?: Maybe<FaceWhereInput>;
  none?: Maybe<FaceWhereInput>;
  some?: Maybe<FaceWhereInput>;
};

export type FaceOrderByRelationAggregateInput = {
  _count?: Maybe<SortOrder>;
};

export enum FaceSource {
  Manual = 'Manual',
  Scan = 'Scan'
}

export type FaceWhereInput = {
  AND?: Maybe<Array<FaceWhereInput>>;
  NOT?: Maybe<Array<FaceWhereInput>>;
  OR?: Maybe<Array<FaceWhereInput>>;
  addedBy?: Maybe<UserWhereInput>;
  addedById?: Maybe<IntNullableFilter>;
  appearance?: Maybe<AppearanceWhereInput>;
  appearanceId?: Maybe<IntNullableFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  height?: Maybe<FloatFilter>;
  id?: Maybe<IntFilter>;
  image?: Maybe<ImageWhereInput>;
  imageId?: Maybe<IntFilter>;
  person?: Maybe<PersonWhereInput>;
  personId?: Maybe<IntNullableFilter>;
  score?: Maybe<FloatFilter>;
  source?: Maybe<EnumFaceSourceFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
  width?: Maybe<FloatFilter>;
  x?: Maybe<FloatFilter>;
  y?: Maybe<FloatFilter>;
};

export type FaceWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
};

export type FloatFilter = {
  equals?: Maybe<Scalars['Float']>;
  gt?: Maybe<Scalars['Float']>;
  gte?: Maybe<Scalars['Float']>;
  in?: Maybe<Array<Scalars['Float']>>;
  lt?: Maybe<Scalars['Float']>;
  lte?: Maybe<Scalars['Float']>;
  not?: Maybe<NestedFloatFilter>;
  notIn?: Maybe<Array<Scalars['Float']>>;
};

export enum Gender {
  Female = 'FEMALE',
  Male = 'MALE',
  Nonbinary = 'NONBINARY'
}

export type Group = {
  __typename?: 'Group';
  aliases: Array<GroupAlias>;
  avatar?: Maybe<Image>;
  banner?: Maybe<Image>;
  createdAt: Scalars['DateTime'];
  id: Scalars['Int'];
  members: Array<GroupMember>;
  name: Scalars['String'];
  updatedAt: Scalars['DateTime'];
};


export type GroupAliasesArgs = {
  cursor?: Maybe<GroupAliasWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  take?: Maybe<Scalars['Int']>;
};


export type GroupMembersArgs = {
  cursor?: Maybe<GroupMemberWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  take?: Maybe<Scalars['Int']>;
};

export type GroupAlias = {
  __typename?: 'GroupAlias';
  createdAt: Scalars['DateTime'];
  id: Scalars['Int'];
  name: Scalars['String'];
  updatedAt: Scalars['DateTime'];
};

export type GroupAliasListRelationFilter = {
  every?: Maybe<GroupAliasWhereInput>;
  none?: Maybe<GroupAliasWhereInput>;
  some?: Maybe<GroupAliasWhereInput>;
};

export type GroupAliasOrderByRelationAggregateInput = {
  _count?: Maybe<SortOrder>;
};

export type GroupAliasWhereInput = {
  AND?: Maybe<Array<GroupAliasWhereInput>>;
  NOT?: Maybe<Array<GroupAliasWhereInput>>;
  OR?: Maybe<Array<GroupAliasWhereInput>>;
  createdAt?: Maybe<DateTimeFilter>;
  group?: Maybe<GroupWhereInput>;
  groupId?: Maybe<IntFilter>;
  id?: Maybe<IntFilter>;
  name?: Maybe<StringFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type GroupAliasWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
};

export type GroupMember = {
  __typename?: 'GroupMember';
  createdAt: Scalars['DateTime'];
  endDate?: Maybe<Scalars['DateTime']>;
  group: Group;
  id: Scalars['Int'];
  person: Person;
  startDate?: Maybe<Scalars['DateTime']>;
  updatedAt: Scalars['DateTime'];
};

export type GroupMemberGroupIdPersonIdCompoundUniqueInput = {
  groupId: Scalars['Int'];
  personId: Scalars['Int'];
};

export type GroupMemberListRelationFilter = {
  every?: Maybe<GroupMemberWhereInput>;
  none?: Maybe<GroupMemberWhereInput>;
  some?: Maybe<GroupMemberWhereInput>;
};

export type GroupMemberOrderByRelationAggregateInput = {
  _count?: Maybe<SortOrder>;
};

export type GroupMemberOrderByWithRelationInput = {
  createdAt?: Maybe<SortOrder>;
  endDate?: Maybe<SortOrder>;
  group?: Maybe<GroupOrderByWithRelationInput>;
  groupId?: Maybe<SortOrder>;
  id?: Maybe<SortOrder>;
  person?: Maybe<PersonOrderByWithRelationInput>;
  personId?: Maybe<SortOrder>;
  preferredMemberships_?: Maybe<PersonOrderByRelationAggregateInput>;
  startDate?: Maybe<SortOrder>;
  updatedAt?: Maybe<SortOrder>;
};

export type GroupMemberWhereInput = {
  AND?: Maybe<Array<GroupMemberWhereInput>>;
  NOT?: Maybe<Array<GroupMemberWhereInput>>;
  OR?: Maybe<Array<GroupMemberWhereInput>>;
  createdAt?: Maybe<DateTimeFilter>;
  endDate?: Maybe<DateTimeNullableFilter>;
  group?: Maybe<GroupWhereInput>;
  groupId?: Maybe<IntFilter>;
  id?: Maybe<IntFilter>;
  person?: Maybe<PersonWhereInput>;
  personId?: Maybe<IntFilter>;
  preferredMemberships_?: Maybe<PersonListRelationFilter>;
  startDate?: Maybe<DateTimeNullableFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type GroupMemberWhereUniqueInput = {
  groupId_personId?: Maybe<GroupMemberGroupIdPersonIdCompoundUniqueInput>;
  id?: Maybe<Scalars['Int']>;
};

export type GroupMembership = {
  endDate?: Maybe<Scalars['String']>;
  id: Scalars['Int'];
  startDate?: Maybe<Scalars['String']>;
};

export type GroupOrderByWithRelationInput = {
  aliases?: Maybe<GroupAliasOrderByRelationAggregateInput>;
  avatar?: Maybe<ImageOrderByWithRelationInput>;
  avatarId?: Maybe<SortOrder>;
  banner?: Maybe<ImageOrderByWithRelationInput>;
  bannerId?: Maybe<SortOrder>;
  createdAt?: Maybe<SortOrder>;
  id?: Maybe<SortOrder>;
  ireneBotId?: Maybe<SortOrder>;
  members?: Maybe<GroupMemberOrderByRelationAggregateInput>;
  name?: Maybe<SortOrder>;
  updatedAt?: Maybe<SortOrder>;
};

export type GroupWhereInput = {
  AND?: Maybe<Array<GroupWhereInput>>;
  NOT?: Maybe<Array<GroupWhereInput>>;
  OR?: Maybe<Array<GroupWhereInput>>;
  aliases?: Maybe<GroupAliasListRelationFilter>;
  avatar?: Maybe<ImageWhereInput>;
  avatarId?: Maybe<IntNullableFilter>;
  banner?: Maybe<ImageWhereInput>;
  bannerId?: Maybe<IntNullableFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  id?: Maybe<IntFilter>;
  ireneBotId?: Maybe<IntNullableFilter>;
  members?: Maybe<GroupMemberListRelationFilter>;
  name?: Maybe<StringFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type GroupWhereUniqueInput = {
  avatarId?: Maybe<Scalars['Int']>;
  bannerId?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  ireneBotId?: Maybe<Scalars['Int']>;
};

export type Homepage = {
  __typename?: 'Homepage';
  trending: Array<Array<HomepageTrendingPerson>>;
};

export type HomepageTrendingPerson = {
  __typename?: 'HomepageTrendingPerson';
  person: Person;
};

export type Image = {
  __typename?: 'Image';
  appearanceTags: Array<AppearanceTag>;
  appearances: Array<Appearance>;
  /** The aspect ratio of the image */
  aspectRatio: Scalars['Float'];
  bytes: Scalars['Int'];
  caption?: Maybe<Scalars['String']>;
  /** A graph of connections people in this image share with others based on images they appear together in up to a depth of 4 */
  connections: ImageConnections;
  createdAt: Scalars['DateTime'];
  faceScanDate?: Maybe<Scalars['DateTime']>;
  /** The name the image file was uploaded with. */
  fileName?: Maybe<Scalars['String']>;
  /** Human readable file size. Use `bytes` for a number representation. */
  fileSize: Scalars['String'];
  /** The center of focus for the image. Calculated based on the position of the faces in the image. */
  focus: ImageCoordinate;
  /** SHA256 checksum of the image. */
  hash: Scalars['String'];
  /** Height of the image in pixels. */
  height: Scalars['Int'];
  id: Scalars['Int'];
  imageTags: Array<ImageTag>;
  ireneBotId?: Maybe<Scalars['Int']>;
  isNsfw: Scalars['Boolean'];
  /** False if not logged in */
  liked?: Maybe<Scalars['Boolean']>;
  /** The IANA media type of the image. */
  mimetype: MimeType;
  /** Dominant colors in the image in decimal format, sorted by frequency. */
  palette: Array<Scalars['Int']>;
  /** The visibility status of the image. */
  public: Scalars['Boolean'];
  /** Direct link to the image on the CDN */
  rawUrl: Scalars['String'];
  /** The unique url identifier of the image. */
  slug: Scalars['String'];
  /** The url the image was taken from (if applicable). Not guaranteed to be a direct image url. */
  source?: Maybe<Scalars['String']>;
  thumbnail: Thumbnail;
  unknownFaces: Array<Face>;
  uploadType: UploadType;
  uploadedBy?: Maybe<User>;
  /** Link to the image on the site */
  url: Scalars['String'];
  views: Scalars['Int'];
  /** Width of the image in pixels. */
  width: Scalars['Int'];
};


export type ImageAppearanceTagsArgs = {
  cursor?: Maybe<AppearanceTagWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  take?: Maybe<Scalars['Int']>;
};


export type ImageAppearancesArgs = {
  cursor?: Maybe<AppearanceWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  take?: Maybe<Scalars['Int']>;
};


export type ImageConnectionsArgs = {
  depth?: Scalars['Int'];
};


export type ImageImageTagsArgs = {
  cursor?: Maybe<ImageTagWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  take?: Maybe<Scalars['Int']>;
};

export enum ImageConnectionEdge {
  ImageToPerson = 'IMAGE_TO_PERSON',
  PersonToImage = 'PERSON_TO_IMAGE'
}

export type ImageConnections = {
  __typename?: 'ImageConnections';
  edges: Array<ImageEdge>;
  images: Array<Image>;
  people: Array<Person>;
};

/** A coordinate representing a position on an image */
export type ImageCoordinate = {
  __typename?: 'ImageCoordinate';
  x: Scalars['Int'];
  y: Scalars['Int'];
};

export type ImageEdge = {
  __typename?: 'ImageEdge';
  from: Scalars['Int'];
  to: Scalars['Int'];
  type?: Maybe<ImageConnectionEdge>;
};

export type ImageLikeListRelationFilter = {
  every?: Maybe<ImageLikeWhereInput>;
  none?: Maybe<ImageLikeWhereInput>;
  some?: Maybe<ImageLikeWhereInput>;
};

export type ImageLikeOrderByRelationAggregateInput = {
  _count?: Maybe<SortOrder>;
};

export type ImageLikeWhereInput = {
  AND?: Maybe<Array<ImageLikeWhereInput>>;
  NOT?: Maybe<Array<ImageLikeWhereInput>>;
  OR?: Maybe<Array<ImageLikeWhereInput>>;
  createdAt?: Maybe<DateTimeFilter>;
  id?: Maybe<IntFilter>;
  image?: Maybe<ImageWhereInput>;
  imageId?: Maybe<IntFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
  user?: Maybe<UserWhereInput>;
  userId?: Maybe<IntFilter>;
};

export type ImageListRelationFilter = {
  every?: Maybe<ImageWhereInput>;
  none?: Maybe<ImageWhereInput>;
  some?: Maybe<ImageWhereInput>;
};

export type ImageOrderByRelationAggregateInput = {
  _count?: Maybe<SortOrder>;
};

export type ImageOrderByWithRelationInput = {
  appearanceTags?: Maybe<AppearanceTagOrderByRelationAggregateInput>;
  appearances?: Maybe<AppearanceOrderByRelationAggregateInput>;
  bytes?: Maybe<SortOrder>;
  caption?: Maybe<SortOrder>;
  createdAt?: Maybe<SortOrder>;
  discoverySource?: Maybe<DiscoveredImageOrderByWithRelationInput>;
  faceScanDate?: Maybe<SortOrder>;
  faceScanRequestDate?: Maybe<SortOrder>;
  faces?: Maybe<FaceOrderByRelationAggregateInput>;
  fileName?: Maybe<SortOrder>;
  groupAvatarOf?: Maybe<GroupOrderByWithRelationInput>;
  groupBannerOf?: Maybe<GroupOrderByWithRelationInput>;
  hash?: Maybe<SortOrder>;
  height?: Maybe<SortOrder>;
  id?: Maybe<SortOrder>;
  imageTags?: Maybe<ImageTagOrderByRelationAggregateInput>;
  ireneBotId?: Maybe<SortOrder>;
  isNsfw?: Maybe<SortOrder>;
  likes?: Maybe<ImageLikeOrderByRelationAggregateInput>;
  mimetype?: Maybe<SortOrder>;
  pHash?: Maybe<SortOrder>;
  palette?: Maybe<SortOrder>;
  personAvatarOf?: Maybe<PersonOrderByWithRelationInput>;
  personBannerOf?: Maybe<PersonOrderByWithRelationInput>;
  potentialDuplicates?: Maybe<DiscoveredImageOrderByRelationAggregateInput>;
  public?: Maybe<SortOrder>;
  slug?: Maybe<SortOrder>;
  source?: Maybe<SortOrder>;
  updatedAt?: Maybe<SortOrder>;
  uploadType?: Maybe<SortOrder>;
  user?: Maybe<UserOrderByWithRelationInput>;
  userAvatarOf?: Maybe<UserOrderByWithRelationInput>;
  userBannerOf?: Maybe<UserOrderByWithRelationInput>;
  userId?: Maybe<SortOrder>;
  views?: Maybe<SortOrder>;
  width?: Maybe<SortOrder>;
  xp?: Maybe<SortOrder>;
};

export type ImageTag = {
  __typename?: 'ImageTag';
  addedBy?: Maybe<User>;
  createdAt: Scalars['DateTime'];
  image: Image;
  tag: Tag;
  updatedAt: Scalars['DateTime'];
};

export type ImageTagImageTagCompoundUniqueInput = {
  imageId: Scalars['Int'];
  tagId: Scalars['Int'];
};

export type ImageTagListRelationFilter = {
  every?: Maybe<ImageTagWhereInput>;
  none?: Maybe<ImageTagWhereInput>;
  some?: Maybe<ImageTagWhereInput>;
};

export type ImageTagOrderByRelationAggregateInput = {
  _count?: Maybe<SortOrder>;
};

export type ImageTagWhereInput = {
  AND?: Maybe<Array<ImageTagWhereInput>>;
  NOT?: Maybe<Array<ImageTagWhereInput>>;
  OR?: Maybe<Array<ImageTagWhereInput>>;
  addedBy?: Maybe<UserWhereInput>;
  addedById?: Maybe<IntNullableFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  id?: Maybe<IntFilter>;
  image?: Maybe<ImageWhereInput>;
  imageId?: Maybe<IntFilter>;
  tag?: Maybe<TagWhereInput>;
  tagId?: Maybe<IntFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type ImageTagWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
  imageTag?: Maybe<ImageTagImageTagCompoundUniqueInput>;
};

export type ImageWhereInput = {
  AND?: Maybe<Array<ImageWhereInput>>;
  NOT?: Maybe<Array<ImageWhereInput>>;
  OR?: Maybe<Array<ImageWhereInput>>;
  appearanceTags?: Maybe<AppearanceTagListRelationFilter>;
  appearances?: Maybe<AppearanceListRelationFilter>;
  bytes?: Maybe<IntFilter>;
  caption?: Maybe<StringNullableFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  discoverySource?: Maybe<DiscoveredImageWhereInput>;
  faceScanDate?: Maybe<DateTimeNullableFilter>;
  faceScanRequestDate?: Maybe<DateTimeNullableFilter>;
  faces?: Maybe<FaceListRelationFilter>;
  fileName?: Maybe<StringNullableFilter>;
  groupAvatarOf?: Maybe<GroupWhereInput>;
  groupBannerOf?: Maybe<GroupWhereInput>;
  hash?: Maybe<StringFilter>;
  height?: Maybe<IntFilter>;
  id?: Maybe<IntFilter>;
  imageTags?: Maybe<ImageTagListRelationFilter>;
  ireneBotId?: Maybe<IntNullableFilter>;
  isNsfw?: Maybe<BoolFilter>;
  likes?: Maybe<ImageLikeListRelationFilter>;
  mimetype?: Maybe<EnumMimeTypeFilter>;
  pHash?: Maybe<StringNullableFilter>;
  palette?: Maybe<IntNullableListFilter>;
  personAvatarOf?: Maybe<PersonWhereInput>;
  personBannerOf?: Maybe<PersonWhereInput>;
  potentialDuplicates?: Maybe<DiscoveredImageListRelationFilter>;
  public?: Maybe<BoolFilter>;
  slug?: Maybe<StringFilter>;
  source?: Maybe<StringNullableFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
  uploadType?: Maybe<EnumUploadTypeFilter>;
  user?: Maybe<UserWhereInput>;
  userAvatarOf?: Maybe<UserWhereInput>;
  userBannerOf?: Maybe<UserWhereInput>;
  userId?: Maybe<IntNullableFilter>;
  views?: Maybe<IntFilter>;
  width?: Maybe<IntFilter>;
  xp?: Maybe<IntFilter>;
};

export type ImageWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
  ireneBotId?: Maybe<Scalars['Int']>;
  slug?: Maybe<Scalars['String']>;
};

export type IntFilter = {
  equals?: Maybe<Scalars['Int']>;
  gt?: Maybe<Scalars['Int']>;
  gte?: Maybe<Scalars['Int']>;
  in?: Maybe<Array<Scalars['Int']>>;
  lt?: Maybe<Scalars['Int']>;
  lte?: Maybe<Scalars['Int']>;
  not?: Maybe<NestedIntFilter>;
  notIn?: Maybe<Array<Scalars['Int']>>;
};

export type IntNullableFilter = {
  equals?: Maybe<Scalars['Int']>;
  gt?: Maybe<Scalars['Int']>;
  gte?: Maybe<Scalars['Int']>;
  in?: Maybe<Array<Scalars['Int']>>;
  lt?: Maybe<Scalars['Int']>;
  lte?: Maybe<Scalars['Int']>;
  not?: Maybe<NestedIntNullableFilter>;
  notIn?: Maybe<Array<Scalars['Int']>>;
};

export type IntNullableListFilter = {
  equals?: Maybe<Array<Scalars['Int']>>;
  has?: Maybe<Scalars['Int']>;
  hasEvery?: Maybe<Array<Scalars['Int']>>;
  hasSome?: Maybe<Array<Scalars['Int']>>;
  isEmpty?: Maybe<Scalars['Boolean']>;
};

export type LeaderboardUser = {
  __typename?: 'LeaderboardUser';
  rank: Scalars['Int'];
  user: User;
  xp: Scalars['Int'];
};

export enum MimeType {
  Avif = 'AVIF',
  Gif = 'GIF',
  Jpg = 'JPG',
  Mp4 = 'MP4',
  Png = 'PNG',
  Svg = 'SVG',
  Webm = 'WEBM',
  Webp = 'WEBP'
}

export type Mutation = {
  __typename?: 'Mutation';
  /** Add an appearance relation on an image. */
  addAppearance: Appearance;
  addProvider: Scalars['String'];
  createAppearanceTag: AppearanceTag;
  createImageTag: ImageTag;
  createTag: Tag;
  deleteAppearanceTag?: Maybe<AppearanceTag>;
  deleteImageTag?: Maybe<ImageTag>;
  discoveredImageVote: DiscoveredImageVote;
  /** Vote using the same verdict on all images in a post */
  discoveredPostVote: Array<DiscoveredImage>;
  /** Attach an existing face to an apperance. */
  linkFace: Appearance;
  /** Removes an appearance from an image */
  removeAppearance: Appearance;
  /** Queue an image to get scanned for faces */
  scanFaces: QueueInfo;
  toggleLike: Image;
  /** Unlinks an existing face from an appearance. This dissociates the face from the appearance but does not remove the face data */
  unlinkFace: Scalars['Int'];
  updatePerson?: Maybe<Person>;
};


export type MutationAddAppearanceArgs = {
  imageId: Scalars['Int'];
  personId: Scalars['Int'];
};


export type MutationAddProviderArgs = {
  provider: AddProviderInput;
};


export type MutationCreateAppearanceTagArgs = {
  appearanceId: Scalars['Int'];
  name: Scalars['String'];
};


export type MutationCreateImageTagArgs = {
  imageId: Scalars['Int'];
  name: Scalars['String'];
};


export type MutationCreateTagArgs = {
  name: Scalars['String'];
};


export type MutationDeleteAppearanceTagArgs = {
  appearanceId: Scalars['Int'];
  name: Scalars['String'];
};


export type MutationDeleteImageTagArgs = {
  imageId: Scalars['Int'];
  name: Scalars['String'];
};


export type MutationDiscoveredImageVoteArgs = {
  imageId: Scalars['Int'];
  reason?: Maybe<Scalars['String']>;
  verdict: Scalars['String'];
};


export type MutationDiscoveredPostVoteArgs = {
  postId: Scalars['Int'];
  reason?: Maybe<Scalars['String']>;
  verdict: Scalars['String'];
};


export type MutationLinkFaceArgs = {
  appearanceId: Scalars['Int'];
  faceId: Scalars['Int'];
};


export type MutationRemoveAppearanceArgs = {
  appearanceId: Scalars['Int'];
};


export type MutationScanFacesArgs = {
  slug: Scalars['String'];
};


export type MutationToggleLikeArgs = {
  imageId: Scalars['Int'];
};


export type MutationUnlinkFaceArgs = {
  appearanceId: Scalars['Int'];
  faceId: Scalars['Int'];
};


export type MutationUpdatePersonArgs = {
  id: Scalars['Int'];
  update: UpdatePersonInputs;
};

export type NestedBoolFilter = {
  equals?: Maybe<Scalars['Boolean']>;
  not?: Maybe<NestedBoolFilter>;
};

export type NestedDateTimeFilter = {
  equals?: Maybe<Scalars['DateTime']>;
  gt?: Maybe<Scalars['DateTime']>;
  gte?: Maybe<Scalars['DateTime']>;
  in?: Maybe<Array<Scalars['DateTime']>>;
  lt?: Maybe<Scalars['DateTime']>;
  lte?: Maybe<Scalars['DateTime']>;
  not?: Maybe<NestedDateTimeFilter>;
  notIn?: Maybe<Array<Scalars['DateTime']>>;
};

export type NestedDateTimeNullableFilter = {
  equals?: Maybe<Scalars['DateTime']>;
  gt?: Maybe<Scalars['DateTime']>;
  gte?: Maybe<Scalars['DateTime']>;
  in?: Maybe<Array<Scalars['DateTime']>>;
  lt?: Maybe<Scalars['DateTime']>;
  lte?: Maybe<Scalars['DateTime']>;
  not?: Maybe<NestedDateTimeNullableFilter>;
  notIn?: Maybe<Array<Scalars['DateTime']>>;
};

export type NestedEnumFaceSourceFilter = {
  equals?: Maybe<FaceSource>;
  in?: Maybe<Array<FaceSource>>;
  not?: Maybe<NestedEnumFaceSourceFilter>;
  notIn?: Maybe<Array<FaceSource>>;
};

export type NestedEnumGenderNullableFilter = {
  equals?: Maybe<Gender>;
  in?: Maybe<Array<Gender>>;
  not?: Maybe<NestedEnumGenderNullableFilter>;
  notIn?: Maybe<Array<Gender>>;
};

export type NestedEnumMimeTypeFilter = {
  equals?: Maybe<MimeType>;
  in?: Maybe<Array<MimeType>>;
  not?: Maybe<NestedEnumMimeTypeFilter>;
  notIn?: Maybe<Array<MimeType>>;
};

export type NestedEnumTagSourceFilter = {
  equals?: Maybe<TagSource>;
  in?: Maybe<Array<TagSource>>;
  not?: Maybe<NestedEnumTagSourceFilter>;
  notIn?: Maybe<Array<TagSource>>;
};

export type NestedEnumUploadTypeFilter = {
  equals?: Maybe<UploadType>;
  in?: Maybe<Array<UploadType>>;
  not?: Maybe<NestedEnumUploadTypeFilter>;
  notIn?: Maybe<Array<UploadType>>;
};

export type NestedFloatFilter = {
  equals?: Maybe<Scalars['Float']>;
  gt?: Maybe<Scalars['Float']>;
  gte?: Maybe<Scalars['Float']>;
  in?: Maybe<Array<Scalars['Float']>>;
  lt?: Maybe<Scalars['Float']>;
  lte?: Maybe<Scalars['Float']>;
  not?: Maybe<NestedFloatFilter>;
  notIn?: Maybe<Array<Scalars['Float']>>;
};

export type NestedIntFilter = {
  equals?: Maybe<Scalars['Int']>;
  gt?: Maybe<Scalars['Int']>;
  gte?: Maybe<Scalars['Int']>;
  in?: Maybe<Array<Scalars['Int']>>;
  lt?: Maybe<Scalars['Int']>;
  lte?: Maybe<Scalars['Int']>;
  not?: Maybe<NestedIntFilter>;
  notIn?: Maybe<Array<Scalars['Int']>>;
};

export type NestedIntNullableFilter = {
  equals?: Maybe<Scalars['Int']>;
  gt?: Maybe<Scalars['Int']>;
  gte?: Maybe<Scalars['Int']>;
  in?: Maybe<Array<Scalars['Int']>>;
  lt?: Maybe<Scalars['Int']>;
  lte?: Maybe<Scalars['Int']>;
  not?: Maybe<NestedIntNullableFilter>;
  notIn?: Maybe<Array<Scalars['Int']>>;
};

export type NestedStringFilter = {
  contains?: Maybe<Scalars['String']>;
  endsWith?: Maybe<Scalars['String']>;
  equals?: Maybe<Scalars['String']>;
  gt?: Maybe<Scalars['String']>;
  gte?: Maybe<Scalars['String']>;
  in?: Maybe<Array<Scalars['String']>>;
  lt?: Maybe<Scalars['String']>;
  lte?: Maybe<Scalars['String']>;
  not?: Maybe<NestedStringFilter>;
  notIn?: Maybe<Array<Scalars['String']>>;
  startsWith?: Maybe<Scalars['String']>;
};

export type NestedStringNullableFilter = {
  contains?: Maybe<Scalars['String']>;
  endsWith?: Maybe<Scalars['String']>;
  equals?: Maybe<Scalars['String']>;
  gt?: Maybe<Scalars['String']>;
  gte?: Maybe<Scalars['String']>;
  in?: Maybe<Array<Scalars['String']>>;
  lt?: Maybe<Scalars['String']>;
  lte?: Maybe<Scalars['String']>;
  not?: Maybe<NestedStringNullableFilter>;
  notIn?: Maybe<Array<Scalars['String']>>;
  startsWith?: Maybe<Scalars['String']>;
};

export type Person = {
  __typename?: 'Person';
  aliases: Array<Alias>;
  appearances: Array<Appearance>;
  avatar?: Maybe<Image>;
  banner?: Maybe<Image>;
  birthDate?: Maybe<Scalars['DateTime']>;
  createdAt: Scalars['DateTime'];
  faces: Array<Face>;
  id: Scalars['Int'];
  memberOf: Array<GroupMember>;
  name: Scalars['String'];
  preferredAlias?: Maybe<Alias>;
  preferredMembership?: Maybe<GroupMember>;
  updatedAt: Scalars['DateTime'];
};


export type PersonAliasesArgs = {
  cursor?: Maybe<AliasWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  take?: Maybe<Scalars['Int']>;
};


export type PersonAppearancesArgs = {
  cursor?: Maybe<AppearanceWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  take?: Maybe<Scalars['Int']>;
};


export type PersonFacesArgs = {
  cursor?: Maybe<FaceWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  take?: Maybe<Scalars['Int']>;
};


export type PersonMemberOfArgs = {
  cursor?: Maybe<GroupMemberWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  take?: Maybe<Scalars['Int']>;
};

export type PersonListRelationFilter = {
  every?: Maybe<PersonWhereInput>;
  none?: Maybe<PersonWhereInput>;
  some?: Maybe<PersonWhereInput>;
};

export type PersonOrderByRelationAggregateInput = {
  _count?: Maybe<SortOrder>;
};

export type PersonOrderByWithRelationInput = {
  aliases?: Maybe<AliasOrderByRelationAggregateInput>;
  appearances?: Maybe<AppearanceOrderByRelationAggregateInput>;
  appearsIn?: Maybe<FaceOrderByRelationAggregateInput>;
  avatar?: Maybe<ImageOrderByWithRelationInput>;
  avatarId?: Maybe<SortOrder>;
  banner?: Maybe<ImageOrderByWithRelationInput>;
  bannerId?: Maybe<SortOrder>;
  birthDate?: Maybe<SortOrder>;
  createdAt?: Maybe<SortOrder>;
  description?: Maybe<SortOrder>;
  gender?: Maybe<SortOrder>;
  id?: Maybe<SortOrder>;
  ireneBotId?: Maybe<SortOrder>;
  memberOf?: Maybe<GroupMemberOrderByRelationAggregateInput>;
  name?: Maybe<SortOrder>;
  preferredAlias?: Maybe<AliasOrderByWithRelationInput>;
  preferredAliasId?: Maybe<SortOrder>;
  preferredMembership?: Maybe<GroupMemberOrderByWithRelationInput>;
  preferredMembershipId?: Maybe<SortOrder>;
  updatedAt?: Maybe<SortOrder>;
};

export type PersonWhereInput = {
  AND?: Maybe<Array<PersonWhereInput>>;
  NOT?: Maybe<Array<PersonWhereInput>>;
  OR?: Maybe<Array<PersonWhereInput>>;
  aliases?: Maybe<AliasListRelationFilter>;
  appearances?: Maybe<AppearanceListRelationFilter>;
  appearsIn?: Maybe<FaceListRelationFilter>;
  avatar?: Maybe<ImageWhereInput>;
  avatarId?: Maybe<IntNullableFilter>;
  banner?: Maybe<ImageWhereInput>;
  bannerId?: Maybe<IntNullableFilter>;
  birthDate?: Maybe<DateTimeNullableFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  description?: Maybe<StringNullableFilter>;
  gender?: Maybe<EnumGenderNullableFilter>;
  id?: Maybe<IntFilter>;
  ireneBotId?: Maybe<IntNullableFilter>;
  memberOf?: Maybe<GroupMemberListRelationFilter>;
  name?: Maybe<StringFilter>;
  preferredAlias?: Maybe<AliasWhereInput>;
  preferredAliasId?: Maybe<IntNullableFilter>;
  preferredMembership?: Maybe<GroupMemberWhereInput>;
  preferredMembershipId?: Maybe<IntNullableFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type PersonWhereUniqueInput = {
  avatarId?: Maybe<Scalars['Int']>;
  bannerId?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['Int']>;
  ireneBotId?: Maybe<Scalars['Int']>;
  preferredAliasId?: Maybe<Scalars['Int']>;
};

/** Statistics associated with each provider */
export type ProviderStatistic = {
  __typename?: 'ProviderStatistic';
  createdAt?: Maybe<Scalars['DateTime']>;
  defaultName?: Maybe<Scalars['String']>;
  destination: Scalars['String'];
  discoveredImages: Scalars['Int'];
  enabled: Scalars['Boolean'];
  lastPost?: Maybe<Scalars['DateTime']>;
  lastScrape?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  official: Scalars['Boolean'];
  priority: Scalars['Float'];
  scrapeCount: Scalars['Int'];
  tokens: Scalars['Float'];
  url: Scalars['String'];
};

export type Query = {
  __typename?: 'Query';
  countAppearances: Array<AppearanceCount>;
  discoveredImages: Array<DiscoveredImage>;
  discoveredPosts: Array<DiscoveredPost>;
  discoveryFeed: Array<DiscoveredPost>;
  discoveryHistory: Array<DiscoveredPost>;
  discoveryLeaderboard: Array<LeaderboardUser>;
  discoveryProviders: Array<ProviderStatistic>;
  discoverySchedule: Array<DiscoveryProvider>;
  discoveryStats: Array<DiscoveryStatistic>;
  group?: Maybe<Group>;
  groups: Array<Group>;
  homepage: Array<Person>;
  /** Find a single image by its slug. */
  image?: Maybe<Image>;
  imageConnections?: Maybe<ImageConnections>;
  images: Array<Image>;
  me?: Maybe<User>;
  people: Array<Person>;
  person?: Maybe<Person>;
  user?: Maybe<User>;
};


export type QueryCountAppearancesArgs = {
  groups: Array<Scalars['Int']>;
};


export type QueryDiscoveredImagesArgs = {
  cursor?: Maybe<DiscoveredImageWhereUniqueInput>;
  orderBy?: Maybe<Array<DiscoveredImageOrderByWithRelationInput>>;
  skip?: Maybe<Scalars['Int']>;
  take?: Maybe<Scalars['Int']>;
  where?: Maybe<DiscoveredImageWhereInput>;
};


export type QueryDiscoveredPostsArgs = {
  cursor?: Maybe<DiscoveredPostWhereUniqueInput>;
  orderBy?: Maybe<Array<DiscoveredPostOrderByWithRelationInput>>;
  skip?: Maybe<Scalars['Int']>;
  take?: Maybe<Scalars['Int']>;
  where?: Maybe<DiscoveredPostWhereInput>;
};


export type QueryDiscoveryFeedArgs = {
  groupIds: Array<Scalars['Int']>;
  peopleIds: Array<Scalars['Int']>;
  skip?: Maybe<Scalars['Int']>;
  take?: Maybe<Scalars['Int']>;
};


export type QueryDiscoveryHistoryArgs = {
  skip?: Maybe<Scalars['Int']>;
  take?: Maybe<Scalars['Int']>;
};


export type QueryDiscoveryLeaderboardArgs = {
  skip?: Maybe<Scalars['Int']>;
  take?: Maybe<Scalars['Int']>;
};


export type QueryGroupArgs = {
  where: GroupWhereUniqueInput;
};


export type QueryGroupsArgs = {
  cursor?: Maybe<GroupWhereUniqueInput>;
  orderBy?: Maybe<Array<GroupOrderByWithRelationInput>>;
  skip?: Maybe<Scalars['Int']>;
  take?: Maybe<Scalars['Int']>;
  where?: Maybe<GroupWhereInput>;
};


export type QueryImageArgs = {
  slug: Scalars['String'];
};


export type QueryImageConnectionsArgs = {
  depth?: Scalars['Int'];
  slug: Scalars['String'];
};


export type QueryImagesArgs = {
  cursor?: Maybe<ImageWhereUniqueInput>;
  orderBy?: Maybe<Array<ImageOrderByWithRelationInput>>;
  skip?: Maybe<Scalars['Int']>;
  take?: Maybe<Scalars['Int']>;
  where?: Maybe<ImageWhereInput>;
};


export type QueryPeopleArgs = {
  cursor?: Maybe<PersonWhereUniqueInput>;
  orderBy?: Maybe<Array<PersonOrderByWithRelationInput>>;
  skip?: Maybe<Scalars['Int']>;
  take?: Maybe<Scalars['Int']>;
  where?: Maybe<PersonWhereInput>;
};


export type QueryPersonArgs = {
  where: PersonWhereUniqueInput;
};


export type QueryUserArgs = {
  id?: Maybe<Scalars['Int']>;
};

export enum QueryMode {
  Default = 'default',
  Insensitive = 'insensitive'
}

export type QueueInfo = {
  __typename?: 'QueueInfo';
  queueSize: Scalars['Int'];
};

export type Role = {
  __typename?: 'Role';
  createdAt: Scalars['DateTime'];
  name: Scalars['String'];
};

export type RoleListRelationFilter = {
  every?: Maybe<RoleWhereInput>;
  none?: Maybe<RoleWhereInput>;
  some?: Maybe<RoleWhereInput>;
};

export type RoleOrderByRelationAggregateInput = {
  _count?: Maybe<SortOrder>;
};

export type RoleWhereInput = {
  AND?: Maybe<Array<RoleWhereInput>>;
  NOT?: Maybe<Array<RoleWhereInput>>;
  OR?: Maybe<Array<RoleWhereInput>>;
  createdAt?: Maybe<DateTimeFilter>;
  id?: Maybe<IntFilter>;
  name?: Maybe<StringFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
  user?: Maybe<UserWhereInput>;
  userId?: Maybe<IntFilter>;
};

export enum SortOrder {
  Asc = 'asc',
  Desc = 'desc'
}

export type StringFilter = {
  contains?: Maybe<Scalars['String']>;
  endsWith?: Maybe<Scalars['String']>;
  equals?: Maybe<Scalars['String']>;
  gt?: Maybe<Scalars['String']>;
  gte?: Maybe<Scalars['String']>;
  in?: Maybe<Array<Scalars['String']>>;
  lt?: Maybe<Scalars['String']>;
  lte?: Maybe<Scalars['String']>;
  mode?: Maybe<QueryMode>;
  not?: Maybe<NestedStringFilter>;
  notIn?: Maybe<Array<Scalars['String']>>;
  startsWith?: Maybe<Scalars['String']>;
};

export type StringNullableFilter = {
  contains?: Maybe<Scalars['String']>;
  endsWith?: Maybe<Scalars['String']>;
  equals?: Maybe<Scalars['String']>;
  gt?: Maybe<Scalars['String']>;
  gte?: Maybe<Scalars['String']>;
  in?: Maybe<Array<Scalars['String']>>;
  lt?: Maybe<Scalars['String']>;
  lte?: Maybe<Scalars['String']>;
  mode?: Maybe<QueryMode>;
  not?: Maybe<NestedStringNullableFilter>;
  notIn?: Maybe<Array<Scalars['String']>>;
  startsWith?: Maybe<Scalars['String']>;
};

export type Tag = {
  __typename?: 'Tag';
  addedBy?: Maybe<User>;
  aliases: Array<TagAlias>;
  category?: Maybe<TagCategory>;
  createdAt: Scalars['DateTime'];
  name: Scalars['String'];
  source: TagSource;
};


export type TagAliasesArgs = {
  cursor?: Maybe<TagAliasWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  take?: Maybe<Scalars['Int']>;
};

export type TagAlias = {
  __typename?: 'TagAlias';
  addedBy?: Maybe<User>;
  createdAt: Scalars['DateTime'];
  name: Scalars['String'];
  tag: Tag;
  updatedAt: Scalars['DateTime'];
};

export type TagAliasAliasTagCompoundUniqueInput = {
  name: Scalars['String'];
  tagId: Scalars['Int'];
};

export type TagAliasListRelationFilter = {
  every?: Maybe<TagAliasWhereInput>;
  none?: Maybe<TagAliasWhereInput>;
  some?: Maybe<TagAliasWhereInput>;
};

export type TagAliasOrderByRelationAggregateInput = {
  _count?: Maybe<SortOrder>;
};

export type TagAliasWhereInput = {
  AND?: Maybe<Array<TagAliasWhereInput>>;
  NOT?: Maybe<Array<TagAliasWhereInput>>;
  OR?: Maybe<Array<TagAliasWhereInput>>;
  addedBy?: Maybe<UserWhereInput>;
  addedById?: Maybe<IntNullableFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  id?: Maybe<IntFilter>;
  name?: Maybe<StringFilter>;
  tag?: Maybe<TagWhereInput>;
  tagId?: Maybe<IntFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type TagAliasWhereUniqueInput = {
  aliasTag?: Maybe<TagAliasAliasTagCompoundUniqueInput>;
  id?: Maybe<Scalars['Int']>;
};

export type TagCategory = {
  __typename?: 'TagCategory';
  addedBy?: Maybe<User>;
  createdAt: Scalars['DateTime'];
  name: Scalars['String'];
  updatedAt: Scalars['DateTime'];
};

export type TagCategoryListRelationFilter = {
  every?: Maybe<TagCategoryWhereInput>;
  none?: Maybe<TagCategoryWhereInput>;
  some?: Maybe<TagCategoryWhereInput>;
};

export type TagCategoryOrderByRelationAggregateInput = {
  _count?: Maybe<SortOrder>;
};

export type TagCategoryWhereInput = {
  AND?: Maybe<Array<TagCategoryWhereInput>>;
  NOT?: Maybe<Array<TagCategoryWhereInput>>;
  OR?: Maybe<Array<TagCategoryWhereInput>>;
  addedBy?: Maybe<UserWhereInput>;
  addedById?: Maybe<IntNullableFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  id?: Maybe<IntFilter>;
  name?: Maybe<StringFilter>;
  tags?: Maybe<TagListRelationFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type TagListRelationFilter = {
  every?: Maybe<TagWhereInput>;
  none?: Maybe<TagWhereInput>;
  some?: Maybe<TagWhereInput>;
};

export type TagOrderByRelationAggregateInput = {
  _count?: Maybe<SortOrder>;
};

export enum TagSource {
  User = 'USER'
}

export type TagWhereInput = {
  AND?: Maybe<Array<TagWhereInput>>;
  NOT?: Maybe<Array<TagWhereInput>>;
  OR?: Maybe<Array<TagWhereInput>>;
  addedBy?: Maybe<UserWhereInput>;
  addedById?: Maybe<IntNullableFilter>;
  aliases?: Maybe<TagAliasListRelationFilter>;
  appearances?: Maybe<AppearanceTagListRelationFilter>;
  category?: Maybe<TagCategoryWhereInput>;
  categoryId?: Maybe<IntNullableFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  id?: Maybe<IntFilter>;
  images?: Maybe<ImageTagListRelationFilter>;
  name?: Maybe<StringFilter>;
  source?: Maybe<EnumTagSourceFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

/** Preview urls of an image */
export type Thumbnail = {
  __typename?: 'Thumbnail';
  large: Scalars['String'];
  medium: Scalars['String'];
  small: Scalars['String'];
};

export type UpdatePersonInputs = {
  aliases: Array<Scalars['String']>;
  avatarId?: Maybe<Scalars['Int']>;
  bannerId?: Maybe<Scalars['Int']>;
  birthDate?: Maybe<Scalars['DateTime']>;
  description?: Maybe<Scalars['String']>;
  gender?: Maybe<Gender>;
  groups: Array<GroupMembership>;
  name: Scalars['String'];
  preferredAliasId?: Maybe<Scalars['Int']>;
  preferredMembershipId?: Maybe<Scalars['Int']>;
};

export enum UploadType {
  AutoDiscovery = 'AUTO_DISCOVERY',
  Token = 'TOKEN',
  Website = 'WEBSITE'
}

export type User = {
  __typename?: 'User';
  avatar?: Maybe<Image>;
  bot: Scalars['Boolean'];
  createdAt: Scalars['DateTime'];
  id: Scalars['Int'];
  image?: Maybe<Scalars['String']>;
  images: Array<Image>;
  name?: Maybe<Scalars['String']>;
  roles: Array<Role>;
  xp?: Maybe<Scalars['Int']>;
};


export type UserImagesArgs = {
  cursor?: Maybe<ImageWhereUniqueInput>;
  orderBy?: Maybe<Array<ImageOrderByWithRelationInput>>;
  skip?: Maybe<Scalars['Int']>;
  take?: Maybe<Scalars['Int']>;
  where?: Maybe<ImageWhereInput>;
};

export type UserOrderByWithRelationInput = {
  DiscoveredImageVote?: Maybe<DiscoveredImageVoteOrderByRelationAggregateInput>;
  appearanceTags?: Maybe<AppearanceTagOrderByRelationAggregateInput>;
  avatar?: Maybe<ImageOrderByWithRelationInput>;
  avatarId?: Maybe<SortOrder>;
  banner?: Maybe<ImageOrderByWithRelationInput>;
  bannerId?: Maybe<SortOrder>;
  bot?: Maybe<SortOrder>;
  cratedTags?: Maybe<TagOrderByRelationAggregateInput>;
  createdAt?: Maybe<SortOrder>;
  email?: Maybe<SortOrder>;
  emailVerified?: Maybe<SortOrder>;
  id?: Maybe<SortOrder>;
  image?: Maybe<SortOrder>;
  imageLikes?: Maybe<ImageLikeOrderByRelationAggregateInput>;
  imageTags?: Maybe<ImageTagOrderByRelationAggregateInput>;
  images?: Maybe<ImageOrderByRelationAggregateInput>;
  markedFaces?: Maybe<FaceOrderByRelationAggregateInput>;
  name?: Maybe<SortOrder>;
  roles?: Maybe<RoleOrderByRelationAggregateInput>;
  tagAliases?: Maybe<TagAliasOrderByRelationAggregateInput>;
  tagCategories?: Maybe<TagCategoryOrderByRelationAggregateInput>;
  taggedAppearances?: Maybe<AppearanceOrderByRelationAggregateInput>;
  token?: Maybe<SortOrder>;
  updatedAt?: Maybe<SortOrder>;
};

export type UserWhereInput = {
  AND?: Maybe<Array<UserWhereInput>>;
  DiscoveredImageVote?: Maybe<DiscoveredImageVoteListRelationFilter>;
  NOT?: Maybe<Array<UserWhereInput>>;
  OR?: Maybe<Array<UserWhereInput>>;
  appearanceTags?: Maybe<AppearanceTagListRelationFilter>;
  avatar?: Maybe<ImageWhereInput>;
  avatarId?: Maybe<IntNullableFilter>;
  banner?: Maybe<ImageWhereInput>;
  bannerId?: Maybe<IntNullableFilter>;
  bot?: Maybe<BoolFilter>;
  cratedTags?: Maybe<TagListRelationFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  email?: Maybe<StringNullableFilter>;
  emailVerified?: Maybe<DateTimeNullableFilter>;
  id?: Maybe<IntFilter>;
  image?: Maybe<StringNullableFilter>;
  imageLikes?: Maybe<ImageLikeListRelationFilter>;
  imageTags?: Maybe<ImageTagListRelationFilter>;
  images?: Maybe<ImageListRelationFilter>;
  markedFaces?: Maybe<FaceListRelationFilter>;
  name?: Maybe<StringNullableFilter>;
  roles?: Maybe<RoleListRelationFilter>;
  tagAliases?: Maybe<TagAliasListRelationFilter>;
  tagCategories?: Maybe<TagCategoryListRelationFilter>;
  taggedAppearances?: Maybe<AppearanceListRelationFilter>;
  token?: Maybe<StringNullableFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type PersonGridDataFragment = (
  { __typename?: 'Person' }
  & Pick<Person, 'id' | 'name'>
  & { avatar?: Maybe<(
    { __typename?: 'Image' }
    & { thumbnail: (
      { __typename?: 'Thumbnail' }
      & Pick<Thumbnail, 'medium'>
    ) }
  )>, preferredMembership?: Maybe<(
    { __typename?: 'GroupMember' }
    & { group: (
      { __typename?: 'Group' }
      & Pick<Group, 'name'>
    ) }
  )>, preferredAlias?: Maybe<(
    { __typename?: 'Alias' }
    & Pick<Alias, 'name'>
  )> }
);

export type BrowsePageIdolsWithFilterQueryVariables = Exact<{
  skip: Scalars['Int'];
  take: Scalars['Int'];
  groups: Array<Scalars['Int']> | Scalars['Int'];
}>;


export type BrowsePageIdolsWithFilterQuery = (
  { __typename?: 'Query' }
  & { people: Array<(
    { __typename?: 'Person' }
    & PersonGridDataFragment
  )> }
);

export type BrowsePageIdolsQueryVariables = Exact<{
  skip: Scalars['Int'];
  take: Scalars['Int'];
}>;


export type BrowsePageIdolsQuery = (
  { __typename?: 'Query' }
  & { people: Array<(
    { __typename?: 'Person' }
    & PersonGridDataFragment
  )> }
);

export type BrowsePageQueryVariables = Exact<{
  take: Scalars['Int'];
  skip?: Maybe<Scalars['Int']>;
}>;


export type BrowsePageQuery = (
  { __typename?: 'Query' }
  & { images: Array<(
    { __typename?: 'Image' }
    & GridImageFragment
  )> }
);

export type AddAppearanceTagMutationVariables = Exact<{
  name: Scalars['String'];
  appearanceId: Scalars['Int'];
}>;


export type AddAppearanceTagMutation = (
  { __typename?: 'Mutation' }
  & { createAppearanceTag: (
    { __typename?: 'AppearanceTag' }
    & { tag: (
      { __typename?: 'Tag' }
      & Pick<Tag, 'name'>
    ) }
  ) }
);

export type DeleteAppearanceTagMutationVariables = Exact<{
  name: Scalars['String'];
  appearanceId: Scalars['Int'];
}>;


export type DeleteAppearanceTagMutation = (
  { __typename?: 'Mutation' }
  & { deleteAppearanceTag?: Maybe<(
    { __typename?: 'AppearanceTag' }
    & { tag: (
      { __typename?: 'Tag' }
      & Pick<Tag, 'name'>
    ) }
  )> }
);

export type PersonEditDataQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type PersonEditDataQuery = (
  { __typename?: 'Query' }
  & { person?: Maybe<(
    { __typename?: 'Person' }
    & Pick<Person, 'birthDate'>
    & { memberOf: Array<(
      { __typename?: 'GroupMember' }
      & { group: (
        { __typename?: 'Group' }
        & Pick<Group, 'id' | 'name'>
      ) }
    )>, preferredMembership?: Maybe<(
      { __typename?: 'GroupMember' }
      & { group: (
        { __typename?: 'Group' }
        & Pick<Group, 'id' | 'name'>
      ) }
    )>, aliases: Array<(
      { __typename?: 'Alias' }
      & Pick<Alias, 'name'>
    )>, preferredAlias?: Maybe<(
      { __typename?: 'Alias' }
      & Pick<Alias, 'name'>
    )>, banner?: Maybe<(
      { __typename?: 'Image' }
      & Pick<Image, 'id' | 'rawUrl'>
      & { thumbnail: (
        { __typename?: 'Thumbnail' }
        & Pick<Thumbnail, 'medium'>
      ) }
    )>, avatar?: Maybe<(
      { __typename?: 'Image' }
      & Pick<Image, 'id' | 'rawUrl'>
      & { thumbnail: (
        { __typename?: 'Thumbnail' }
        & Pick<Thumbnail, 'medium'>
      ) }
    )> }
  )> }
);

export type PersonEditMutationVariables = Exact<{
  id: Scalars['Int'];
  input: UpdatePersonInputs;
}>;


export type PersonEditMutation = (
  { __typename?: 'Mutation' }
  & { updatePerson?: Maybe<(
    { __typename?: 'Person' }
    & Pick<Person, 'id' | 'name' | 'birthDate'>
    & { appearances: Array<(
      { __typename?: 'Appearance' }
      & Pick<Appearance, 'id'>
      & { image: (
        { __typename?: 'Image' }
        & GridImageFragment
      ) }
    )>, memberOf: Array<(
      { __typename?: 'GroupMember' }
      & OnePersonRelationshipMembershipFragment
    )>, preferredMembership?: Maybe<(
      { __typename?: 'GroupMember' }
      & OnePersonRelationshipMembershipFragment
    )>, aliases: Array<(
      { __typename?: 'Alias' }
      & Pick<Alias, 'id' | 'name'>
    )>, avatar?: Maybe<(
      { __typename?: 'Image' }
      & FocusFragment
      & OnePersonRelationshipImageFragment
    )>, preferredAlias?: Maybe<(
      { __typename?: 'Alias' }
      & Pick<Alias, 'id' | 'name'>
    )>, banner?: Maybe<(
      { __typename?: 'Image' }
      & Pick<Image, 'id' | 'rawUrl'>
      & FocusFragment
    )> }
  )> }
);

export type AddProviderMutationVariables = Exact<{
  provider: AddProviderInput;
}>;


export type AddProviderMutation = (
  { __typename?: 'Mutation' }
  & Pick<Mutation, 'addProvider'>
);

export type DiscoveryProvidersQueryVariables = Exact<{ [key: string]: never; }>;


export type DiscoveryProvidersQuery = (
  { __typename?: 'Query' }
  & { discoveryProviders: Array<(
    { __typename?: 'ProviderStatistic' }
    & Pick<ProviderStatistic, 'name' | 'destination' | 'defaultName' | 'enabled' | 'lastScrape' | 'scrapeCount' | 'lastPost' | 'discoveredImages' | 'official' | 'url' | 'createdAt'>
  )> }
);

export type DiscoveryLeaderboardQueryVariables = Exact<{ [key: string]: never; }>;


export type DiscoveryLeaderboardQuery = (
  { __typename?: 'Query' }
  & { discoveryLeaderboard: Array<(
    { __typename?: 'LeaderboardUser' }
    & Pick<LeaderboardUser, 'rank' | 'xp'>
    & { user: (
      { __typename?: 'User' }
      & Pick<User, 'id' | 'image' | 'name' | 'bot'>
    ) }
  )> }
);

export type DiscoveryHistoryQueryVariables = Exact<{
  take: Scalars['Int'];
  skip?: Scalars['Int'];
}>;


export type DiscoveryHistoryQuery = (
  { __typename?: 'Query' }
  & { discoveryHistory: Array<(
    { __typename?: 'DiscoveredPost' }
    & DiscoveryPostListableFragment
  )> }
);

export type OnePersonRelationshipImageFragment = (
  { __typename?: 'Image' }
  & Pick<Image, 'id'>
  & { thumbnail: (
    { __typename?: 'Thumbnail' }
    & Pick<Thumbnail, 'small'>
  ) }
);

export type OnePersonRelationshipMembershipFragment = (
  { __typename?: 'GroupMember' }
  & Pick<GroupMember, 'id' | 'startDate'>
  & { group: (
    { __typename?: 'Group' }
    & Pick<Group, 'id' | 'name'>
    & { avatar?: Maybe<(
      { __typename?: 'Image' }
      & Pick<Image, 'width' | 'height'>
      & { focus: (
        { __typename?: 'ImageCoordinate' }
        & Pick<ImageCoordinate, 'x' | 'y'>
      ), thumbnail: (
        { __typename?: 'Thumbnail' }
        & Pick<Thumbnail, 'small'>
      ) }
    )> }
  ) }
);

export type OnePersonQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type OnePersonQuery = (
  { __typename?: 'Query' }
  & { person?: Maybe<(
    { __typename?: 'Person' }
    & Pick<Person, 'id' | 'name' | 'birthDate'>
    & { appearances: Array<(
      { __typename?: 'Appearance' }
      & Pick<Appearance, 'id'>
      & { image: (
        { __typename?: 'Image' }
        & GridImageFragment
      ) }
    )>, memberOf: Array<(
      { __typename?: 'GroupMember' }
      & OnePersonRelationshipMembershipFragment
    )>, preferredMembership?: Maybe<(
      { __typename?: 'GroupMember' }
      & OnePersonRelationshipMembershipFragment
    )>, aliases: Array<(
      { __typename?: 'Alias' }
      & Pick<Alias, 'id' | 'name'>
    )>, avatar?: Maybe<(
      { __typename?: 'Image' }
      & FocusFragment
      & OnePersonRelationshipImageFragment
    )>, preferredAlias?: Maybe<(
      { __typename?: 'Alias' }
      & Pick<Alias, 'id' | 'name'>
    )>, banner?: Maybe<(
      { __typename?: 'Image' }
      & Pick<Image, 'id' | 'rawUrl'>
      & FocusFragment
    )> }
  )> }
);

export type AddToQueueMutationVariables = Exact<{
  slug: Scalars['String'];
}>;


export type AddToQueueMutation = (
  { __typename?: 'Mutation' }
  & { scanFaces: (
    { __typename?: 'QueueInfo' }
    & Pick<QueueInfo, 'queueSize'>
  ) }
);

export type UserDataQueryVariables = Exact<{ [key: string]: never; }>;


export type UserDataQuery = (
  { __typename?: 'Query' }
  & { me?: Maybe<(
    { __typename?: 'User' }
    & Pick<User, 'id' | 'name' | 'image' | 'xp' | 'createdAt'>
    & { roles: Array<(
      { __typename?: 'Role' }
      & Pick<Role, 'name'>
    )> }
  )> }
);

export type OneImageQueryVariables = Exact<{
  slug: Scalars['String'];
}>;


export type OneImageQuery = (
  { __typename?: 'Query' }
  & { image?: Maybe<(
    { __typename?: 'Image' }
    & Pick<Image, 'liked' | 'faceScanDate' | 'public'>
    & { unknownFaces: Array<(
      { __typename?: 'Face' }
      & { appearance?: Maybe<(
        { __typename?: 'Appearance' }
        & AppearanceDataFragment
      )> }
      & FaceDataFragment
    )>, appearances: Array<(
      { __typename?: 'Appearance' }
      & Pick<Appearance, 'id'>
      & { person: (
        { __typename?: 'Person' }
        & Pick<Person, 'id' | 'name'>
        & { preferredAlias?: Maybe<(
          { __typename?: 'Alias' }
          & Pick<Alias, 'name'>
        )> }
      ), tags: Array<(
        { __typename?: 'AppearanceTag' }
        & { tag: (
          { __typename?: 'Tag' }
          & Pick<Tag, 'name'>
        ) }
      )>, faces: Array<(
        { __typename?: 'Face' }
        & FaceDataFragment
      )> }
    )>, uploadedBy?: Maybe<(
      { __typename?: 'User' }
      & { roles: Array<(
        { __typename?: 'Role' }
        & UserRoleDataFragment
      )> }
      & UserDataFragment
    )> }
    & ImageDataFragment
  )> }
);

export type PersonPageQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type PersonPageQuery = (
  { __typename?: 'Query' }
  & { person?: Maybe<(
    { __typename?: 'Person' }
    & Pick<Person, 'name' | 'birthDate'>
    & { aliases: Array<(
      { __typename?: 'Alias' }
      & Pick<Alias, 'id' | 'name'>
    )>, preferredAlias?: Maybe<(
      { __typename?: 'Alias' }
      & Pick<Alias, 'name'>
    )>, appearances: Array<(
      { __typename?: 'Appearance' }
      & Pick<Appearance, 'createdAt'>
      & { image: (
        { __typename?: 'Image' }
        & { thumbnail: (
          { __typename?: 'Thumbnail' }
          & Pick<Thumbnail, 'medium'>
        ) }
        & ImageDataFragment
      ) }
    )> }
  )> }
);

export type AppearanceDataFragment = (
  { __typename?: 'Appearance' }
  & Pick<Appearance, 'id'>
  & { person: (
    { __typename?: 'Person' }
    & Pick<Person, 'id' | 'name'>
    & { preferredAlias?: Maybe<(
      { __typename?: 'Alias' }
      & Pick<Alias, 'name'>
    )> }
  ) }
);

export type ConnectionGraphQueryVariables = Exact<{
  slug: Scalars['String'];
}>;


export type ConnectionGraphQuery = (
  { __typename?: 'Query' }
  & { imageConnections?: Maybe<(
    { __typename?: 'ImageConnections' }
    & { edges: Array<(
      { __typename?: 'ImageEdge' }
      & Pick<ImageEdge, 'type' | 'to' | 'from'>
    )>, people: Array<(
      { __typename?: 'Person' }
      & Pick<Person, 'id' | 'name'>
    )>, images: Array<(
      { __typename?: 'Image' }
      & Pick<Image, 'slug' | 'id' | 'rawUrl'>
    )> }
  )> }
);

export type DiscoveryPostListableFragment = (
  { __typename?: 'DiscoveredPost' }
  & Pick<DiscoveredPost, 'id' | 'providerType' | 'uniqueIdentifier' | 'body' | 'accountName' | 'accountAvatarUrl' | 'postUrl' | 'createdAt' | 'originalPostDate'>
  & { referencingGroups: Array<(
    { __typename?: 'Group' }
    & Pick<Group, 'id' | 'name'>
  )>, images: Array<(
    { __typename?: 'DiscoveredImage' }
    & Pick<DiscoveredImage, 'thumbnail' | 'url' | 'id'>
    & { vote?: Maybe<(
      { __typename?: 'DiscoveredImageVote' }
      & Pick<DiscoveredImageVote, 'verdict'>
    )>, duplicateImage?: Maybe<(
      { __typename?: 'Image' }
      & Pick<Image, 'url' | 'rawUrl'>
    )> }
  )> }
);

export type DiscoveryScheduleQueryVariables = Exact<{ [key: string]: never; }>;


export type DiscoveryScheduleQuery = (
  { __typename?: 'Query' }
  & { discoverySchedule: Array<(
    { __typename?: 'DiscoveryProvider' }
    & Pick<DiscoveryProvider, 'destination' | 'name' | 'waitDays' | 'url' | 'provider' | 'official'>
  )> }
);

export type DiscoveryStatsQueryVariables = Exact<{ [key: string]: never; }>;


export type DiscoveryStatsQuery = (
  { __typename?: 'Query' }
  & { discoveryStats: Array<(
    { __typename?: 'DiscoveryStatistic' }
    & Pick<DiscoveryStatistic, 'count' | 'verdict'>
  )> }
);

export type DiscoveredPostsQueryVariables = Exact<{
  skip: Scalars['Int'];
  take: Scalars['Int'];
  groupIds?: Array<Scalars['Int']> | Scalars['Int'];
  peopleIds?: Array<Scalars['Int']> | Scalars['Int'];
}>;


export type DiscoveredPostsQuery = (
  { __typename?: 'Query' }
  & { discoveryFeed: Array<(
    { __typename?: 'DiscoveredPost' }
    & DiscoveryPostListableFragment
  )> }
);

export type VoteDiscoveryImageMutationVariables = Exact<{
  imageId: Scalars['Int'];
  verdict: Scalars['String'];
  reason?: Maybe<Scalars['String']>;
}>;


export type VoteDiscoveryImageMutation = (
  { __typename?: 'Mutation' }
  & { discoveredImageVote: (
    { __typename?: 'DiscoveredImageVote' }
    & Pick<DiscoveredImageVote, 'id'>
  ) }
);

export type VoteDiscoveryPostMutationVariables = Exact<{
  postId: Scalars['Int'];
  verdict: Scalars['String'];
  reason?: Maybe<Scalars['String']>;
}>;


export type VoteDiscoveryPostMutation = (
  { __typename?: 'Mutation' }
  & { discoveredPostVote: Array<(
    { __typename?: 'DiscoveredImage' }
    & Pick<DiscoveredImage, 'id'>
    & { vote?: Maybe<(
      { __typename?: 'DiscoveredImageVote' }
      & Pick<DiscoveredImageVote, 'reason' | 'verdict'>
    )> }
  )> }
);

export type FaceDataFragment = (
  { __typename?: 'Face' }
  & Pick<Face, 'id' | 'x' | 'y' | 'width' | 'height' | 'score'>
);

export type HomepagePersonQueryVariables = Exact<{
  take: Scalars['Int'];
  skip: Scalars['Int'];
  id: Scalars['Int'];
}>;


export type HomepagePersonQuery = (
  { __typename?: 'Query' }
  & { images: Array<(
    { __typename?: 'Image' }
    & GridImageFragment
  )> }
);

export type HomepageQueryVariables = Exact<{ [key: string]: never; }>;


export type HomepageQuery = (
  { __typename?: 'Query' }
  & { homepage: Array<(
    { __typename?: 'Person' }
    & Pick<Person, 'id' | 'name'>
    & { preferredAlias?: Maybe<(
      { __typename?: 'Alias' }
      & Pick<Alias, 'name'>
    )>, preferredMembership?: Maybe<(
      { __typename?: 'GroupMember' }
      & { group: (
        { __typename?: 'Group' }
        & Pick<Group, 'name'>
      ) }
    )>, avatar?: Maybe<(
      { __typename?: 'Image' }
      & Pick<Image, 'url' | 'createdAt'>
      & { thumbnail: (
        { __typename?: 'Thumbnail' }
        & Pick<Thumbnail, 'small'>
      ) }
    )>, banner?: Maybe<(
      { __typename?: 'Image' }
      & Pick<Image, 'url' | 'rawUrl' | 'width' | 'height'>
      & { focus: (
        { __typename?: 'ImageCoordinate' }
        & Pick<ImageCoordinate, 'x' | 'y'>
      ) }
    )> }
  )> }
);

export type FocusFragment = (
  { __typename?: 'Image' }
  & Pick<Image, 'width' | 'height'>
  & { focus: (
    { __typename?: 'ImageCoordinate' }
    & Pick<ImageCoordinate, 'x' | 'y'>
  ) }
);

export type ImageDataFragment = (
  { __typename?: 'Image' }
  & Pick<Image, 'id' | 'height' | 'width' | 'isNsfw' | 'url' | 'rawUrl' | 'createdAt' | 'caption' | 'public' | 'source' | 'slug' | 'bytes' | 'mimetype' | 'palette'>
  & { imageTags: Array<(
    { __typename?: 'ImageTag' }
    & { tag: (
      { __typename?: 'Tag' }
      & Pick<Tag, 'name'>
    ) }
  )> }
);

export type GridImageFragment = (
  { __typename?: 'Image' }
  & Pick<Image, 'id' | 'url' | 'height' | 'width' | 'rawUrl' | 'aspectRatio' | 'createdAt'>
  & { focus: (
    { __typename?: 'ImageCoordinate' }
    & Pick<ImageCoordinate, 'x' | 'y'>
  ), thumbnail: (
    { __typename?: 'Thumbnail' }
    & Pick<Thumbnail, 'small'>
  ), uploadedBy?: Maybe<(
    { __typename?: 'User' }
    & Pick<User, 'id' | 'name'>
  )>, appearances: Array<(
    { __typename?: 'Appearance' }
    & Pick<Appearance, 'id'>
    & { person: (
      { __typename?: 'Person' }
      & Pick<Person, 'name'>
    ) }
  )> }
);

export type PersonGridImageFragment = (
  { __typename?: 'Person' }
  & Pick<Person, 'id' | 'name'>
  & { preferredAlias?: Maybe<(
    { __typename?: 'Alias' }
    & Pick<Alias, 'name'>
  )>, avatar?: Maybe<(
    { __typename?: 'Image' }
    & { thumbnail: (
      { __typename?: 'Thumbnail' }
      & Pick<Thumbnail, 'medium'>
    ) }
  )> }
);

export type AppearanceWithFacesFragment = (
  { __typename?: 'Appearance' }
  & Pick<Appearance, 'id'>
  & { faces: Array<(
    { __typename?: 'Face' }
    & FaceDataFragment
  )>, person: (
    { __typename?: 'Person' }
    & Pick<Person, 'name'>
    & { preferredAlias?: Maybe<(
      { __typename?: 'Alias' }
      & Pick<Alias, 'name'>
    )> }
  ), tags: Array<(
    { __typename?: 'AppearanceTag' }
    & { tag: (
      { __typename?: 'Tag' }
      & Pick<Tag, 'name'>
    ) }
  )> }
);

export type AddAppearanceMutationVariables = Exact<{
  imageId: Scalars['Int'];
  personId: Scalars['Int'];
}>;


export type AddAppearanceMutation = (
  { __typename?: 'Mutation' }
  & { appearance: (
    { __typename?: 'Appearance' }
    & AppearanceWithFacesFragment
  ) }
);

export type RemoveAppearanceMutationVariables = Exact<{
  appearanceId: Scalars['Int'];
}>;


export type RemoveAppearanceMutation = (
  { __typename?: 'Mutation' }
  & { appearance: (
    { __typename?: 'Appearance' }
    & Pick<Appearance, 'id'>
  ) }
);

export type LinkFaceMutationVariables = Exact<{
  appearanceId: Scalars['Int'];
  faceId: Scalars['Int'];
}>;


export type LinkFaceMutation = (
  { __typename?: 'Mutation' }
  & { appearance: (
    { __typename?: 'Appearance' }
    & AppearanceWithFacesFragment
  ) }
);

export type UnlinkFaceMutationVariables = Exact<{
  appearanceId: Scalars['Int'];
  faceId: Scalars['Int'];
}>;


export type UnlinkFaceMutation = (
  { __typename?: 'Mutation' }
  & Pick<Mutation, 'unlinkFace'>
);

export type GetUploadResultQueryVariables = Exact<{
  slug: Scalars['String'];
}>;


export type GetUploadResultQuery = (
  { __typename?: 'Query' }
  & { image?: Maybe<(
    { __typename?: 'Image' }
    & { appearances: Array<(
      { __typename?: 'Appearance' }
      & Pick<Appearance, 'id'>
      & { person: (
        { __typename?: 'Person' }
        & Pick<Person, 'id' | 'name'>
      ), faces: Array<(
        { __typename?: 'Face' }
        & FaceDataFragment
      )> }
    )> }
    & ImageDataFragment
  )> }
);

export type MeQueryVariables = Exact<{ [key: string]: never; }>;


export type MeQuery = (
  { __typename?: 'Query' }
  & { me?: Maybe<(
    { __typename?: 'User' }
    & { images: Array<(
      { __typename?: 'Image' }
      & GridImageFragment
    )>, roles: Array<(
      { __typename?: 'Role' }
      & UserRoleDataFragment
    )> }
    & UserDataFragment
  )> }
);

export type ToggleLikeMutationVariables = Exact<{
  id: Scalars['Int'];
}>;


export type ToggleLikeMutation = (
  { __typename?: 'Mutation' }
  & { toggleLike: (
    { __typename?: 'Image' }
    & Pick<Image, 'liked'>
    & ImageDataFragment
  ) }
);

export type UserDataFragment = (
  { __typename?: 'User' }
  & Pick<User, 'id' | 'name' | 'bot'>
  & { avatar: User['image'] }
);

export type UserRoleDataFragment = (
  { __typename?: 'Role' }
  & Pick<Role, 'name'>
);

export const PersonGridDataFragmentDoc = `
    fragment PersonGridData on Person {
  id
  avatar {
    thumbnail {
      medium
    }
  }
  name
  preferredMembership {
    group {
      name
    }
  }
  preferredAlias {
    name
  }
}
    `;
export const OnePersonRelationshipImageFragmentDoc = `
    fragment OnePersonRelationshipImage on Image {
  id
  thumbnail {
    small
  }
}
    `;
export const OnePersonRelationshipMembershipFragmentDoc = `
    fragment OnePersonRelationshipMembership on GroupMember {
  id
  startDate
  group {
    id
    avatar {
      width
      height
      focus {
        x
        y
      }
      thumbnail {
        small
      }
    }
    name
  }
}
    `;
export const AppearanceDataFragmentDoc = `
    fragment AppearanceData on Appearance {
  id
  person {
    id
    name
    preferredAlias {
      name
    }
  }
}
    `;
export const DiscoveryPostListableFragmentDoc = `
    fragment DiscoveryPostListable on DiscoveredPost {
  id
  providerType
  uniqueIdentifier
  body
  accountName
  accountAvatarUrl
  postUrl
  createdAt
  originalPostDate
  referencingGroups {
    id
    name
  }
  images {
    thumbnail
    url
    id
    vote {
      verdict
    }
    duplicateImage {
      url
      rawUrl
    }
  }
}
    `;
export const FocusFragmentDoc = `
    fragment Focus on Image {
  width
  height
  focus {
    x
    y
  }
}
    `;
export const ImageDataFragmentDoc = `
    fragment ImageData on Image {
  id
  height
  width
  isNsfw
  url
  rawUrl
  createdAt
  caption
  public
  source
  slug
  bytes
  mimetype
  palette
  imageTags {
    tag {
      name
    }
  }
}
    `;
export const GridImageFragmentDoc = `
    fragment GridImage on Image {
  id
  url
  height
  width
  focus {
    x
    y
  }
  thumbnail {
    small
  }
  rawUrl
  aspectRatio
  uploadedBy {
    id
    name
  }
  appearances {
    id
    person {
      name
    }
  }
  createdAt
}
    `;
export const PersonGridImageFragmentDoc = `
    fragment PersonGridImage on Person {
  id
  name
  preferredAlias {
    name
  }
  avatar {
    thumbnail {
      medium
    }
  }
}
    `;
export const FaceDataFragmentDoc = `
    fragment FaceData on Face {
  id
  x
  y
  width
  height
  score
}
    `;
export const AppearanceWithFacesFragmentDoc = `
    fragment AppearanceWithFaces on Appearance {
  id
  faces {
    ...FaceData
  }
  person {
    preferredAlias {
      name
    }
    name
  }
  tags {
    tag {
      name
    }
  }
}
    ${FaceDataFragmentDoc}`;
export const UserDataFragmentDoc = `
    fragment UserData on User {
  id
  name
  avatar: image
  bot
}
    `;
export const UserRoleDataFragmentDoc = `
    fragment UserRoleData on Role {
  name
}
    `;
export const BrowsePageIdolsWithFilterDocument = `
    query BrowsePageIdolsWithFilter($skip: Int!, $take: Int!, $groups: [Int!]!) {
  people(
    skip: $skip
    take: $take
    orderBy: [{updatedAt: asc}]
    where: {memberOf: {some: {group: {id: {in: $groups}}}}}
  ) {
    ...PersonGridData
  }
}
    ${PersonGridDataFragmentDoc}`;
export const useBrowsePageIdolsWithFilterQuery = <
      TData = BrowsePageIdolsWithFilterQuery,
      TError = unknown
    >(
      variables: BrowsePageIdolsWithFilterQueryVariables, 
      options?: UseQueryOptions<BrowsePageIdolsWithFilterQuery, TError, TData>
    ) => 
    useQuery<BrowsePageIdolsWithFilterQuery, TError, TData>(
      ['BrowsePageIdolsWithFilter', variables],
      fetcher<BrowsePageIdolsWithFilterQuery, BrowsePageIdolsWithFilterQueryVariables>(BrowsePageIdolsWithFilterDocument, variables),
      options
    );
export const BrowsePageIdolsDocument = `
    query BrowsePageIdols($skip: Int!, $take: Int!) {
  people(skip: $skip, take: $take, orderBy: [{updatedAt: asc}]) {
    ...PersonGridData
  }
}
    ${PersonGridDataFragmentDoc}`;
export const useBrowsePageIdolsQuery = <
      TData = BrowsePageIdolsQuery,
      TError = unknown
    >(
      variables: BrowsePageIdolsQueryVariables, 
      options?: UseQueryOptions<BrowsePageIdolsQuery, TError, TData>
    ) => 
    useQuery<BrowsePageIdolsQuery, TError, TData>(
      ['BrowsePageIdols', variables],
      fetcher<BrowsePageIdolsQuery, BrowsePageIdolsQueryVariables>(BrowsePageIdolsDocument, variables),
      options
    );
export const BrowsePageDocument = `
    query BrowsePage($take: Int!, $skip: Int) {
  images(orderBy: [{createdAt: desc}], take: $take, skip: $skip) {
    ...GridImage
  }
}
    ${GridImageFragmentDoc}`;
export const useBrowsePageQuery = <
      TData = BrowsePageQuery,
      TError = unknown
    >(
      variables: BrowsePageQueryVariables, 
      options?: UseQueryOptions<BrowsePageQuery, TError, TData>
    ) => 
    useQuery<BrowsePageQuery, TError, TData>(
      ['BrowsePage', variables],
      fetcher<BrowsePageQuery, BrowsePageQueryVariables>(BrowsePageDocument, variables),
      options
    );
export const AddAppearanceTagDocument = `
    mutation AddAppearanceTag($name: String!, $appearanceId: Int!) {
  createAppearanceTag(name: $name, appearanceId: $appearanceId) {
    tag {
      name
    }
  }
}
    `;
export const useAddAppearanceTagMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<AddAppearanceTagMutation, TError, AddAppearanceTagMutationVariables, TContext>) => 
    useMutation<AddAppearanceTagMutation, TError, AddAppearanceTagMutationVariables, TContext>(
      (variables?: AddAppearanceTagMutationVariables) => fetcher<AddAppearanceTagMutation, AddAppearanceTagMutationVariables>(AddAppearanceTagDocument, variables)(),
      options
    );
export const DeleteAppearanceTagDocument = `
    mutation DeleteAppearanceTag($name: String!, $appearanceId: Int!) {
  deleteAppearanceTag(name: $name, appearanceId: $appearanceId) {
    tag {
      name
    }
  }
}
    `;
export const useDeleteAppearanceTagMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<DeleteAppearanceTagMutation, TError, DeleteAppearanceTagMutationVariables, TContext>) => 
    useMutation<DeleteAppearanceTagMutation, TError, DeleteAppearanceTagMutationVariables, TContext>(
      (variables?: DeleteAppearanceTagMutationVariables) => fetcher<DeleteAppearanceTagMutation, DeleteAppearanceTagMutationVariables>(DeleteAppearanceTagDocument, variables)(),
      options
    );
export const PersonEditDataDocument = `
    query PersonEditData($id: Int!) {
  person(where: {id: $id}) {
    birthDate
    memberOf {
      group {
        id
        name
      }
    }
    preferredMembership {
      group {
        id
        name
      }
    }
    aliases {
      name
    }
    preferredAlias {
      name
    }
    banner {
      id
      rawUrl
      thumbnail {
        medium
      }
    }
    avatar {
      id
      rawUrl
      thumbnail {
        medium
      }
    }
  }
}
    `;
export const usePersonEditDataQuery = <
      TData = PersonEditDataQuery,
      TError = unknown
    >(
      variables: PersonEditDataQueryVariables, 
      options?: UseQueryOptions<PersonEditDataQuery, TError, TData>
    ) => 
    useQuery<PersonEditDataQuery, TError, TData>(
      ['PersonEditData', variables],
      fetcher<PersonEditDataQuery, PersonEditDataQueryVariables>(PersonEditDataDocument, variables),
      options
    );
export const PersonEditDocument = `
    mutation PersonEdit($id: Int!, $input: UpdatePersonInputs!) {
  updatePerson(id: $id, update: $input) {
    id
    name
    birthDate
    appearances {
      id
      image {
        ...GridImage
      }
    }
    memberOf {
      ...OnePersonRelationshipMembership
    }
    preferredMembership {
      ...OnePersonRelationshipMembership
    }
    aliases {
      id
      name
    }
    avatar {
      ...Focus
      ...OnePersonRelationshipImage
    }
    preferredAlias {
      id
      name
    }
    banner {
      id
      ...Focus
      rawUrl
    }
  }
}
    ${GridImageFragmentDoc}
${OnePersonRelationshipMembershipFragmentDoc}
${FocusFragmentDoc}
${OnePersonRelationshipImageFragmentDoc}`;
export const usePersonEditMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<PersonEditMutation, TError, PersonEditMutationVariables, TContext>) => 
    useMutation<PersonEditMutation, TError, PersonEditMutationVariables, TContext>(
      (variables?: PersonEditMutationVariables) => fetcher<PersonEditMutation, PersonEditMutationVariables>(PersonEditDocument, variables)(),
      options
    );
export const AddProviderDocument = `
    mutation AddProvider($provider: AddProviderInput!) {
  addProvider(provider: $provider)
}
    `;
export const useAddProviderMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<AddProviderMutation, TError, AddProviderMutationVariables, TContext>) => 
    useMutation<AddProviderMutation, TError, AddProviderMutationVariables, TContext>(
      (variables?: AddProviderMutationVariables) => fetcher<AddProviderMutation, AddProviderMutationVariables>(AddProviderDocument, variables)(),
      options
    );
export const DiscoveryProvidersDocument = `
    query DiscoveryProviders {
  discoveryProviders {
    name
    destination
    defaultName
    enabled
    lastScrape
    scrapeCount
    lastPost
    discoveredImages
    official
    url
    createdAt
  }
}
    `;
export const useDiscoveryProvidersQuery = <
      TData = DiscoveryProvidersQuery,
      TError = unknown
    >(
      variables?: DiscoveryProvidersQueryVariables, 
      options?: UseQueryOptions<DiscoveryProvidersQuery, TError, TData>
    ) => 
    useQuery<DiscoveryProvidersQuery, TError, TData>(
      ['DiscoveryProviders', variables],
      fetcher<DiscoveryProvidersQuery, DiscoveryProvidersQueryVariables>(DiscoveryProvidersDocument, variables),
      options
    );
export const DiscoveryLeaderboardDocument = `
    query DiscoveryLeaderboard {
  discoveryLeaderboard {
    rank
    xp
    user {
      id
      image
      name
      bot
    }
  }
}
    `;
export const useDiscoveryLeaderboardQuery = <
      TData = DiscoveryLeaderboardQuery,
      TError = unknown
    >(
      variables?: DiscoveryLeaderboardQueryVariables, 
      options?: UseQueryOptions<DiscoveryLeaderboardQuery, TError, TData>
    ) => 
    useQuery<DiscoveryLeaderboardQuery, TError, TData>(
      ['DiscoveryLeaderboard', variables],
      fetcher<DiscoveryLeaderboardQuery, DiscoveryLeaderboardQueryVariables>(DiscoveryLeaderboardDocument, variables),
      options
    );
export const DiscoveryHistoryDocument = `
    query DiscoveryHistory($take: Int!, $skip: Int! = 0) {
  discoveryHistory(take: $take, skip: $skip) {
    ...DiscoveryPostListable
  }
}
    ${DiscoveryPostListableFragmentDoc}`;
export const useDiscoveryHistoryQuery = <
      TData = DiscoveryHistoryQuery,
      TError = unknown
    >(
      variables: DiscoveryHistoryQueryVariables, 
      options?: UseQueryOptions<DiscoveryHistoryQuery, TError, TData>
    ) => 
    useQuery<DiscoveryHistoryQuery, TError, TData>(
      ['DiscoveryHistory', variables],
      fetcher<DiscoveryHistoryQuery, DiscoveryHistoryQueryVariables>(DiscoveryHistoryDocument, variables),
      options
    );
export const OnePersonDocument = `
    query OnePerson($id: Int!) {
  person(where: {id: $id}) {
    id
    name
    birthDate
    appearances(take: 20) {
      id
      image {
        ...GridImage
      }
    }
    memberOf {
      ...OnePersonRelationshipMembership
    }
    preferredMembership {
      ...OnePersonRelationshipMembership
    }
    aliases {
      id
      name
    }
    avatar {
      ...Focus
      ...OnePersonRelationshipImage
    }
    preferredAlias {
      id
      name
    }
    banner {
      id
      ...Focus
      rawUrl
    }
  }
}
    ${GridImageFragmentDoc}
${OnePersonRelationshipMembershipFragmentDoc}
${FocusFragmentDoc}
${OnePersonRelationshipImageFragmentDoc}`;
export const useOnePersonQuery = <
      TData = OnePersonQuery,
      TError = unknown
    >(
      variables: OnePersonQueryVariables, 
      options?: UseQueryOptions<OnePersonQuery, TError, TData>
    ) => 
    useQuery<OnePersonQuery, TError, TData>(
      ['OnePerson', variables],
      fetcher<OnePersonQuery, OnePersonQueryVariables>(OnePersonDocument, variables),
      options
    );
export const AddToQueueDocument = `
    mutation addToQueue($slug: String!) {
  scanFaces(slug: $slug) {
    queueSize
  }
}
    `;
export const useAddToQueueMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<AddToQueueMutation, TError, AddToQueueMutationVariables, TContext>) => 
    useMutation<AddToQueueMutation, TError, AddToQueueMutationVariables, TContext>(
      (variables?: AddToQueueMutationVariables) => fetcher<AddToQueueMutation, AddToQueueMutationVariables>(AddToQueueDocument, variables)(),
      options
    );
export const UserDataDocument = `
    query UserData {
  me {
    id
    name
    image
    xp
    createdAt
    roles {
      name
    }
  }
}
    `;
export const useUserDataQuery = <
      TData = UserDataQuery,
      TError = unknown
    >(
      variables?: UserDataQueryVariables, 
      options?: UseQueryOptions<UserDataQuery, TError, TData>
    ) => 
    useQuery<UserDataQuery, TError, TData>(
      ['UserData', variables],
      fetcher<UserDataQuery, UserDataQueryVariables>(UserDataDocument, variables),
      options
    );
export const OneImageDocument = `
    query OneImage($slug: String!) {
  image(slug: $slug) {
    unknownFaces {
      ...FaceData
      appearance {
        ...AppearanceData
      }
    }
    appearances {
      id
      person {
        id
        name
        preferredAlias {
          name
        }
      }
      tags {
        tag {
          name
        }
      }
      faces {
        ...FaceData
      }
    }
    liked
    uploadedBy {
      ...UserData
      roles {
        ...UserRoleData
      }
    }
    ...ImageData
    faceScanDate
    public
  }
}
    ${FaceDataFragmentDoc}
${AppearanceDataFragmentDoc}
${UserDataFragmentDoc}
${UserRoleDataFragmentDoc}
${ImageDataFragmentDoc}`;
export const useOneImageQuery = <
      TData = OneImageQuery,
      TError = unknown
    >(
      variables: OneImageQueryVariables, 
      options?: UseQueryOptions<OneImageQuery, TError, TData>
    ) => 
    useQuery<OneImageQuery, TError, TData>(
      ['OneImage', variables],
      fetcher<OneImageQuery, OneImageQueryVariables>(OneImageDocument, variables),
      options
    );
export const PersonPageDocument = `
    query personPage($id: Int!) {
  person(where: {id: $id}) {
    name
    birthDate
    aliases {
      id
      name
    }
    preferredAlias {
      name
    }
    appearances {
      image {
        ...ImageData
        thumbnail {
          medium
        }
      }
      createdAt
    }
  }
}
    ${ImageDataFragmentDoc}`;
export const usePersonPageQuery = <
      TData = PersonPageQuery,
      TError = unknown
    >(
      variables: PersonPageQueryVariables, 
      options?: UseQueryOptions<PersonPageQuery, TError, TData>
    ) => 
    useQuery<PersonPageQuery, TError, TData>(
      ['personPage', variables],
      fetcher<PersonPageQuery, PersonPageQueryVariables>(PersonPageDocument, variables),
      options
    );
export const ConnectionGraphDocument = `
    query connectionGraph($slug: String!) {
  imageConnections(depth: 2, slug: $slug) {
    edges {
      type
      to
      from
    }
    people {
      id
      name
    }
    images {
      slug
      id
      rawUrl
    }
  }
}
    `;
export const useConnectionGraphQuery = <
      TData = ConnectionGraphQuery,
      TError = unknown
    >(
      variables: ConnectionGraphQueryVariables, 
      options?: UseQueryOptions<ConnectionGraphQuery, TError, TData>
    ) => 
    useQuery<ConnectionGraphQuery, TError, TData>(
      ['connectionGraph', variables],
      fetcher<ConnectionGraphQuery, ConnectionGraphQueryVariables>(ConnectionGraphDocument, variables),
      options
    );
export const DiscoveryScheduleDocument = `
    query DiscoverySchedule {
  discoverySchedule {
    destination
    name
    waitDays
    url
    provider
    official
  }
}
    `;
export const useDiscoveryScheduleQuery = <
      TData = DiscoveryScheduleQuery,
      TError = unknown
    >(
      variables?: DiscoveryScheduleQueryVariables, 
      options?: UseQueryOptions<DiscoveryScheduleQuery, TError, TData>
    ) => 
    useQuery<DiscoveryScheduleQuery, TError, TData>(
      ['DiscoverySchedule', variables],
      fetcher<DiscoveryScheduleQuery, DiscoveryScheduleQueryVariables>(DiscoveryScheduleDocument, variables),
      options
    );
export const DiscoveryStatsDocument = `
    query DiscoveryStats {
  discoveryStats {
    count
    verdict
  }
}
    `;
export const useDiscoveryStatsQuery = <
      TData = DiscoveryStatsQuery,
      TError = unknown
    >(
      variables?: DiscoveryStatsQueryVariables, 
      options?: UseQueryOptions<DiscoveryStatsQuery, TError, TData>
    ) => 
    useQuery<DiscoveryStatsQuery, TError, TData>(
      ['DiscoveryStats', variables],
      fetcher<DiscoveryStatsQuery, DiscoveryStatsQueryVariables>(DiscoveryStatsDocument, variables),
      options
    );
export const DiscoveredPostsDocument = `
    query DiscoveredPosts($skip: Int!, $take: Int!, $groupIds: [Int!]! = [], $peopleIds: [Int!]! = []) {
  discoveryFeed(
    skip: $skip
    take: $take
    groupIds: $groupIds
    peopleIds: $peopleIds
  ) {
    ...DiscoveryPostListable
  }
}
    ${DiscoveryPostListableFragmentDoc}`;
export const useDiscoveredPostsQuery = <
      TData = DiscoveredPostsQuery,
      TError = unknown
    >(
      variables: DiscoveredPostsQueryVariables, 
      options?: UseQueryOptions<DiscoveredPostsQuery, TError, TData>
    ) => 
    useQuery<DiscoveredPostsQuery, TError, TData>(
      ['DiscoveredPosts', variables],
      fetcher<DiscoveredPostsQuery, DiscoveredPostsQueryVariables>(DiscoveredPostsDocument, variables),
      options
    );
export const VoteDiscoveryImageDocument = `
    mutation VoteDiscoveryImage($imageId: Int!, $verdict: String!, $reason: String) {
  discoveredImageVote(imageId: $imageId, verdict: $verdict, reason: $reason) {
    id
  }
}
    `;
export const useVoteDiscoveryImageMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<VoteDiscoveryImageMutation, TError, VoteDiscoveryImageMutationVariables, TContext>) => 
    useMutation<VoteDiscoveryImageMutation, TError, VoteDiscoveryImageMutationVariables, TContext>(
      (variables?: VoteDiscoveryImageMutationVariables) => fetcher<VoteDiscoveryImageMutation, VoteDiscoveryImageMutationVariables>(VoteDiscoveryImageDocument, variables)(),
      options
    );
export const VoteDiscoveryPostDocument = `
    mutation VoteDiscoveryPost($postId: Int!, $verdict: String!, $reason: String) {
  discoveredPostVote(postId: $postId, verdict: $verdict, reason: $reason) {
    id
    vote {
      reason
      verdict
    }
  }
}
    `;
export const useVoteDiscoveryPostMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<VoteDiscoveryPostMutation, TError, VoteDiscoveryPostMutationVariables, TContext>) => 
    useMutation<VoteDiscoveryPostMutation, TError, VoteDiscoveryPostMutationVariables, TContext>(
      (variables?: VoteDiscoveryPostMutationVariables) => fetcher<VoteDiscoveryPostMutation, VoteDiscoveryPostMutationVariables>(VoteDiscoveryPostDocument, variables)(),
      options
    );
export const HomepagePersonDocument = `
    query HomepagePerson($take: Int!, $skip: Int!, $id: Int!) {
  images(
    where: {appearances: {some: {person: {id: {equals: $id}}}}}
    take: $take
    skip: $skip
    orderBy: {createdAt: desc}
  ) {
    ...GridImage
  }
}
    ${GridImageFragmentDoc}`;
export const useHomepagePersonQuery = <
      TData = HomepagePersonQuery,
      TError = unknown
    >(
      variables: HomepagePersonQueryVariables, 
      options?: UseQueryOptions<HomepagePersonQuery, TError, TData>
    ) => 
    useQuery<HomepagePersonQuery, TError, TData>(
      ['HomepagePerson', variables],
      fetcher<HomepagePersonQuery, HomepagePersonQueryVariables>(HomepagePersonDocument, variables),
      options
    );
export const HomepageDocument = `
    query Homepage {
  homepage {
    id
    name
    preferredAlias {
      name
    }
    preferredMembership {
      group {
        name
      }
    }
    avatar {
      url
      createdAt
      thumbnail {
        small
      }
    }
    banner {
      url
      rawUrl
      width
      height
      focus {
        x
        y
      }
    }
  }
}
    `;
export const useHomepageQuery = <
      TData = HomepageQuery,
      TError = unknown
    >(
      variables?: HomepageQueryVariables, 
      options?: UseQueryOptions<HomepageQuery, TError, TData>
    ) => 
    useQuery<HomepageQuery, TError, TData>(
      ['Homepage', variables],
      fetcher<HomepageQuery, HomepageQueryVariables>(HomepageDocument, variables),
      options
    );
export const AddAppearanceDocument = `
    mutation AddAppearance($imageId: Int!, $personId: Int!) {
  appearance: addAppearance(imageId: $imageId, personId: $personId) {
    ...AppearanceWithFaces
  }
}
    ${AppearanceWithFacesFragmentDoc}`;
export const useAddAppearanceMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<AddAppearanceMutation, TError, AddAppearanceMutationVariables, TContext>) => 
    useMutation<AddAppearanceMutation, TError, AddAppearanceMutationVariables, TContext>(
      (variables?: AddAppearanceMutationVariables) => fetcher<AddAppearanceMutation, AddAppearanceMutationVariables>(AddAppearanceDocument, variables)(),
      options
    );
export const RemoveAppearanceDocument = `
    mutation RemoveAppearance($appearanceId: Int!) {
  appearance: removeAppearance(appearanceId: $appearanceId) {
    id
  }
}
    `;
export const useRemoveAppearanceMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<RemoveAppearanceMutation, TError, RemoveAppearanceMutationVariables, TContext>) => 
    useMutation<RemoveAppearanceMutation, TError, RemoveAppearanceMutationVariables, TContext>(
      (variables?: RemoveAppearanceMutationVariables) => fetcher<RemoveAppearanceMutation, RemoveAppearanceMutationVariables>(RemoveAppearanceDocument, variables)(),
      options
    );
export const LinkFaceDocument = `
    mutation LinkFace($appearanceId: Int!, $faceId: Int!) {
  appearance: linkFace(faceId: $faceId, appearanceId: $appearanceId) {
    ...AppearanceWithFaces
  }
}
    ${AppearanceWithFacesFragmentDoc}`;
export const useLinkFaceMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<LinkFaceMutation, TError, LinkFaceMutationVariables, TContext>) => 
    useMutation<LinkFaceMutation, TError, LinkFaceMutationVariables, TContext>(
      (variables?: LinkFaceMutationVariables) => fetcher<LinkFaceMutation, LinkFaceMutationVariables>(LinkFaceDocument, variables)(),
      options
    );
export const UnlinkFaceDocument = `
    mutation UnlinkFace($appearanceId: Int!, $faceId: Int!) {
  unlinkFace(faceId: $faceId, appearanceId: $appearanceId)
}
    `;
export const useUnlinkFaceMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<UnlinkFaceMutation, TError, UnlinkFaceMutationVariables, TContext>) => 
    useMutation<UnlinkFaceMutation, TError, UnlinkFaceMutationVariables, TContext>(
      (variables?: UnlinkFaceMutationVariables) => fetcher<UnlinkFaceMutation, UnlinkFaceMutationVariables>(UnlinkFaceDocument, variables)(),
      options
    );
export const GetUploadResultDocument = `
    query getUploadResult($slug: String!) {
  image(slug: $slug) {
    appearances {
      id
      person {
        id
        name
      }
      faces {
        ...FaceData
      }
    }
    ...ImageData
  }
}
    ${FaceDataFragmentDoc}
${ImageDataFragmentDoc}`;
export const useGetUploadResultQuery = <
      TData = GetUploadResultQuery,
      TError = unknown
    >(
      variables: GetUploadResultQueryVariables, 
      options?: UseQueryOptions<GetUploadResultQuery, TError, TData>
    ) => 
    useQuery<GetUploadResultQuery, TError, TData>(
      ['getUploadResult', variables],
      fetcher<GetUploadResultQuery, GetUploadResultQueryVariables>(GetUploadResultDocument, variables),
      options
    );
export const MeDocument = `
    query Me {
  me {
    ...UserData
    images(orderBy: {createdAt: asc}) {
      ...GridImage
    }
    roles {
      ...UserRoleData
    }
  }
}
    ${UserDataFragmentDoc}
${GridImageFragmentDoc}
${UserRoleDataFragmentDoc}`;
export const useMeQuery = <
      TData = MeQuery,
      TError = unknown
    >(
      variables?: MeQueryVariables, 
      options?: UseQueryOptions<MeQuery, TError, TData>
    ) => 
    useQuery<MeQuery, TError, TData>(
      ['Me', variables],
      fetcher<MeQuery, MeQueryVariables>(MeDocument, variables),
      options
    );
export const ToggleLikeDocument = `
    mutation toggleLike($id: Int!) {
  toggleLike(imageId: $id) {
    ...ImageData
    liked
  }
}
    ${ImageDataFragmentDoc}`;
export const useToggleLikeMutation = <
      TError = unknown,
      TContext = unknown
    >(options?: UseMutationOptions<ToggleLikeMutation, TError, ToggleLikeMutationVariables, TContext>) => 
    useMutation<ToggleLikeMutation, TError, ToggleLikeMutationVariables, TContext>(
      (variables?: ToggleLikeMutationVariables) => fetcher<ToggleLikeMutation, ToggleLikeMutationVariables>(ToggleLikeDocument, variables)(),
      options
    );
export { fetcher }