### This file was generated by Nexus Schema
### Do not make changes to this file directly


type Alias {
  createdAt: DateTime!
  id: Int!
  name: String!
  updatedAt: DateTime!
}

input AliasListRelationFilter {
  every: AliasWhereInput
  none: AliasWhereInput
  some: AliasWhereInput
}

input AliasPersonAliasCompoundUniqueInput {
  name: String!
  personId: Int!
}

input AliasWhereInput {
  AND: [AliasWhereInput!]
  NOT: [AliasWhereInput!]
  OR: [AliasWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  name: StringFilter
  person: PersonWhereInput
  personId: IntFilter
  preferredAliasOf: PersonWhereInput
  updatedAt: DateTimeFilter
}

input AliasWhereUniqueInput {
  id: Int
  personAlias: AliasPersonAliasCompoundUniqueInput
}

type Appearance {
  addedBy: User!
  createdAt: DateTime!
  faces(cursor: FaceWhereUniqueInput, skip: Int, take: Int): [Face!]!
  id: Int!
  image: Image!
  person: Person!
  updatedAt: DateTime!
}

input AppearanceAppearanceCompoundUniqueInput {
  imageId: Int!
  personId: Int!
}

type AppearanceCount {
  count: Int!
  group: Group!
}

input AppearanceListRelationFilter {
  every: AppearanceWhereInput
  none: AppearanceWhereInput
  some: AppearanceWhereInput
}

input AppearanceWhereInput {
  AND: [AppearanceWhereInput!]
  NOT: [AppearanceWhereInput!]
  OR: [AppearanceWhereInput!]
  addedBy: UserWhereInput
  addedById: IntFilter
  createdAt: DateTimeFilter
  faces: FaceListRelationFilter
  id: IntFilter
  image: ImageWhereInput
  imageId: IntFilter
  person: PersonWhereInput
  personId: IntFilter
  updatedAt: DateTimeFilter
}

input AppearanceWhereUniqueInput {
  appearance: AppearanceAppearanceCompoundUniqueInput
  id: Int
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

scalar DateTime

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input EnumFaceSourceFilter {
  equals: FaceSource
  in: [FaceSource!]
  not: NestedEnumFaceSourceFilter
  notIn: [FaceSource!]
}

input EnumMimeTypeFilter {
  equals: MimeType
  in: [MimeType!]
  not: NestedEnumMimeTypeFilter
  notIn: [MimeType!]
}

input EnumTagSourceFilter {
  equals: TagSource
  in: [TagSource!]
  not: NestedEnumTagSourceFilter
  notIn: [TagSource!]
}

input EnumUploadTypeFilter {
  equals: UploadType
  in: [UploadType!]
  not: NestedEnumUploadTypeFilter
  notIn: [UploadType!]
}

type Face {
  addedBy: User
  appearance: Appearance
  createdAt: DateTime!
  height: Float!
  id: Int!
  image: Image!
  score: Float!
  source: FaceSource!
  updatedAt: DateTime!
  width: Float!
  x: Float!
  y: Float!
}

input FaceListRelationFilter {
  every: FaceWhereInput
  none: FaceWhereInput
  some: FaceWhereInput
}

enum FaceSource {
  Manual
  Scan
}

input FaceWhereInput {
  AND: [FaceWhereInput!]
  NOT: [FaceWhereInput!]
  OR: [FaceWhereInput!]
  addedBy: UserWhereInput
  addedById: IntNullableFilter
  appearance: AppearanceWhereInput
  appearanceId: IntNullableFilter
  createdAt: DateTimeFilter
  height: FloatFilter
  id: IntFilter
  image: ImageWhereInput
  imageId: IntFilter
  person: PersonWhereInput
  personId: IntNullableFilter
  score: FloatFilter
  source: EnumFaceSourceFilter
  updatedAt: DateTimeFilter
  width: FloatFilter
  x: FloatFilter
  y: FloatFilter
}

input FaceWhereUniqueInput {
  id: Int
}

input FloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

type Group {
  aliases(cursor: GroupAliasWhereUniqueInput, skip: Int, take: Int): [GroupAlias!]!
  avatar: Image
  banner: Image
  createdAt: DateTime!
  id: Int!
  members(cursor: GroupMemberWhereUniqueInput, skip: Int, take: Int): [GroupMember!]!
  name: String!
  updatedAt: DateTime!
}

type GroupAlias {
  createdAt: DateTime!
  id: Int!
  name: String!
  updatedAt: DateTime!
}

input GroupAliasListRelationFilter {
  every: GroupAliasWhereInput
  none: GroupAliasWhereInput
  some: GroupAliasWhereInput
}

input GroupAliasWhereInput {
  AND: [GroupAliasWhereInput!]
  NOT: [GroupAliasWhereInput!]
  OR: [GroupAliasWhereInput!]
  createdAt: DateTimeFilter
  group: GroupWhereInput
  groupId: IntFilter
  id: IntFilter
  name: StringFilter
  updatedAt: DateTimeFilter
}

input GroupAliasWhereUniqueInput {
  id: Int
}

type GroupMember {
  createdAt: DateTime!
  endDate: DateTime
  group: Group!
  id: Int!
  person: Person!
  startDate: DateTime
  updatedAt: DateTime!
}

input GroupMemberListRelationFilter {
  every: GroupMemberWhereInput
  none: GroupMemberWhereInput
  some: GroupMemberWhereInput
}

input GroupMemberMemberCompoundUniqueInput {
  groupId: Int!
  personId: Int!
}

input GroupMemberWhereInput {
  AND: [GroupMemberWhereInput!]
  NOT: [GroupMemberWhereInput!]
  OR: [GroupMemberWhereInput!]
  createdAt: DateTimeFilter
  endDate: DateTimeNullableFilter
  group: GroupWhereInput
  groupId: IntFilter
  id: IntFilter
  person: PersonWhereInput
  personId: IntFilter
  preferredMemberships_: PersonListRelationFilter
  startDate: DateTimeNullableFilter
  updatedAt: DateTimeFilter
}

input GroupMemberWhereUniqueInput {
  id: Int
  member: GroupMemberMemberCompoundUniqueInput
}

input GroupOrderByInput {
  avatarId: SortOrder
  bannerId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  ireneBotId: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input GroupWhereInput {
  AND: [GroupWhereInput!]
  NOT: [GroupWhereInput!]
  OR: [GroupWhereInput!]
  aliases: GroupAliasListRelationFilter
  avatar: ImageWhereInput
  avatarId: IntNullableFilter
  banner: ImageWhereInput
  bannerId: IntNullableFilter
  createdAt: DateTimeFilter
  id: IntFilter
  ireneBotId: IntNullableFilter
  members: GroupMemberListRelationFilter
  name: StringFilter
  updatedAt: DateTimeFilter
}

input GroupWhereUniqueInput {
  id: Int
  ireneBotId: Int
}

type Image {
  appearances(cursor: AppearanceWhereUniqueInput, skip: Int, take: Int): [Appearance!]!

  """The aspect ratio of the image"""
  aspectRatio: Float!
  bytes: Int!
  caption: String

  """
  A graph of connections people in this image share with others based on images they appear together in up to a depth of 4
  """
  connections(depth: Int! = 2): ImageConnections!
  createdAt: DateTime!
  faceScanDate: DateTime

  """The name the image file was uploaded with."""
  fileName: String

  """Human readable file size. Use `bytes` for a number representation."""
  fileSize: String!

  """SHA256 checksum of the image."""
  hash: String!

  """Height of the image in pixels."""
  height: Int!
  id: Int!

  """( ͡° ͜ʖ ͡°)"""
  isNsfw: Boolean!

  """False if not logged in"""
  liked: Boolean

  """The IANA media type of the image."""
  mimetype: MimeType!

  """
  Block hash of the image, useful for doing reverse search using hamming distance.
  """
  pHash: String

  """Dominant colors in the image in decimal format, sorted by frequency."""
  palette: [Int!]!

  """The visibility status of the image."""
  public: Boolean!

  """Direct link to the image on the CDN"""
  rawUrl: String!

  """The unique url identifier of the image."""
  slug: String!

  """
  The url the image was taken from (if applicable). Not guaranteed to be a direct image url.
  """
  source: String
  tags(cursor: TagWhereUniqueInput, skip: Int, take: Int): [Tag!]!
  thumbnail: Thumbnail!
  unknownFaces: [Face!]!
  uploadType: UploadType!
  uploadedBy: User

  """Link to the image on the site"""
  url: String!
  views: Int!

  """Width of the image in pixels."""
  width: Int!
}

enum ImageConnectionEdge {
  IMAGE_TO_PERSON
  PERSON_TO_IMAGE
}

type ImageConnections {
  edges: [ImageEdge!]!
  images: [Image!]!
  people: [Person!]!
}

type ImageEdge {
  from: Int!
  to: Int!
  type: ImageConnectionEdge
}

input ImageLikeListRelationFilter {
  every: ImageLikeWhereInput
  none: ImageLikeWhereInput
  some: ImageLikeWhereInput
}

input ImageLikeWhereInput {
  AND: [ImageLikeWhereInput!]
  NOT: [ImageLikeWhereInput!]
  OR: [ImageLikeWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  image: ImageWhereInput
  imageId: IntFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: IntFilter
}

input ImageListRelationFilter {
  every: ImageWhereInput
  none: ImageWhereInput
  some: ImageWhereInput
}

input ImageOrderByInput {
  bytes: SortOrder
  caption: SortOrder
  createdAt: SortOrder
  faceScanDate: SortOrder
  faceScanRequestDate: SortOrder
  fileName: SortOrder
  hash: SortOrder
  height: SortOrder
  id: SortOrder
  ireneBotId: SortOrder
  isNsfw: SortOrder
  mimetype: SortOrder
  pHash: SortOrder
  palette: SortOrder
  public: SortOrder
  slug: SortOrder
  source: SortOrder
  updatedAt: SortOrder
  uploadType: SortOrder
  userId: SortOrder
  views: SortOrder
  width: SortOrder
}

input ImageWhereInput {
  AND: [ImageWhereInput!]
  NOT: [ImageWhereInput!]
  OR: [ImageWhereInput!]
  appearances: AppearanceListRelationFilter
  avatarOf: GroupWhereInput
  bannerOf: GroupWhereInput
  bytes: IntFilter
  caption: StringNullableFilter
  createdAt: DateTimeFilter
  faceScanDate: DateTimeNullableFilter
  faceScanRequestDate: DateTimeNullableFilter
  faces: FaceListRelationFilter
  fileName: StringNullableFilter
  hash: StringFilter
  height: IntFilter
  id: IntFilter
  ireneBotId: IntNullableFilter
  isNsfw: BoolFilter
  likes: ImageLikeListRelationFilter
  mimetype: EnumMimeTypeFilter
  pHash: StringNullableFilter
  palette: IntNullableListFilter
  public: BoolFilter
  slug: StringFilter
  source: StringNullableFilter
  tags: TagListRelationFilter
  updatedAt: DateTimeFilter
  uploadType: EnumUploadTypeFilter
  user: UserWhereInput
  userId: IntNullableFilter
  views: IntFilter
  width: IntFilter
}

input ImageWhereUniqueInput {
  id: Int
  ireneBotId: Int
  slug: String
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input IntNullableListFilter {
  equals: [Int!]
  has: Int
  hasEvery: [Int!]
  hasSome: [Int!]
  isEmpty: Boolean
}

enum MimeType {
  AVIF
  GIF
  JPG
  MP4
  PNG
  SVG
  WEBM
  WEBP
}

type Mutation {
  """Add an appearance relation on an image."""
  addAppearance(imageId: Int!, personId: Int!): Appearance!

  """Attach an existing face to an apperance."""
  linkFace(appearanceId: Int!, faceId: Int!): Appearance!

  """Removes an appearance from an image"""
  removeAppearance(appearanceId: Int!): Appearance!

  """Queue an image to get scanned for faces"""
  scanFaces(slug: String!): QueueInfo!
  toggleLike(imageId: Int!): Image!

  """
  Unlinks an existing face from an appearance. This dissociates the face from the appearance but does not remove the face data
  """
  unlinkFace(appearanceId: Int!, faceId: Int!): Int!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input NestedEnumFaceSourceFilter {
  equals: FaceSource
  in: [FaceSource!]
  not: NestedEnumFaceSourceFilter
  notIn: [FaceSource!]
}

input NestedEnumMimeTypeFilter {
  equals: MimeType
  in: [MimeType!]
  not: NestedEnumMimeTypeFilter
  notIn: [MimeType!]
}

input NestedEnumTagSourceFilter {
  equals: TagSource
  in: [TagSource!]
  not: NestedEnumTagSourceFilter
  notIn: [TagSource!]
}

input NestedEnumUploadTypeFilter {
  equals: UploadType
  in: [UploadType!]
  not: NestedEnumUploadTypeFilter
  notIn: [UploadType!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

type Person {
  aliases(cursor: AliasWhereUniqueInput, skip: Int, take: Int): [Alias!]!
  appearances(cursor: AppearanceWhereUniqueInput, skip: Int, take: Int): [Appearance!]!
  createdAt: DateTime!
  faces(cursor: FaceWhereUniqueInput, skip: Int, take: Int): [Face!]!
  id: Int!
  memberOf(cursor: GroupMemberWhereUniqueInput, skip: Int, take: Int): [GroupMember!]!
  name: String!
  preferredAlias: Alias
  preferredMembership: GroupMember
  updatedAt: DateTime!
}

input PersonListRelationFilter {
  every: PersonWhereInput
  none: PersonWhereInput
  some: PersonWhereInput
}

input PersonWhereInput {
  AND: [PersonWhereInput!]
  NOT: [PersonWhereInput!]
  OR: [PersonWhereInput!]
  aliases: AliasListRelationFilter
  appearances: AppearanceListRelationFilter
  appearsIn: FaceListRelationFilter
  createdAt: DateTimeFilter
  description: StringNullableFilter
  id: IntFilter
  ireneBotId: IntNullableFilter
  memberOf: GroupMemberListRelationFilter
  name: StringFilter
  preferredAlias: AliasWhereInput
  preferredAliasId: IntNullableFilter
  preferredMembership: GroupMemberWhereInput
  preferredMembershipId: IntNullableFilter
  updatedAt: DateTimeFilter
}

input PersonWhereUniqueInput {
  id: Int
  ireneBotId: Int
}

type Query {
  countAppearances(groups: [Int!]!): [AppearanceCount!]!
  group(where: GroupWhereUniqueInput!): Group
  groups(cursor: GroupWhereUniqueInput, orderBy: [GroupOrderByInput!], skip: Int, take: Int, where: GroupWhereInput): [Group!]!

  """Find a single image by its slug."""
  image(slug: String!): Image
  imageConnections(depth: Int! = 2, slug: String!): ImageConnections
  images(cursor: ImageWhereUniqueInput, orderBy: [ImageOrderByInput!], skip: Int, take: Int, where: ImageWhereInput): [Image!]!
  me: User
  people(cursor: PersonWhereUniqueInput, skip: Int, take: Int, where: PersonWhereInput): [Person!]!
  person(where: PersonWhereUniqueInput!): Person
  user(id: Int): User
}

enum QueryMode {
  default
  insensitive
}

type QueueInfo {
  queueSize: Int!
}

type Role {
  createdAt: DateTime!
  name: String!
}

input RoleListRelationFilter {
  every: RoleWhereInput
  none: RoleWhereInput
  some: RoleWhereInput
}

input RoleUserRoleCompoundUniqueInput {
  name: String!
  userId: Int!
}

input RoleWhereInput {
  AND: [RoleWhereInput!]
  NOT: [RoleWhereInput!]
  OR: [RoleWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  name: StringFilter
  updatedAt: DateTimeFilter
  user: UserWhereInput
  userId: IntFilter
}

input RoleWhereUniqueInput {
  id: Int
  userRole: RoleUserRoleCompoundUniqueInput
}

enum SortOrder {
  asc
  desc
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

type Tag {
  addedBy: User
  createdAt: DateTime!
  name: String!
  source: TagSource!
}

input TagListRelationFilter {
  every: TagWhereInput
  none: TagWhereInput
  some: TagWhereInput
}

enum TagSource {
  USER
}

input TagWhereInput {
  AND: [TagWhereInput!]
  NOT: [TagWhereInput!]
  OR: [TagWhereInput!]
  addedBy: UserWhereInput
  addedById: IntNullableFilter
  createdAt: DateTimeFilter
  id: IntFilter
  image: ImageWhereInput
  imageId: IntFilter
  name: StringFilter
  source: EnumTagSourceFilter
  updatedAt: DateTimeFilter
}

input TagWhereUniqueInput {
  id: Int
}

"""Preview urls of an image"""
type Thumbnail {
  large: String!
  medium: String!
  small: String!
}

enum UploadType {
  TOKEN
  WEBSITE
}

type User {
  avatar: String
  bot: Boolean!
  id: Int!
  images(cursor: ImageWhereUniqueInput, orderBy: [ImageOrderByInput!], skip: Int, take: Int, where: ImageWhereInput): [Image!]!
  name: String
  roles(cursor: RoleWhereUniqueInput, skip: Int, take: Int): [Role!]!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  bot: BoolFilter
  cratedTags: TagListRelationFilter
  createdAt: DateTimeFilter
  email: StringNullableFilter
  emailVerified: DateTimeNullableFilter
  id: IntFilter
  image: StringNullableFilter
  imageLikes: ImageLikeListRelationFilter
  images: ImageListRelationFilter
  markedFaces: FaceListRelationFilter
  name: StringNullableFilter
  roles: RoleListRelationFilter
  taggedAppearances: AppearanceListRelationFilter
  token: StringNullableFilter
  updatedAt: DateTimeFilter
}
