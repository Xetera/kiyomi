/* DO NOT EDIT! this file was generated by graphql-codegen */
/* eslint-disable */
import { GraphQLClient } from 'graphql-request';
import * as Dom from 'graphql-request/dist/types.dom';
import gql from 'graphql-tag';
export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  DateTime: any;
};

export type Alias = {
  __typename?: 'Alias';
  createdAt: Scalars['DateTime'];
  id: Scalars['Int'];
  name: Scalars['String'];
  updatedAt: Scalars['DateTime'];
};

export type AliasCreateManyPersonInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  name: Scalars['String'];
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AliasCreateManyPersonInputEnvelope = {
  data?: Maybe<Array<AliasCreateManyPersonInput>>;
  skipDuplicates?: Maybe<Scalars['Boolean']>;
};

export type AliasCreateNestedManyWithoutPersonInput = {
  connect?: Maybe<Array<AliasWhereUniqueInput>>;
  connectOrCreate?: Maybe<Array<AliasCreateOrConnectWithoutPersonInput>>;
  create?: Maybe<Array<AliasCreateWithoutPersonInput>>;
  createMany?: Maybe<AliasCreateManyPersonInputEnvelope>;
};

export type AliasCreateNestedOneWithoutPreferredAliasOfInput = {
  connect?: Maybe<AliasWhereUniqueInput>;
  connectOrCreate?: Maybe<AliasCreateOrConnectWithoutPreferredAliasOfInput>;
  create?: Maybe<AliasCreateWithoutPreferredAliasOfInput>;
};

export type AliasCreateOrConnectWithoutPersonInput = {
  create: AliasCreateWithoutPersonInput;
  where: AliasWhereUniqueInput;
};

export type AliasCreateOrConnectWithoutPreferredAliasOfInput = {
  create: AliasCreateWithoutPreferredAliasOfInput;
  where: AliasWhereUniqueInput;
};

export type AliasCreateWithoutPersonInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  preferredAliasOf?: Maybe<PersonCreateNestedOneWithoutPreferredAliasInput>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AliasCreateWithoutPreferredAliasOfInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  person: PersonCreateNestedOneWithoutAliasesInput;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AliasListRelationFilter = {
  every?: Maybe<AliasWhereInput>;
  none?: Maybe<AliasWhereInput>;
  some?: Maybe<AliasWhereInput>;
};

export type AliasPersonAliasCompoundUniqueInput = {
  name: Scalars['String'];
  personId: Scalars['Int'];
};

export type AliasScalarWhereInput = {
  AND?: Maybe<Array<AliasScalarWhereInput>>;
  NOT?: Maybe<Array<AliasScalarWhereInput>>;
  OR?: Maybe<Array<AliasScalarWhereInput>>;
  createdAt?: Maybe<DateTimeFilter>;
  id?: Maybe<IntFilter>;
  name?: Maybe<StringFilter>;
  personId?: Maybe<IntFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type AliasUpdateManyMutationInput = {
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  name?: Maybe<StringFieldUpdateOperationsInput>;
  updatedAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
};

export type AliasUpdateManyWithWhereWithoutPersonInput = {
  data: AliasUpdateManyMutationInput;
  where: AliasScalarWhereInput;
};

export type AliasUpdateManyWithoutPersonInput = {
  connect?: Maybe<Array<AliasWhereUniqueInput>>;
  connectOrCreate?: Maybe<Array<AliasCreateOrConnectWithoutPersonInput>>;
  create?: Maybe<Array<AliasCreateWithoutPersonInput>>;
  createMany?: Maybe<AliasCreateManyPersonInputEnvelope>;
  delete?: Maybe<Array<AliasWhereUniqueInput>>;
  deleteMany?: Maybe<Array<AliasScalarWhereInput>>;
  disconnect?: Maybe<Array<AliasWhereUniqueInput>>;
  set?: Maybe<Array<AliasWhereUniqueInput>>;
  update?: Maybe<Array<AliasUpdateWithWhereUniqueWithoutPersonInput>>;
  updateMany?: Maybe<Array<AliasUpdateManyWithWhereWithoutPersonInput>>;
  upsert?: Maybe<Array<AliasUpsertWithWhereUniqueWithoutPersonInput>>;
};

export type AliasUpdateOneWithoutPreferredAliasOfInput = {
  connect?: Maybe<AliasWhereUniqueInput>;
  connectOrCreate?: Maybe<AliasCreateOrConnectWithoutPreferredAliasOfInput>;
  create?: Maybe<AliasCreateWithoutPreferredAliasOfInput>;
  delete?: Maybe<Scalars['Boolean']>;
  disconnect?: Maybe<Scalars['Boolean']>;
  update?: Maybe<AliasUpdateWithoutPreferredAliasOfInput>;
  upsert?: Maybe<AliasUpsertWithoutPreferredAliasOfInput>;
};

export type AliasUpdateWithWhereUniqueWithoutPersonInput = {
  data: AliasUpdateWithoutPersonInput;
  where: AliasWhereUniqueInput;
};

export type AliasUpdateWithoutPersonInput = {
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  name?: Maybe<StringFieldUpdateOperationsInput>;
  preferredAliasOf?: Maybe<PersonUpdateOneWithoutPreferredAliasInput>;
  updatedAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
};

export type AliasUpdateWithoutPreferredAliasOfInput = {
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  name?: Maybe<StringFieldUpdateOperationsInput>;
  person?: Maybe<PersonUpdateOneRequiredWithoutAliasesInput>;
  updatedAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
};

export type AliasUpsertWithWhereUniqueWithoutPersonInput = {
  create: AliasCreateWithoutPersonInput;
  update: AliasUpdateWithoutPersonInput;
  where: AliasWhereUniqueInput;
};

export type AliasUpsertWithoutPreferredAliasOfInput = {
  create: AliasCreateWithoutPreferredAliasOfInput;
  update: AliasUpdateWithoutPreferredAliasOfInput;
};

export type AliasWhereInput = {
  AND?: Maybe<Array<AliasWhereInput>>;
  NOT?: Maybe<Array<AliasWhereInput>>;
  OR?: Maybe<Array<AliasWhereInput>>;
  createdAt?: Maybe<DateTimeFilter>;
  id?: Maybe<IntFilter>;
  name?: Maybe<StringFilter>;
  person?: Maybe<PersonWhereInput>;
  personId?: Maybe<IntFilter>;
  preferredAliasOf?: Maybe<PersonWhereInput>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type AliasWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
  personAlias?: Maybe<AliasPersonAliasCompoundUniqueInput>;
};

export type Appearance = {
  __typename?: 'Appearance';
  addedBy: User;
  createdAt: Scalars['DateTime'];
  faces: Array<Face>;
  id: Scalars['Int'];
  image: Image;
  person: Person;
  updatedAt: Scalars['DateTime'];
};


export type AppearanceFacesArgs = {
  cursor?: Maybe<FaceWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  take?: Maybe<Scalars['Int']>;
};

export type AppearanceAppearanceCompoundUniqueInput = {
  imageId: Scalars['Int'];
  personId: Scalars['Int'];
};

export type AppearanceCreateManyAddedByInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  imageId: Scalars['Int'];
  personId: Scalars['Int'];
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AppearanceCreateManyAddedByInputEnvelope = {
  data?: Maybe<Array<AppearanceCreateManyAddedByInput>>;
  skipDuplicates?: Maybe<Scalars['Boolean']>;
};

export type AppearanceCreateManyImageInput = {
  addedById: Scalars['Int'];
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  personId: Scalars['Int'];
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AppearanceCreateManyImageInputEnvelope = {
  data?: Maybe<Array<AppearanceCreateManyImageInput>>;
  skipDuplicates?: Maybe<Scalars['Boolean']>;
};

export type AppearanceCreateManyPersonInput = {
  addedById: Scalars['Int'];
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  imageId: Scalars['Int'];
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AppearanceCreateManyPersonInputEnvelope = {
  data?: Maybe<Array<AppearanceCreateManyPersonInput>>;
  skipDuplicates?: Maybe<Scalars['Boolean']>;
};

export type AppearanceCreateNestedManyWithoutAddedByInput = {
  connect?: Maybe<Array<AppearanceWhereUniqueInput>>;
  connectOrCreate?: Maybe<Array<AppearanceCreateOrConnectWithoutAddedByInput>>;
  create?: Maybe<Array<AppearanceCreateWithoutAddedByInput>>;
  createMany?: Maybe<AppearanceCreateManyAddedByInputEnvelope>;
};

export type AppearanceCreateNestedManyWithoutImageInput = {
  connect?: Maybe<Array<AppearanceWhereUniqueInput>>;
  connectOrCreate?: Maybe<Array<AppearanceCreateOrConnectWithoutImageInput>>;
  create?: Maybe<Array<AppearanceCreateWithoutImageInput>>;
  createMany?: Maybe<AppearanceCreateManyImageInputEnvelope>;
};

export type AppearanceCreateNestedManyWithoutPersonInput = {
  connect?: Maybe<Array<AppearanceWhereUniqueInput>>;
  connectOrCreate?: Maybe<Array<AppearanceCreateOrConnectWithoutPersonInput>>;
  create?: Maybe<Array<AppearanceCreateWithoutPersonInput>>;
  createMany?: Maybe<AppearanceCreateManyPersonInputEnvelope>;
};

export type AppearanceCreateOrConnectWithoutAddedByInput = {
  create: AppearanceCreateWithoutAddedByInput;
  where: AppearanceWhereUniqueInput;
};

export type AppearanceCreateOrConnectWithoutFacesInput = {
  create: AppearanceCreateWithoutFacesInput;
  where: AppearanceWhereUniqueInput;
};

export type AppearanceCreateOrConnectWithoutImageInput = {
  create: AppearanceCreateWithoutImageInput;
  where: AppearanceWhereUniqueInput;
};

export type AppearanceCreateOrConnectWithoutPersonInput = {
  create: AppearanceCreateWithoutPersonInput;
  where: AppearanceWhereUniqueInput;
};

export type AppearanceCreateWithoutAddedByInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  faces?: Maybe<FaceCreateNestedManyWithoutAppearanceInput>;
  image: ImageCreateNestedOneWithoutAppearancesInput;
  person: PersonCreateNestedOneWithoutAppearancesInput;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AppearanceCreateWithoutFacesInput = {
  addedBy: UserCreateNestedOneWithoutTaggedAppearancesInput;
  createdAt?: Maybe<Scalars['DateTime']>;
  image: ImageCreateNestedOneWithoutAppearancesInput;
  person: PersonCreateNestedOneWithoutAppearancesInput;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AppearanceCreateWithoutImageInput = {
  addedBy: UserCreateNestedOneWithoutTaggedAppearancesInput;
  createdAt?: Maybe<Scalars['DateTime']>;
  faces?: Maybe<FaceCreateNestedManyWithoutAppearanceInput>;
  person: PersonCreateNestedOneWithoutAppearancesInput;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AppearanceCreateWithoutPersonInput = {
  addedBy: UserCreateNestedOneWithoutTaggedAppearancesInput;
  createdAt?: Maybe<Scalars['DateTime']>;
  faces?: Maybe<FaceCreateNestedManyWithoutAppearanceInput>;
  image: ImageCreateNestedOneWithoutAppearancesInput;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type AppearanceListRelationFilter = {
  every?: Maybe<AppearanceWhereInput>;
  none?: Maybe<AppearanceWhereInput>;
  some?: Maybe<AppearanceWhereInput>;
};

export type AppearanceScalarWhereInput = {
  AND?: Maybe<Array<AppearanceScalarWhereInput>>;
  NOT?: Maybe<Array<AppearanceScalarWhereInput>>;
  OR?: Maybe<Array<AppearanceScalarWhereInput>>;
  addedById?: Maybe<IntFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  id?: Maybe<IntFilter>;
  imageId?: Maybe<IntFilter>;
  personId?: Maybe<IntFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type AppearanceUpdateManyMutationInput = {
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  updatedAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
};

export type AppearanceUpdateManyWithWhereWithoutAddedByInput = {
  data: AppearanceUpdateManyMutationInput;
  where: AppearanceScalarWhereInput;
};

export type AppearanceUpdateManyWithWhereWithoutImageInput = {
  data: AppearanceUpdateManyMutationInput;
  where: AppearanceScalarWhereInput;
};

export type AppearanceUpdateManyWithWhereWithoutPersonInput = {
  data: AppearanceUpdateManyMutationInput;
  where: AppearanceScalarWhereInput;
};

export type AppearanceUpdateManyWithoutAddedByInput = {
  connect?: Maybe<Array<AppearanceWhereUniqueInput>>;
  connectOrCreate?: Maybe<Array<AppearanceCreateOrConnectWithoutAddedByInput>>;
  create?: Maybe<Array<AppearanceCreateWithoutAddedByInput>>;
  createMany?: Maybe<AppearanceCreateManyAddedByInputEnvelope>;
  delete?: Maybe<Array<AppearanceWhereUniqueInput>>;
  deleteMany?: Maybe<Array<AppearanceScalarWhereInput>>;
  disconnect?: Maybe<Array<AppearanceWhereUniqueInput>>;
  set?: Maybe<Array<AppearanceWhereUniqueInput>>;
  update?: Maybe<Array<AppearanceUpdateWithWhereUniqueWithoutAddedByInput>>;
  updateMany?: Maybe<Array<AppearanceUpdateManyWithWhereWithoutAddedByInput>>;
  upsert?: Maybe<Array<AppearanceUpsertWithWhereUniqueWithoutAddedByInput>>;
};

export type AppearanceUpdateManyWithoutImageInput = {
  connect?: Maybe<Array<AppearanceWhereUniqueInput>>;
  connectOrCreate?: Maybe<Array<AppearanceCreateOrConnectWithoutImageInput>>;
  create?: Maybe<Array<AppearanceCreateWithoutImageInput>>;
  createMany?: Maybe<AppearanceCreateManyImageInputEnvelope>;
  delete?: Maybe<Array<AppearanceWhereUniqueInput>>;
  deleteMany?: Maybe<Array<AppearanceScalarWhereInput>>;
  disconnect?: Maybe<Array<AppearanceWhereUniqueInput>>;
  set?: Maybe<Array<AppearanceWhereUniqueInput>>;
  update?: Maybe<Array<AppearanceUpdateWithWhereUniqueWithoutImageInput>>;
  updateMany?: Maybe<Array<AppearanceUpdateManyWithWhereWithoutImageInput>>;
  upsert?: Maybe<Array<AppearanceUpsertWithWhereUniqueWithoutImageInput>>;
};

export type AppearanceUpdateManyWithoutPersonInput = {
  connect?: Maybe<Array<AppearanceWhereUniqueInput>>;
  connectOrCreate?: Maybe<Array<AppearanceCreateOrConnectWithoutPersonInput>>;
  create?: Maybe<Array<AppearanceCreateWithoutPersonInput>>;
  createMany?: Maybe<AppearanceCreateManyPersonInputEnvelope>;
  delete?: Maybe<Array<AppearanceWhereUniqueInput>>;
  deleteMany?: Maybe<Array<AppearanceScalarWhereInput>>;
  disconnect?: Maybe<Array<AppearanceWhereUniqueInput>>;
  set?: Maybe<Array<AppearanceWhereUniqueInput>>;
  update?: Maybe<Array<AppearanceUpdateWithWhereUniqueWithoutPersonInput>>;
  updateMany?: Maybe<Array<AppearanceUpdateManyWithWhereWithoutPersonInput>>;
  upsert?: Maybe<Array<AppearanceUpsertWithWhereUniqueWithoutPersonInput>>;
};

export type AppearanceUpdateOneWithoutFacesInput = {
  connect?: Maybe<AppearanceWhereUniqueInput>;
  connectOrCreate?: Maybe<AppearanceCreateOrConnectWithoutFacesInput>;
  create?: Maybe<AppearanceCreateWithoutFacesInput>;
  delete?: Maybe<Scalars['Boolean']>;
  disconnect?: Maybe<Scalars['Boolean']>;
  update?: Maybe<AppearanceUpdateWithoutFacesInput>;
  upsert?: Maybe<AppearanceUpsertWithoutFacesInput>;
};

export type AppearanceUpdateWithWhereUniqueWithoutAddedByInput = {
  data: AppearanceUpdateWithoutAddedByInput;
  where: AppearanceWhereUniqueInput;
};

export type AppearanceUpdateWithWhereUniqueWithoutImageInput = {
  data: AppearanceUpdateWithoutImageInput;
  where: AppearanceWhereUniqueInput;
};

export type AppearanceUpdateWithWhereUniqueWithoutPersonInput = {
  data: AppearanceUpdateWithoutPersonInput;
  where: AppearanceWhereUniqueInput;
};

export type AppearanceUpdateWithoutAddedByInput = {
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  faces?: Maybe<FaceUpdateManyWithoutAppearanceInput>;
  image?: Maybe<ImageUpdateOneRequiredWithoutAppearancesInput>;
  person?: Maybe<PersonUpdateOneRequiredWithoutAppearancesInput>;
  updatedAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
};

export type AppearanceUpdateWithoutFacesInput = {
  addedBy?: Maybe<UserUpdateOneRequiredWithoutTaggedAppearancesInput>;
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  image?: Maybe<ImageUpdateOneRequiredWithoutAppearancesInput>;
  person?: Maybe<PersonUpdateOneRequiredWithoutAppearancesInput>;
  updatedAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
};

export type AppearanceUpdateWithoutImageInput = {
  addedBy?: Maybe<UserUpdateOneRequiredWithoutTaggedAppearancesInput>;
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  faces?: Maybe<FaceUpdateManyWithoutAppearanceInput>;
  person?: Maybe<PersonUpdateOneRequiredWithoutAppearancesInput>;
  updatedAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
};

export type AppearanceUpdateWithoutPersonInput = {
  addedBy?: Maybe<UserUpdateOneRequiredWithoutTaggedAppearancesInput>;
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  faces?: Maybe<FaceUpdateManyWithoutAppearanceInput>;
  image?: Maybe<ImageUpdateOneRequiredWithoutAppearancesInput>;
  updatedAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
};

export type AppearanceUpsertWithWhereUniqueWithoutAddedByInput = {
  create: AppearanceCreateWithoutAddedByInput;
  update: AppearanceUpdateWithoutAddedByInput;
  where: AppearanceWhereUniqueInput;
};

export type AppearanceUpsertWithWhereUniqueWithoutImageInput = {
  create: AppearanceCreateWithoutImageInput;
  update: AppearanceUpdateWithoutImageInput;
  where: AppearanceWhereUniqueInput;
};

export type AppearanceUpsertWithWhereUniqueWithoutPersonInput = {
  create: AppearanceCreateWithoutPersonInput;
  update: AppearanceUpdateWithoutPersonInput;
  where: AppearanceWhereUniqueInput;
};

export type AppearanceUpsertWithoutFacesInput = {
  create: AppearanceCreateWithoutFacesInput;
  update: AppearanceUpdateWithoutFacesInput;
};

export type AppearanceWhereInput = {
  AND?: Maybe<Array<AppearanceWhereInput>>;
  NOT?: Maybe<Array<AppearanceWhereInput>>;
  OR?: Maybe<Array<AppearanceWhereInput>>;
  addedBy?: Maybe<UserWhereInput>;
  addedById?: Maybe<IntFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  faces?: Maybe<FaceListRelationFilter>;
  id?: Maybe<IntFilter>;
  image?: Maybe<ImageWhereInput>;
  imageId?: Maybe<IntFilter>;
  person?: Maybe<PersonWhereInput>;
  personId?: Maybe<IntFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type AppearanceWhereUniqueInput = {
  appearance?: Maybe<AppearanceAppearanceCompoundUniqueInput>;
  id?: Maybe<Scalars['Int']>;
};

export type BoolFieldUpdateOperationsInput = {
  set?: Maybe<Scalars['Boolean']>;
};

export type BoolFilter = {
  equals?: Maybe<Scalars['Boolean']>;
  not?: Maybe<NestedBoolFilter>;
};


export type DateTimeFieldUpdateOperationsInput = {
  set?: Maybe<Scalars['DateTime']>;
};

export type DateTimeFilter = {
  equals?: Maybe<Scalars['DateTime']>;
  gt?: Maybe<Scalars['DateTime']>;
  gte?: Maybe<Scalars['DateTime']>;
  in?: Maybe<Array<Scalars['DateTime']>>;
  lt?: Maybe<Scalars['DateTime']>;
  lte?: Maybe<Scalars['DateTime']>;
  not?: Maybe<NestedDateTimeFilter>;
  notIn?: Maybe<Array<Scalars['DateTime']>>;
};

export type DateTimeNullableFilter = {
  equals?: Maybe<Scalars['DateTime']>;
  gt?: Maybe<Scalars['DateTime']>;
  gte?: Maybe<Scalars['DateTime']>;
  in?: Maybe<Array<Scalars['DateTime']>>;
  lt?: Maybe<Scalars['DateTime']>;
  lte?: Maybe<Scalars['DateTime']>;
  not?: Maybe<NestedDateTimeNullableFilter>;
  notIn?: Maybe<Array<Scalars['DateTime']>>;
};

export type EnumFaceSourceFieldUpdateOperationsInput = {
  set?: Maybe<FaceSource>;
};

export type EnumFaceSourceFilter = {
  equals?: Maybe<FaceSource>;
  in?: Maybe<Array<FaceSource>>;
  not?: Maybe<NestedEnumFaceSourceFilter>;
  notIn?: Maybe<Array<FaceSource>>;
};

export type EnumMimeTypeFieldUpdateOperationsInput = {
  set?: Maybe<MimeType>;
};

export type EnumMimeTypeFilter = {
  equals?: Maybe<MimeType>;
  in?: Maybe<Array<MimeType>>;
  not?: Maybe<NestedEnumMimeTypeFilter>;
  notIn?: Maybe<Array<MimeType>>;
};

export type EnumTagSourceFieldUpdateOperationsInput = {
  set?: Maybe<TagSource>;
};

export type EnumTagSourceFilter = {
  equals?: Maybe<TagSource>;
  in?: Maybe<Array<TagSource>>;
  not?: Maybe<NestedEnumTagSourceFilter>;
  notIn?: Maybe<Array<TagSource>>;
};

export type EnumUploadTypeFieldUpdateOperationsInput = {
  set?: Maybe<UploadType>;
};

export type EnumUploadTypeFilter = {
  equals?: Maybe<UploadType>;
  in?: Maybe<Array<UploadType>>;
  not?: Maybe<NestedEnumUploadTypeFilter>;
  notIn?: Maybe<Array<UploadType>>;
};

export type Face = {
  __typename?: 'Face';
  addedBy?: Maybe<User>;
  appearance?: Maybe<Appearance>;
  createdAt: Scalars['DateTime'];
  height: Scalars['Float'];
  id: Scalars['Int'];
  image: Image;
  score: Scalars['Float'];
  source: FaceSource;
  updatedAt: Scalars['DateTime'];
  width: Scalars['Float'];
  x: Scalars['Float'];
  y: Scalars['Float'];
};

export type FaceCreateNestedManyWithoutAddedByInput = {
  connect?: Maybe<Array<FaceWhereUniqueInput>>;
};

export type FaceCreateNestedManyWithoutAppearanceInput = {
  connect?: Maybe<Array<FaceWhereUniqueInput>>;
};

export type FaceCreateNestedManyWithoutImageInput = {
  connect?: Maybe<Array<FaceWhereUniqueInput>>;
};

export type FaceCreateNestedManyWithoutPersonInput = {
  connect?: Maybe<Array<FaceWhereUniqueInput>>;
};

export type FaceInput = {
  certainty: Scalars['Float'];
  descriptor: Array<Scalars['Float']>;
  height: Scalars['Float'];
  width: Scalars['Float'];
  x: Scalars['Float'];
  y: Scalars['Float'];
};

export type FaceListRelationFilter = {
  every?: Maybe<FaceWhereInput>;
  none?: Maybe<FaceWhereInput>;
  some?: Maybe<FaceWhereInput>;
};

export type FaceScalarWhereInput = {
  AND?: Maybe<Array<FaceScalarWhereInput>>;
  NOT?: Maybe<Array<FaceScalarWhereInput>>;
  OR?: Maybe<Array<FaceScalarWhereInput>>;
  addedById?: Maybe<IntNullableFilter>;
  appearanceId?: Maybe<IntNullableFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  height?: Maybe<FloatFilter>;
  id?: Maybe<IntFilter>;
  imageId?: Maybe<IntFilter>;
  personId?: Maybe<IntNullableFilter>;
  score?: Maybe<FloatFilter>;
  source?: Maybe<EnumFaceSourceFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
  width?: Maybe<FloatFilter>;
  x?: Maybe<FloatFilter>;
  y?: Maybe<FloatFilter>;
};

export enum FaceSource {
  Manual = 'Manual',
  Scan = 'Scan'
}

export type FaceUpdateManyMutationInput = {
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  height?: Maybe<FloatFieldUpdateOperationsInput>;
  score?: Maybe<FloatFieldUpdateOperationsInput>;
  source?: Maybe<EnumFaceSourceFieldUpdateOperationsInput>;
  updatedAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  width?: Maybe<FloatFieldUpdateOperationsInput>;
  x?: Maybe<FloatFieldUpdateOperationsInput>;
  y?: Maybe<FloatFieldUpdateOperationsInput>;
};

export type FaceUpdateManyWithWhereWithoutAddedByInput = {
  data: FaceUpdateManyMutationInput;
  where: FaceScalarWhereInput;
};

export type FaceUpdateManyWithWhereWithoutAppearanceInput = {
  data: FaceUpdateManyMutationInput;
  where: FaceScalarWhereInput;
};

export type FaceUpdateManyWithWhereWithoutImageInput = {
  data: FaceUpdateManyMutationInput;
  where: FaceScalarWhereInput;
};

export type FaceUpdateManyWithWhereWithoutPersonInput = {
  data: FaceUpdateManyMutationInput;
  where: FaceScalarWhereInput;
};

export type FaceUpdateManyWithoutAddedByInput = {
  connect?: Maybe<Array<FaceWhereUniqueInput>>;
  delete?: Maybe<Array<FaceWhereUniqueInput>>;
  deleteMany?: Maybe<Array<FaceScalarWhereInput>>;
  disconnect?: Maybe<Array<FaceWhereUniqueInput>>;
  set?: Maybe<Array<FaceWhereUniqueInput>>;
  update?: Maybe<Array<FaceUpdateWithWhereUniqueWithoutAddedByInput>>;
  updateMany?: Maybe<Array<FaceUpdateManyWithWhereWithoutAddedByInput>>;
};

export type FaceUpdateManyWithoutAppearanceInput = {
  connect?: Maybe<Array<FaceWhereUniqueInput>>;
  delete?: Maybe<Array<FaceWhereUniqueInput>>;
  deleteMany?: Maybe<Array<FaceScalarWhereInput>>;
  disconnect?: Maybe<Array<FaceWhereUniqueInput>>;
  set?: Maybe<Array<FaceWhereUniqueInput>>;
  update?: Maybe<Array<FaceUpdateWithWhereUniqueWithoutAppearanceInput>>;
  updateMany?: Maybe<Array<FaceUpdateManyWithWhereWithoutAppearanceInput>>;
};

export type FaceUpdateManyWithoutImageInput = {
  connect?: Maybe<Array<FaceWhereUniqueInput>>;
  delete?: Maybe<Array<FaceWhereUniqueInput>>;
  deleteMany?: Maybe<Array<FaceScalarWhereInput>>;
  disconnect?: Maybe<Array<FaceWhereUniqueInput>>;
  set?: Maybe<Array<FaceWhereUniqueInput>>;
  update?: Maybe<Array<FaceUpdateWithWhereUniqueWithoutImageInput>>;
  updateMany?: Maybe<Array<FaceUpdateManyWithWhereWithoutImageInput>>;
};

export type FaceUpdateManyWithoutPersonInput = {
  connect?: Maybe<Array<FaceWhereUniqueInput>>;
  delete?: Maybe<Array<FaceWhereUniqueInput>>;
  deleteMany?: Maybe<Array<FaceScalarWhereInput>>;
  disconnect?: Maybe<Array<FaceWhereUniqueInput>>;
  set?: Maybe<Array<FaceWhereUniqueInput>>;
  update?: Maybe<Array<FaceUpdateWithWhereUniqueWithoutPersonInput>>;
  updateMany?: Maybe<Array<FaceUpdateManyWithWhereWithoutPersonInput>>;
};

export type FaceUpdateWithWhereUniqueWithoutAddedByInput = {
  data: FaceUpdateWithoutAddedByInput;
  where: FaceWhereUniqueInput;
};

export type FaceUpdateWithWhereUniqueWithoutAppearanceInput = {
  data: FaceUpdateWithoutAppearanceInput;
  where: FaceWhereUniqueInput;
};

export type FaceUpdateWithWhereUniqueWithoutImageInput = {
  data: FaceUpdateWithoutImageInput;
  where: FaceWhereUniqueInput;
};

export type FaceUpdateWithWhereUniqueWithoutPersonInput = {
  data: FaceUpdateWithoutPersonInput;
  where: FaceWhereUniqueInput;
};

export type FaceUpdateWithoutAddedByInput = {
  appearance?: Maybe<AppearanceUpdateOneWithoutFacesInput>;
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  height?: Maybe<FloatFieldUpdateOperationsInput>;
  image?: Maybe<ImageUpdateOneRequiredWithoutFacesInput>;
  person?: Maybe<PersonUpdateOneWithoutAppearsInInput>;
  score?: Maybe<FloatFieldUpdateOperationsInput>;
  source?: Maybe<EnumFaceSourceFieldUpdateOperationsInput>;
  updatedAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  width?: Maybe<FloatFieldUpdateOperationsInput>;
  x?: Maybe<FloatFieldUpdateOperationsInput>;
  y?: Maybe<FloatFieldUpdateOperationsInput>;
};

export type FaceUpdateWithoutAppearanceInput = {
  addedBy?: Maybe<UserUpdateOneWithoutMarkedFacesInput>;
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  height?: Maybe<FloatFieldUpdateOperationsInput>;
  image?: Maybe<ImageUpdateOneRequiredWithoutFacesInput>;
  person?: Maybe<PersonUpdateOneWithoutAppearsInInput>;
  score?: Maybe<FloatFieldUpdateOperationsInput>;
  source?: Maybe<EnumFaceSourceFieldUpdateOperationsInput>;
  updatedAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  width?: Maybe<FloatFieldUpdateOperationsInput>;
  x?: Maybe<FloatFieldUpdateOperationsInput>;
  y?: Maybe<FloatFieldUpdateOperationsInput>;
};

export type FaceUpdateWithoutImageInput = {
  addedBy?: Maybe<UserUpdateOneWithoutMarkedFacesInput>;
  appearance?: Maybe<AppearanceUpdateOneWithoutFacesInput>;
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  height?: Maybe<FloatFieldUpdateOperationsInput>;
  person?: Maybe<PersonUpdateOneWithoutAppearsInInput>;
  score?: Maybe<FloatFieldUpdateOperationsInput>;
  source?: Maybe<EnumFaceSourceFieldUpdateOperationsInput>;
  updatedAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  width?: Maybe<FloatFieldUpdateOperationsInput>;
  x?: Maybe<FloatFieldUpdateOperationsInput>;
  y?: Maybe<FloatFieldUpdateOperationsInput>;
};

export type FaceUpdateWithoutPersonInput = {
  addedBy?: Maybe<UserUpdateOneWithoutMarkedFacesInput>;
  appearance?: Maybe<AppearanceUpdateOneWithoutFacesInput>;
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  height?: Maybe<FloatFieldUpdateOperationsInput>;
  image?: Maybe<ImageUpdateOneRequiredWithoutFacesInput>;
  score?: Maybe<FloatFieldUpdateOperationsInput>;
  source?: Maybe<EnumFaceSourceFieldUpdateOperationsInput>;
  updatedAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  width?: Maybe<FloatFieldUpdateOperationsInput>;
  x?: Maybe<FloatFieldUpdateOperationsInput>;
  y?: Maybe<FloatFieldUpdateOperationsInput>;
};

export type FaceWhereInput = {
  AND?: Maybe<Array<FaceWhereInput>>;
  NOT?: Maybe<Array<FaceWhereInput>>;
  OR?: Maybe<Array<FaceWhereInput>>;
  addedBy?: Maybe<UserWhereInput>;
  addedById?: Maybe<IntNullableFilter>;
  appearance?: Maybe<AppearanceWhereInput>;
  appearanceId?: Maybe<IntNullableFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  height?: Maybe<FloatFilter>;
  id?: Maybe<IntFilter>;
  image?: Maybe<ImageWhereInput>;
  imageId?: Maybe<IntFilter>;
  person?: Maybe<PersonWhereInput>;
  personId?: Maybe<IntNullableFilter>;
  score?: Maybe<FloatFilter>;
  source?: Maybe<EnumFaceSourceFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
  width?: Maybe<FloatFilter>;
  x?: Maybe<FloatFilter>;
  y?: Maybe<FloatFilter>;
};

export type FaceWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
};

export type FloatFieldUpdateOperationsInput = {
  decrement?: Maybe<Scalars['Float']>;
  divide?: Maybe<Scalars['Float']>;
  increment?: Maybe<Scalars['Float']>;
  multiply?: Maybe<Scalars['Float']>;
  set?: Maybe<Scalars['Float']>;
};

export type FloatFilter = {
  equals?: Maybe<Scalars['Float']>;
  gt?: Maybe<Scalars['Float']>;
  gte?: Maybe<Scalars['Float']>;
  in?: Maybe<Array<Scalars['Float']>>;
  lt?: Maybe<Scalars['Float']>;
  lte?: Maybe<Scalars['Float']>;
  not?: Maybe<NestedFloatFilter>;
  notIn?: Maybe<Array<Scalars['Float']>>;
};

export type Group = {
  __typename?: 'Group';
  aliases: Array<GroupAlias>;
  avatar?: Maybe<Image>;
  banner?: Maybe<Image>;
  createdAt: Scalars['DateTime'];
  id: Scalars['Int'];
  members: Array<GroupMember>;
  name: Scalars['String'];
  updatedAt: Scalars['DateTime'];
};


export type GroupAliasesArgs = {
  cursor?: Maybe<GroupAliasWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  take?: Maybe<Scalars['Int']>;
};


export type GroupMembersArgs = {
  cursor?: Maybe<GroupMemberWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  take?: Maybe<Scalars['Int']>;
};

export type GroupAlias = {
  __typename?: 'GroupAlias';
  createdAt: Scalars['DateTime'];
  id: Scalars['Int'];
  name: Scalars['String'];
  updatedAt: Scalars['DateTime'];
};

export type GroupAliasCreateManyGroupInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  name: Scalars['String'];
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type GroupAliasCreateManyGroupInputEnvelope = {
  data?: Maybe<Array<GroupAliasCreateManyGroupInput>>;
  skipDuplicates?: Maybe<Scalars['Boolean']>;
};

export type GroupAliasCreateNestedManyWithoutGroupInput = {
  connect?: Maybe<Array<GroupAliasWhereUniqueInput>>;
  connectOrCreate?: Maybe<Array<GroupAliasCreateOrConnectWithoutGroupInput>>;
  create?: Maybe<Array<GroupAliasCreateWithoutGroupInput>>;
  createMany?: Maybe<GroupAliasCreateManyGroupInputEnvelope>;
};

export type GroupAliasCreateOrConnectWithoutGroupInput = {
  create: GroupAliasCreateWithoutGroupInput;
  where: GroupAliasWhereUniqueInput;
};

export type GroupAliasCreateWithoutGroupInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type GroupAliasListRelationFilter = {
  every?: Maybe<GroupAliasWhereInput>;
  none?: Maybe<GroupAliasWhereInput>;
  some?: Maybe<GroupAliasWhereInput>;
};

export type GroupAliasScalarWhereInput = {
  AND?: Maybe<Array<GroupAliasScalarWhereInput>>;
  NOT?: Maybe<Array<GroupAliasScalarWhereInput>>;
  OR?: Maybe<Array<GroupAliasScalarWhereInput>>;
  createdAt?: Maybe<DateTimeFilter>;
  groupId?: Maybe<IntFilter>;
  id?: Maybe<IntFilter>;
  name?: Maybe<StringFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type GroupAliasUpdateManyMutationInput = {
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  name?: Maybe<StringFieldUpdateOperationsInput>;
  updatedAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
};

export type GroupAliasUpdateManyWithWhereWithoutGroupInput = {
  data: GroupAliasUpdateManyMutationInput;
  where: GroupAliasScalarWhereInput;
};

export type GroupAliasUpdateManyWithoutGroupInput = {
  connect?: Maybe<Array<GroupAliasWhereUniqueInput>>;
  connectOrCreate?: Maybe<Array<GroupAliasCreateOrConnectWithoutGroupInput>>;
  create?: Maybe<Array<GroupAliasCreateWithoutGroupInput>>;
  createMany?: Maybe<GroupAliasCreateManyGroupInputEnvelope>;
  delete?: Maybe<Array<GroupAliasWhereUniqueInput>>;
  deleteMany?: Maybe<Array<GroupAliasScalarWhereInput>>;
  disconnect?: Maybe<Array<GroupAliasWhereUniqueInput>>;
  set?: Maybe<Array<GroupAliasWhereUniqueInput>>;
  update?: Maybe<Array<GroupAliasUpdateWithWhereUniqueWithoutGroupInput>>;
  updateMany?: Maybe<Array<GroupAliasUpdateManyWithWhereWithoutGroupInput>>;
  upsert?: Maybe<Array<GroupAliasUpsertWithWhereUniqueWithoutGroupInput>>;
};

export type GroupAliasUpdateWithWhereUniqueWithoutGroupInput = {
  data: GroupAliasUpdateWithoutGroupInput;
  where: GroupAliasWhereUniqueInput;
};

export type GroupAliasUpdateWithoutGroupInput = {
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  name?: Maybe<StringFieldUpdateOperationsInput>;
  updatedAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
};

export type GroupAliasUpsertWithWhereUniqueWithoutGroupInput = {
  create: GroupAliasCreateWithoutGroupInput;
  update: GroupAliasUpdateWithoutGroupInput;
  where: GroupAliasWhereUniqueInput;
};

export type GroupAliasWhereInput = {
  AND?: Maybe<Array<GroupAliasWhereInput>>;
  NOT?: Maybe<Array<GroupAliasWhereInput>>;
  OR?: Maybe<Array<GroupAliasWhereInput>>;
  createdAt?: Maybe<DateTimeFilter>;
  group?: Maybe<GroupWhereInput>;
  groupId?: Maybe<IntFilter>;
  id?: Maybe<IntFilter>;
  name?: Maybe<StringFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type GroupAliasWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
};

export type GroupCreateInput = {
  aliases?: Maybe<GroupAliasCreateNestedManyWithoutGroupInput>;
  avatar?: Maybe<ImageCreateNestedOneWithoutAvatarOfInput>;
  banner?: Maybe<ImageCreateNestedOneWithoutBannerOfInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  ireneBotId?: Maybe<Scalars['Int']>;
  members?: Maybe<GroupMemberCreateNestedManyWithoutGroupInput>;
  name: Scalars['String'];
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type GroupCreateNestedOneWithoutAvatarInput = {
  connect?: Maybe<GroupWhereUniqueInput>;
  connectOrCreate?: Maybe<GroupCreateOrConnectWithoutAvatarInput>;
  create?: Maybe<GroupCreateWithoutAvatarInput>;
};

export type GroupCreateNestedOneWithoutBannerInput = {
  connect?: Maybe<GroupWhereUniqueInput>;
  connectOrCreate?: Maybe<GroupCreateOrConnectWithoutBannerInput>;
  create?: Maybe<GroupCreateWithoutBannerInput>;
};

export type GroupCreateNestedOneWithoutMembersInput = {
  connect?: Maybe<GroupWhereUniqueInput>;
  connectOrCreate?: Maybe<GroupCreateOrConnectWithoutMembersInput>;
  create?: Maybe<GroupCreateWithoutMembersInput>;
};

export type GroupCreateOrConnectWithoutAvatarInput = {
  create: GroupCreateWithoutAvatarInput;
  where: GroupWhereUniqueInput;
};

export type GroupCreateOrConnectWithoutBannerInput = {
  create: GroupCreateWithoutBannerInput;
  where: GroupWhereUniqueInput;
};

export type GroupCreateOrConnectWithoutMembersInput = {
  create: GroupCreateWithoutMembersInput;
  where: GroupWhereUniqueInput;
};

export type GroupCreateWithoutAvatarInput = {
  aliases?: Maybe<GroupAliasCreateNestedManyWithoutGroupInput>;
  banner?: Maybe<ImageCreateNestedOneWithoutBannerOfInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  ireneBotId?: Maybe<Scalars['Int']>;
  members?: Maybe<GroupMemberCreateNestedManyWithoutGroupInput>;
  name: Scalars['String'];
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type GroupCreateWithoutBannerInput = {
  aliases?: Maybe<GroupAliasCreateNestedManyWithoutGroupInput>;
  avatar?: Maybe<ImageCreateNestedOneWithoutAvatarOfInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  ireneBotId?: Maybe<Scalars['Int']>;
  members?: Maybe<GroupMemberCreateNestedManyWithoutGroupInput>;
  name: Scalars['String'];
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type GroupCreateWithoutMembersInput = {
  aliases?: Maybe<GroupAliasCreateNestedManyWithoutGroupInput>;
  avatar?: Maybe<ImageCreateNestedOneWithoutAvatarOfInput>;
  banner?: Maybe<ImageCreateNestedOneWithoutBannerOfInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  ireneBotId?: Maybe<Scalars['Int']>;
  name: Scalars['String'];
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type GroupMember = {
  __typename?: 'GroupMember';
  createdAt: Scalars['DateTime'];
  endDate?: Maybe<Scalars['DateTime']>;
  group: Group;
  id: Scalars['Int'];
  person: Person;
  startDate?: Maybe<Scalars['DateTime']>;
  updatedAt: Scalars['DateTime'];
};

export type GroupMemberCreateManyGroupInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  endDate?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  personId: Scalars['Int'];
  startDate?: Maybe<Scalars['DateTime']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type GroupMemberCreateManyGroupInputEnvelope = {
  data?: Maybe<Array<GroupMemberCreateManyGroupInput>>;
  skipDuplicates?: Maybe<Scalars['Boolean']>;
};

export type GroupMemberCreateManyPersonInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  endDate?: Maybe<Scalars['DateTime']>;
  groupId: Scalars['Int'];
  id?: Maybe<Scalars['Int']>;
  startDate?: Maybe<Scalars['DateTime']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type GroupMemberCreateManyPersonInputEnvelope = {
  data?: Maybe<Array<GroupMemberCreateManyPersonInput>>;
  skipDuplicates?: Maybe<Scalars['Boolean']>;
};

export type GroupMemberCreateNestedManyWithoutGroupInput = {
  connect?: Maybe<Array<GroupMemberWhereUniqueInput>>;
  connectOrCreate?: Maybe<Array<GroupMemberCreateOrConnectWithoutGroupInput>>;
  create?: Maybe<Array<GroupMemberCreateWithoutGroupInput>>;
  createMany?: Maybe<GroupMemberCreateManyGroupInputEnvelope>;
};

export type GroupMemberCreateNestedManyWithoutPersonInput = {
  connect?: Maybe<Array<GroupMemberWhereUniqueInput>>;
  connectOrCreate?: Maybe<Array<GroupMemberCreateOrConnectWithoutPersonInput>>;
  create?: Maybe<Array<GroupMemberCreateWithoutPersonInput>>;
  createMany?: Maybe<GroupMemberCreateManyPersonInputEnvelope>;
};

export type GroupMemberCreateOrConnectWithoutGroupInput = {
  create: GroupMemberCreateWithoutGroupInput;
  where: GroupMemberWhereUniqueInput;
};

export type GroupMemberCreateOrConnectWithoutPersonInput = {
  create: GroupMemberCreateWithoutPersonInput;
  where: GroupMemberWhereUniqueInput;
};

export type GroupMemberCreateWithoutGroupInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  endDate?: Maybe<Scalars['DateTime']>;
  person: PersonCreateNestedOneWithoutMemberOfInput;
  startDate?: Maybe<Scalars['DateTime']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type GroupMemberCreateWithoutPersonInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  endDate?: Maybe<Scalars['DateTime']>;
  group: GroupCreateNestedOneWithoutMembersInput;
  startDate?: Maybe<Scalars['DateTime']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type GroupMemberListRelationFilter = {
  every?: Maybe<GroupMemberWhereInput>;
  none?: Maybe<GroupMemberWhereInput>;
  some?: Maybe<GroupMemberWhereInput>;
};

export type GroupMemberMemberCompoundUniqueInput = {
  groupId: Scalars['Int'];
  personId: Scalars['Int'];
};

export type GroupMemberScalarWhereInput = {
  AND?: Maybe<Array<GroupMemberScalarWhereInput>>;
  NOT?: Maybe<Array<GroupMemberScalarWhereInput>>;
  OR?: Maybe<Array<GroupMemberScalarWhereInput>>;
  createdAt?: Maybe<DateTimeFilter>;
  endDate?: Maybe<DateTimeNullableFilter>;
  groupId?: Maybe<IntFilter>;
  id?: Maybe<IntFilter>;
  personId?: Maybe<IntFilter>;
  startDate?: Maybe<DateTimeNullableFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type GroupMemberUpdateManyMutationInput = {
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  endDate?: Maybe<NullableDateTimeFieldUpdateOperationsInput>;
  startDate?: Maybe<NullableDateTimeFieldUpdateOperationsInput>;
  updatedAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
};

export type GroupMemberUpdateManyWithWhereWithoutGroupInput = {
  data: GroupMemberUpdateManyMutationInput;
  where: GroupMemberScalarWhereInput;
};

export type GroupMemberUpdateManyWithWhereWithoutPersonInput = {
  data: GroupMemberUpdateManyMutationInput;
  where: GroupMemberScalarWhereInput;
};

export type GroupMemberUpdateManyWithoutGroupInput = {
  connect?: Maybe<Array<GroupMemberWhereUniqueInput>>;
  connectOrCreate?: Maybe<Array<GroupMemberCreateOrConnectWithoutGroupInput>>;
  create?: Maybe<Array<GroupMemberCreateWithoutGroupInput>>;
  createMany?: Maybe<GroupMemberCreateManyGroupInputEnvelope>;
  delete?: Maybe<Array<GroupMemberWhereUniqueInput>>;
  deleteMany?: Maybe<Array<GroupMemberScalarWhereInput>>;
  disconnect?: Maybe<Array<GroupMemberWhereUniqueInput>>;
  set?: Maybe<Array<GroupMemberWhereUniqueInput>>;
  update?: Maybe<Array<GroupMemberUpdateWithWhereUniqueWithoutGroupInput>>;
  updateMany?: Maybe<Array<GroupMemberUpdateManyWithWhereWithoutGroupInput>>;
  upsert?: Maybe<Array<GroupMemberUpsertWithWhereUniqueWithoutGroupInput>>;
};

export type GroupMemberUpdateManyWithoutPersonInput = {
  connect?: Maybe<Array<GroupMemberWhereUniqueInput>>;
  connectOrCreate?: Maybe<Array<GroupMemberCreateOrConnectWithoutPersonInput>>;
  create?: Maybe<Array<GroupMemberCreateWithoutPersonInput>>;
  createMany?: Maybe<GroupMemberCreateManyPersonInputEnvelope>;
  delete?: Maybe<Array<GroupMemberWhereUniqueInput>>;
  deleteMany?: Maybe<Array<GroupMemberScalarWhereInput>>;
  disconnect?: Maybe<Array<GroupMemberWhereUniqueInput>>;
  set?: Maybe<Array<GroupMemberWhereUniqueInput>>;
  update?: Maybe<Array<GroupMemberUpdateWithWhereUniqueWithoutPersonInput>>;
  updateMany?: Maybe<Array<GroupMemberUpdateManyWithWhereWithoutPersonInput>>;
  upsert?: Maybe<Array<GroupMemberUpsertWithWhereUniqueWithoutPersonInput>>;
};

export type GroupMemberUpdateWithWhereUniqueWithoutGroupInput = {
  data: GroupMemberUpdateWithoutGroupInput;
  where: GroupMemberWhereUniqueInput;
};

export type GroupMemberUpdateWithWhereUniqueWithoutPersonInput = {
  data: GroupMemberUpdateWithoutPersonInput;
  where: GroupMemberWhereUniqueInput;
};

export type GroupMemberUpdateWithoutGroupInput = {
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  endDate?: Maybe<NullableDateTimeFieldUpdateOperationsInput>;
  person?: Maybe<PersonUpdateOneRequiredWithoutMemberOfInput>;
  startDate?: Maybe<NullableDateTimeFieldUpdateOperationsInput>;
  updatedAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
};

export type GroupMemberUpdateWithoutPersonInput = {
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  endDate?: Maybe<NullableDateTimeFieldUpdateOperationsInput>;
  group?: Maybe<GroupUpdateOneRequiredWithoutMembersInput>;
  startDate?: Maybe<NullableDateTimeFieldUpdateOperationsInput>;
  updatedAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
};

export type GroupMemberUpsertWithWhereUniqueWithoutGroupInput = {
  create: GroupMemberCreateWithoutGroupInput;
  update: GroupMemberUpdateWithoutGroupInput;
  where: GroupMemberWhereUniqueInput;
};

export type GroupMemberUpsertWithWhereUniqueWithoutPersonInput = {
  create: GroupMemberCreateWithoutPersonInput;
  update: GroupMemberUpdateWithoutPersonInput;
  where: GroupMemberWhereUniqueInput;
};

export type GroupMemberWhereInput = {
  AND?: Maybe<Array<GroupMemberWhereInput>>;
  NOT?: Maybe<Array<GroupMemberWhereInput>>;
  OR?: Maybe<Array<GroupMemberWhereInput>>;
  createdAt?: Maybe<DateTimeFilter>;
  endDate?: Maybe<DateTimeNullableFilter>;
  group?: Maybe<GroupWhereInput>;
  groupId?: Maybe<IntFilter>;
  id?: Maybe<IntFilter>;
  person?: Maybe<PersonWhereInput>;
  personId?: Maybe<IntFilter>;
  startDate?: Maybe<DateTimeNullableFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type GroupMemberWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
  member?: Maybe<GroupMemberMemberCompoundUniqueInput>;
};

export type GroupUpdateInput = {
  aliases?: Maybe<GroupAliasUpdateManyWithoutGroupInput>;
  avatar?: Maybe<ImageUpdateOneWithoutAvatarOfInput>;
  banner?: Maybe<ImageUpdateOneWithoutBannerOfInput>;
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  ireneBotId?: Maybe<NullableIntFieldUpdateOperationsInput>;
  members?: Maybe<GroupMemberUpdateManyWithoutGroupInput>;
  name?: Maybe<StringFieldUpdateOperationsInput>;
  updatedAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
};

export type GroupUpdateOneRequiredWithoutMembersInput = {
  connect?: Maybe<GroupWhereUniqueInput>;
  connectOrCreate?: Maybe<GroupCreateOrConnectWithoutMembersInput>;
  create?: Maybe<GroupCreateWithoutMembersInput>;
  update?: Maybe<GroupUpdateWithoutMembersInput>;
  upsert?: Maybe<GroupUpsertWithoutMembersInput>;
};

export type GroupUpdateOneWithoutAvatarInput = {
  connect?: Maybe<GroupWhereUniqueInput>;
  connectOrCreate?: Maybe<GroupCreateOrConnectWithoutAvatarInput>;
  create?: Maybe<GroupCreateWithoutAvatarInput>;
  delete?: Maybe<Scalars['Boolean']>;
  disconnect?: Maybe<Scalars['Boolean']>;
  update?: Maybe<GroupUpdateWithoutAvatarInput>;
  upsert?: Maybe<GroupUpsertWithoutAvatarInput>;
};

export type GroupUpdateOneWithoutBannerInput = {
  connect?: Maybe<GroupWhereUniqueInput>;
  connectOrCreate?: Maybe<GroupCreateOrConnectWithoutBannerInput>;
  create?: Maybe<GroupCreateWithoutBannerInput>;
  delete?: Maybe<Scalars['Boolean']>;
  disconnect?: Maybe<Scalars['Boolean']>;
  update?: Maybe<GroupUpdateWithoutBannerInput>;
  upsert?: Maybe<GroupUpsertWithoutBannerInput>;
};

export type GroupUpdateWithoutAvatarInput = {
  aliases?: Maybe<GroupAliasUpdateManyWithoutGroupInput>;
  banner?: Maybe<ImageUpdateOneWithoutBannerOfInput>;
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  ireneBotId?: Maybe<NullableIntFieldUpdateOperationsInput>;
  members?: Maybe<GroupMemberUpdateManyWithoutGroupInput>;
  name?: Maybe<StringFieldUpdateOperationsInput>;
  updatedAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
};

export type GroupUpdateWithoutBannerInput = {
  aliases?: Maybe<GroupAliasUpdateManyWithoutGroupInput>;
  avatar?: Maybe<ImageUpdateOneWithoutAvatarOfInput>;
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  ireneBotId?: Maybe<NullableIntFieldUpdateOperationsInput>;
  members?: Maybe<GroupMemberUpdateManyWithoutGroupInput>;
  name?: Maybe<StringFieldUpdateOperationsInput>;
  updatedAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
};

export type GroupUpdateWithoutMembersInput = {
  aliases?: Maybe<GroupAliasUpdateManyWithoutGroupInput>;
  avatar?: Maybe<ImageUpdateOneWithoutAvatarOfInput>;
  banner?: Maybe<ImageUpdateOneWithoutBannerOfInput>;
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  ireneBotId?: Maybe<NullableIntFieldUpdateOperationsInput>;
  name?: Maybe<StringFieldUpdateOperationsInput>;
  updatedAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
};

export type GroupUpsertWithoutAvatarInput = {
  create: GroupCreateWithoutAvatarInput;
  update: GroupUpdateWithoutAvatarInput;
};

export type GroupUpsertWithoutBannerInput = {
  create: GroupCreateWithoutBannerInput;
  update: GroupUpdateWithoutBannerInput;
};

export type GroupUpsertWithoutMembersInput = {
  create: GroupCreateWithoutMembersInput;
  update: GroupUpdateWithoutMembersInput;
};

export type GroupWhereInput = {
  AND?: Maybe<Array<GroupWhereInput>>;
  NOT?: Maybe<Array<GroupWhereInput>>;
  OR?: Maybe<Array<GroupWhereInput>>;
  aliases?: Maybe<GroupAliasListRelationFilter>;
  avatar?: Maybe<ImageWhereInput>;
  avatarId?: Maybe<IntNullableFilter>;
  banner?: Maybe<ImageWhereInput>;
  bannerId?: Maybe<IntNullableFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  id?: Maybe<IntFilter>;
  ireneBotId?: Maybe<IntNullableFilter>;
  members?: Maybe<GroupMemberListRelationFilter>;
  name?: Maybe<StringFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type GroupWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
  ireneBotId?: Maybe<Scalars['Int']>;
};

export type Image = {
  __typename?: 'Image';
  appearances: Array<Appearance>;
  /** The aspect ratio of the image */
  aspectRatio: Scalars['Float'];
  bytes: Scalars['Int'];
  caption?: Maybe<Scalars['String']>;
  /** A graph of connections people in this image share with others based on images they appear together in up to a depth of 4 */
  connections: ImageConnections;
  createdAt: Scalars['DateTime'];
  faceScanDate?: Maybe<Scalars['DateTime']>;
  /** The name the image file was uploaded with. */
  fileName?: Maybe<Scalars['String']>;
  /** Human readable file size. Use `bytes` for a number representation. */
  fileSize: Scalars['String'];
  /** SHA256 checksum of the image. */
  hash: Scalars['String'];
  /** Height of the image in pixels. */
  height: Scalars['Int'];
  id: Scalars['Int'];
  /** ( ͡° ͜ʖ ͡°) */
  isNsfw: Scalars['Boolean'];
  /** False if not logged in */
  liked?: Maybe<Scalars['Boolean']>;
  /** The IANA media type of the image. */
  mimetype: MimeType;
  /** Block hash of the image, useful for doing reverse search using hamming distance. */
  pHash?: Maybe<Scalars['String']>;
  /** Dominant colors in the image in decimal format, sorted by frequency. */
  palette: Array<Scalars['Int']>;
  /** The visibility status of the image. */
  public: Scalars['Boolean'];
  /** Direct link to the image on the CDN */
  rawUrl: Scalars['String'];
  /** The unique url identifier of the image. */
  slug: Scalars['String'];
  /** The url the image was taken from (if applicable). Not guaranteed to be a direct image url. */
  source?: Maybe<Scalars['String']>;
  tags: Array<Tag>;
  thumbnail: Thumbnail;
  unknownFaces: Array<Face>;
  uploadType: UploadType;
  uploadedBy?: Maybe<User>;
  /** Link to the image on the site */
  url: Scalars['String'];
  views: Scalars['Int'];
  /** Width of the image in pixels. */
  width: Scalars['Int'];
};


export type ImageAppearancesArgs = {
  cursor?: Maybe<AppearanceWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  take?: Maybe<Scalars['Int']>;
};


export type ImageConnectionsArgs = {
  depth?: Scalars['Int'];
};


export type ImageTagsArgs = {
  cursor?: Maybe<TagWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  take?: Maybe<Scalars['Int']>;
};

export enum ImageConnectionEdge {
  ImageToPerson = 'IMAGE_TO_PERSON',
  PersonToImage = 'PERSON_TO_IMAGE'
}

export type ImageConnections = {
  __typename?: 'ImageConnections';
  edges: Array<ImageEdge>;
  images: Array<Image>;
  people: Array<Person>;
};

export type ImageCreateManyUserInput = {
  bytes?: Maybe<Scalars['Int']>;
  caption?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  faceScanDate?: Maybe<Scalars['DateTime']>;
  faceScanRequestDate?: Maybe<Scalars['DateTime']>;
  fileName?: Maybe<Scalars['String']>;
  hash: Scalars['String'];
  height: Scalars['Int'];
  id?: Maybe<Scalars['Int']>;
  ireneBotId?: Maybe<Scalars['Int']>;
  isNsfw?: Maybe<Scalars['Boolean']>;
  mimetype: MimeType;
  pHash?: Maybe<Scalars['String']>;
  palette?: Maybe<ImageCreateManypaletteInput>;
  public?: Maybe<Scalars['Boolean']>;
  slug: Scalars['String'];
  source?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  uploadType: UploadType;
  views?: Maybe<Scalars['Int']>;
  width: Scalars['Int'];
};

export type ImageCreateManyUserInputEnvelope = {
  data?: Maybe<Array<ImageCreateManyUserInput>>;
  skipDuplicates?: Maybe<Scalars['Boolean']>;
};

export type ImageCreateManypaletteInput = {
  set?: Maybe<Array<Scalars['Int']>>;
};

export type ImageCreateNestedManyWithoutUserInput = {
  connect?: Maybe<Array<ImageWhereUniqueInput>>;
  connectOrCreate?: Maybe<Array<ImageCreateOrConnectWithoutUserInput>>;
  create?: Maybe<Array<ImageCreateWithoutUserInput>>;
  createMany?: Maybe<ImageCreateManyUserInputEnvelope>;
};

export type ImageCreateNestedOneWithoutAppearancesInput = {
  connect?: Maybe<ImageWhereUniqueInput>;
  connectOrCreate?: Maybe<ImageCreateOrConnectWithoutAppearancesInput>;
  create?: Maybe<ImageCreateWithoutAppearancesInput>;
};

export type ImageCreateNestedOneWithoutAvatarOfInput = {
  connect?: Maybe<ImageWhereUniqueInput>;
  connectOrCreate?: Maybe<ImageCreateOrConnectWithoutAvatarOfInput>;
  create?: Maybe<ImageCreateWithoutAvatarOfInput>;
};

export type ImageCreateNestedOneWithoutBannerOfInput = {
  connect?: Maybe<ImageWhereUniqueInput>;
  connectOrCreate?: Maybe<ImageCreateOrConnectWithoutBannerOfInput>;
  create?: Maybe<ImageCreateWithoutBannerOfInput>;
};

export type ImageCreateNestedOneWithoutLikesInput = {
  connect?: Maybe<ImageWhereUniqueInput>;
  connectOrCreate?: Maybe<ImageCreateOrConnectWithoutLikesInput>;
  create?: Maybe<ImageCreateWithoutLikesInput>;
};

export type ImageCreateNestedOneWithoutTagsInput = {
  connect?: Maybe<ImageWhereUniqueInput>;
  connectOrCreate?: Maybe<ImageCreateOrConnectWithoutTagsInput>;
  create?: Maybe<ImageCreateWithoutTagsInput>;
};

export type ImageCreateOrConnectWithoutAppearancesInput = {
  create: ImageCreateWithoutAppearancesInput;
  where: ImageWhereUniqueInput;
};

export type ImageCreateOrConnectWithoutAvatarOfInput = {
  create: ImageCreateWithoutAvatarOfInput;
  where: ImageWhereUniqueInput;
};

export type ImageCreateOrConnectWithoutBannerOfInput = {
  create: ImageCreateWithoutBannerOfInput;
  where: ImageWhereUniqueInput;
};

export type ImageCreateOrConnectWithoutFacesInput = {
  create: ImageCreateWithoutFacesInput;
  where: ImageWhereUniqueInput;
};

export type ImageCreateOrConnectWithoutLikesInput = {
  create: ImageCreateWithoutLikesInput;
  where: ImageWhereUniqueInput;
};

export type ImageCreateOrConnectWithoutTagsInput = {
  create: ImageCreateWithoutTagsInput;
  where: ImageWhereUniqueInput;
};

export type ImageCreateOrConnectWithoutUserInput = {
  create: ImageCreateWithoutUserInput;
  where: ImageWhereUniqueInput;
};

export type ImageCreateWithoutAppearancesInput = {
  avatarOf?: Maybe<GroupCreateNestedOneWithoutAvatarInput>;
  bannerOf?: Maybe<GroupCreateNestedOneWithoutBannerInput>;
  bytes?: Maybe<Scalars['Int']>;
  caption?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  faceScanDate?: Maybe<Scalars['DateTime']>;
  faceScanRequestDate?: Maybe<Scalars['DateTime']>;
  faces?: Maybe<FaceCreateNestedManyWithoutImageInput>;
  fileName?: Maybe<Scalars['String']>;
  hash: Scalars['String'];
  height: Scalars['Int'];
  ireneBotId?: Maybe<Scalars['Int']>;
  isNsfw?: Maybe<Scalars['Boolean']>;
  likes?: Maybe<ImageLikeCreateNestedManyWithoutImageInput>;
  mimetype: MimeType;
  pHash?: Maybe<Scalars['String']>;
  palette?: Maybe<ImageCreatepaletteInput>;
  public?: Maybe<Scalars['Boolean']>;
  slug: Scalars['String'];
  source?: Maybe<Scalars['String']>;
  tags?: Maybe<TagCreateNestedManyWithoutImageInput>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  uploadType: UploadType;
  user?: Maybe<UserCreateNestedOneWithoutImagesInput>;
  views?: Maybe<Scalars['Int']>;
  width: Scalars['Int'];
};

export type ImageCreateWithoutAvatarOfInput = {
  appearances?: Maybe<AppearanceCreateNestedManyWithoutImageInput>;
  bannerOf?: Maybe<GroupCreateNestedOneWithoutBannerInput>;
  bytes?: Maybe<Scalars['Int']>;
  caption?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  faceScanDate?: Maybe<Scalars['DateTime']>;
  faceScanRequestDate?: Maybe<Scalars['DateTime']>;
  faces?: Maybe<FaceCreateNestedManyWithoutImageInput>;
  fileName?: Maybe<Scalars['String']>;
  hash: Scalars['String'];
  height: Scalars['Int'];
  ireneBotId?: Maybe<Scalars['Int']>;
  isNsfw?: Maybe<Scalars['Boolean']>;
  likes?: Maybe<ImageLikeCreateNestedManyWithoutImageInput>;
  mimetype: MimeType;
  pHash?: Maybe<Scalars['String']>;
  palette?: Maybe<ImageCreatepaletteInput>;
  public?: Maybe<Scalars['Boolean']>;
  slug: Scalars['String'];
  source?: Maybe<Scalars['String']>;
  tags?: Maybe<TagCreateNestedManyWithoutImageInput>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  uploadType: UploadType;
  user?: Maybe<UserCreateNestedOneWithoutImagesInput>;
  views?: Maybe<Scalars['Int']>;
  width: Scalars['Int'];
};

export type ImageCreateWithoutBannerOfInput = {
  appearances?: Maybe<AppearanceCreateNestedManyWithoutImageInput>;
  avatarOf?: Maybe<GroupCreateNestedOneWithoutAvatarInput>;
  bytes?: Maybe<Scalars['Int']>;
  caption?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  faceScanDate?: Maybe<Scalars['DateTime']>;
  faceScanRequestDate?: Maybe<Scalars['DateTime']>;
  faces?: Maybe<FaceCreateNestedManyWithoutImageInput>;
  fileName?: Maybe<Scalars['String']>;
  hash: Scalars['String'];
  height: Scalars['Int'];
  ireneBotId?: Maybe<Scalars['Int']>;
  isNsfw?: Maybe<Scalars['Boolean']>;
  likes?: Maybe<ImageLikeCreateNestedManyWithoutImageInput>;
  mimetype: MimeType;
  pHash?: Maybe<Scalars['String']>;
  palette?: Maybe<ImageCreatepaletteInput>;
  public?: Maybe<Scalars['Boolean']>;
  slug: Scalars['String'];
  source?: Maybe<Scalars['String']>;
  tags?: Maybe<TagCreateNestedManyWithoutImageInput>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  uploadType: UploadType;
  user?: Maybe<UserCreateNestedOneWithoutImagesInput>;
  views?: Maybe<Scalars['Int']>;
  width: Scalars['Int'];
};

export type ImageCreateWithoutFacesInput = {
  appearances?: Maybe<AppearanceCreateNestedManyWithoutImageInput>;
  avatarOf?: Maybe<GroupCreateNestedOneWithoutAvatarInput>;
  bannerOf?: Maybe<GroupCreateNestedOneWithoutBannerInput>;
  bytes?: Maybe<Scalars['Int']>;
  caption?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  faceScanDate?: Maybe<Scalars['DateTime']>;
  faceScanRequestDate?: Maybe<Scalars['DateTime']>;
  fileName?: Maybe<Scalars['String']>;
  hash: Scalars['String'];
  height: Scalars['Int'];
  ireneBotId?: Maybe<Scalars['Int']>;
  isNsfw?: Maybe<Scalars['Boolean']>;
  likes?: Maybe<ImageLikeCreateNestedManyWithoutImageInput>;
  mimetype: MimeType;
  pHash?: Maybe<Scalars['String']>;
  palette?: Maybe<ImageCreatepaletteInput>;
  public?: Maybe<Scalars['Boolean']>;
  slug: Scalars['String'];
  source?: Maybe<Scalars['String']>;
  tags?: Maybe<TagCreateNestedManyWithoutImageInput>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  uploadType: UploadType;
  user?: Maybe<UserCreateNestedOneWithoutImagesInput>;
  views?: Maybe<Scalars['Int']>;
  width: Scalars['Int'];
};

export type ImageCreateWithoutLikesInput = {
  appearances?: Maybe<AppearanceCreateNestedManyWithoutImageInput>;
  avatarOf?: Maybe<GroupCreateNestedOneWithoutAvatarInput>;
  bannerOf?: Maybe<GroupCreateNestedOneWithoutBannerInput>;
  bytes?: Maybe<Scalars['Int']>;
  caption?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  faceScanDate?: Maybe<Scalars['DateTime']>;
  faceScanRequestDate?: Maybe<Scalars['DateTime']>;
  faces?: Maybe<FaceCreateNestedManyWithoutImageInput>;
  fileName?: Maybe<Scalars['String']>;
  hash: Scalars['String'];
  height: Scalars['Int'];
  ireneBotId?: Maybe<Scalars['Int']>;
  isNsfw?: Maybe<Scalars['Boolean']>;
  mimetype: MimeType;
  pHash?: Maybe<Scalars['String']>;
  palette?: Maybe<ImageCreatepaletteInput>;
  public?: Maybe<Scalars['Boolean']>;
  slug: Scalars['String'];
  source?: Maybe<Scalars['String']>;
  tags?: Maybe<TagCreateNestedManyWithoutImageInput>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  uploadType: UploadType;
  user?: Maybe<UserCreateNestedOneWithoutImagesInput>;
  views?: Maybe<Scalars['Int']>;
  width: Scalars['Int'];
};

export type ImageCreateWithoutTagsInput = {
  appearances?: Maybe<AppearanceCreateNestedManyWithoutImageInput>;
  avatarOf?: Maybe<GroupCreateNestedOneWithoutAvatarInput>;
  bannerOf?: Maybe<GroupCreateNestedOneWithoutBannerInput>;
  bytes?: Maybe<Scalars['Int']>;
  caption?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  faceScanDate?: Maybe<Scalars['DateTime']>;
  faceScanRequestDate?: Maybe<Scalars['DateTime']>;
  faces?: Maybe<FaceCreateNestedManyWithoutImageInput>;
  fileName?: Maybe<Scalars['String']>;
  hash: Scalars['String'];
  height: Scalars['Int'];
  ireneBotId?: Maybe<Scalars['Int']>;
  isNsfw?: Maybe<Scalars['Boolean']>;
  likes?: Maybe<ImageLikeCreateNestedManyWithoutImageInput>;
  mimetype: MimeType;
  pHash?: Maybe<Scalars['String']>;
  palette?: Maybe<ImageCreatepaletteInput>;
  public?: Maybe<Scalars['Boolean']>;
  slug: Scalars['String'];
  source?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  uploadType: UploadType;
  user?: Maybe<UserCreateNestedOneWithoutImagesInput>;
  views?: Maybe<Scalars['Int']>;
  width: Scalars['Int'];
};

export type ImageCreateWithoutUserInput = {
  appearances?: Maybe<AppearanceCreateNestedManyWithoutImageInput>;
  avatarOf?: Maybe<GroupCreateNestedOneWithoutAvatarInput>;
  bannerOf?: Maybe<GroupCreateNestedOneWithoutBannerInput>;
  bytes?: Maybe<Scalars['Int']>;
  caption?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  faceScanDate?: Maybe<Scalars['DateTime']>;
  faceScanRequestDate?: Maybe<Scalars['DateTime']>;
  faces?: Maybe<FaceCreateNestedManyWithoutImageInput>;
  fileName?: Maybe<Scalars['String']>;
  hash: Scalars['String'];
  height: Scalars['Int'];
  ireneBotId?: Maybe<Scalars['Int']>;
  isNsfw?: Maybe<Scalars['Boolean']>;
  likes?: Maybe<ImageLikeCreateNestedManyWithoutImageInput>;
  mimetype: MimeType;
  pHash?: Maybe<Scalars['String']>;
  palette?: Maybe<ImageCreatepaletteInput>;
  public?: Maybe<Scalars['Boolean']>;
  slug: Scalars['String'];
  source?: Maybe<Scalars['String']>;
  tags?: Maybe<TagCreateNestedManyWithoutImageInput>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  uploadType: UploadType;
  views?: Maybe<Scalars['Int']>;
  width: Scalars['Int'];
};

export type ImageCreatepaletteInput = {
  set?: Maybe<Array<Scalars['Int']>>;
};

export type ImageEdge = {
  __typename?: 'ImageEdge';
  from: Scalars['Int'];
  to: Scalars['Int'];
  type?: Maybe<ImageConnectionEdge>;
};

export type ImageLikeCreateManyImageInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  userId: Scalars['Int'];
};

export type ImageLikeCreateManyImageInputEnvelope = {
  data?: Maybe<Array<ImageLikeCreateManyImageInput>>;
  skipDuplicates?: Maybe<Scalars['Boolean']>;
};

export type ImageLikeCreateManyUserInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  imageId: Scalars['Int'];
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type ImageLikeCreateManyUserInputEnvelope = {
  data?: Maybe<Array<ImageLikeCreateManyUserInput>>;
  skipDuplicates?: Maybe<Scalars['Boolean']>;
};

export type ImageLikeCreateNestedManyWithoutImageInput = {
  connect?: Maybe<Array<ImageLikeWhereUniqueInput>>;
  connectOrCreate?: Maybe<Array<ImageLikeCreateOrConnectWithoutImageInput>>;
  create?: Maybe<Array<ImageLikeCreateWithoutImageInput>>;
  createMany?: Maybe<ImageLikeCreateManyImageInputEnvelope>;
};

export type ImageLikeCreateNestedManyWithoutUserInput = {
  connect?: Maybe<Array<ImageLikeWhereUniqueInput>>;
  connectOrCreate?: Maybe<Array<ImageLikeCreateOrConnectWithoutUserInput>>;
  create?: Maybe<Array<ImageLikeCreateWithoutUserInput>>;
  createMany?: Maybe<ImageLikeCreateManyUserInputEnvelope>;
};

export type ImageLikeCreateOrConnectWithoutImageInput = {
  create: ImageLikeCreateWithoutImageInput;
  where: ImageLikeWhereUniqueInput;
};

export type ImageLikeCreateOrConnectWithoutUserInput = {
  create: ImageLikeCreateWithoutUserInput;
  where: ImageLikeWhereUniqueInput;
};

export type ImageLikeCreateWithoutImageInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
  user: UserCreateNestedOneWithoutImageLikesInput;
};

export type ImageLikeCreateWithoutUserInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  image: ImageCreateNestedOneWithoutLikesInput;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type ImageLikeLikedImageCompoundUniqueInput = {
  imageId: Scalars['Int'];
  userId: Scalars['Int'];
};

export type ImageLikeListRelationFilter = {
  every?: Maybe<ImageLikeWhereInput>;
  none?: Maybe<ImageLikeWhereInput>;
  some?: Maybe<ImageLikeWhereInput>;
};

export type ImageLikeScalarWhereInput = {
  AND?: Maybe<Array<ImageLikeScalarWhereInput>>;
  NOT?: Maybe<Array<ImageLikeScalarWhereInput>>;
  OR?: Maybe<Array<ImageLikeScalarWhereInput>>;
  createdAt?: Maybe<DateTimeFilter>;
  id?: Maybe<IntFilter>;
  imageId?: Maybe<IntFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
  userId?: Maybe<IntFilter>;
};

export type ImageLikeUpdateManyMutationInput = {
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  updatedAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
};

export type ImageLikeUpdateManyWithWhereWithoutImageInput = {
  data: ImageLikeUpdateManyMutationInput;
  where: ImageLikeScalarWhereInput;
};

export type ImageLikeUpdateManyWithWhereWithoutUserInput = {
  data: ImageLikeUpdateManyMutationInput;
  where: ImageLikeScalarWhereInput;
};

export type ImageLikeUpdateManyWithoutImageInput = {
  connect?: Maybe<Array<ImageLikeWhereUniqueInput>>;
  connectOrCreate?: Maybe<Array<ImageLikeCreateOrConnectWithoutImageInput>>;
  create?: Maybe<Array<ImageLikeCreateWithoutImageInput>>;
  createMany?: Maybe<ImageLikeCreateManyImageInputEnvelope>;
  delete?: Maybe<Array<ImageLikeWhereUniqueInput>>;
  deleteMany?: Maybe<Array<ImageLikeScalarWhereInput>>;
  disconnect?: Maybe<Array<ImageLikeWhereUniqueInput>>;
  set?: Maybe<Array<ImageLikeWhereUniqueInput>>;
  update?: Maybe<Array<ImageLikeUpdateWithWhereUniqueWithoutImageInput>>;
  updateMany?: Maybe<Array<ImageLikeUpdateManyWithWhereWithoutImageInput>>;
  upsert?: Maybe<Array<ImageLikeUpsertWithWhereUniqueWithoutImageInput>>;
};

export type ImageLikeUpdateManyWithoutUserInput = {
  connect?: Maybe<Array<ImageLikeWhereUniqueInput>>;
  connectOrCreate?: Maybe<Array<ImageLikeCreateOrConnectWithoutUserInput>>;
  create?: Maybe<Array<ImageLikeCreateWithoutUserInput>>;
  createMany?: Maybe<ImageLikeCreateManyUserInputEnvelope>;
  delete?: Maybe<Array<ImageLikeWhereUniqueInput>>;
  deleteMany?: Maybe<Array<ImageLikeScalarWhereInput>>;
  disconnect?: Maybe<Array<ImageLikeWhereUniqueInput>>;
  set?: Maybe<Array<ImageLikeWhereUniqueInput>>;
  update?: Maybe<Array<ImageLikeUpdateWithWhereUniqueWithoutUserInput>>;
  updateMany?: Maybe<Array<ImageLikeUpdateManyWithWhereWithoutUserInput>>;
  upsert?: Maybe<Array<ImageLikeUpsertWithWhereUniqueWithoutUserInput>>;
};

export type ImageLikeUpdateWithWhereUniqueWithoutImageInput = {
  data: ImageLikeUpdateWithoutImageInput;
  where: ImageLikeWhereUniqueInput;
};

export type ImageLikeUpdateWithWhereUniqueWithoutUserInput = {
  data: ImageLikeUpdateWithoutUserInput;
  where: ImageLikeWhereUniqueInput;
};

export type ImageLikeUpdateWithoutImageInput = {
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  updatedAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  user?: Maybe<UserUpdateOneRequiredWithoutImageLikesInput>;
};

export type ImageLikeUpdateWithoutUserInput = {
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  image?: Maybe<ImageUpdateOneRequiredWithoutLikesInput>;
  updatedAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
};

export type ImageLikeUpsertWithWhereUniqueWithoutImageInput = {
  create: ImageLikeCreateWithoutImageInput;
  update: ImageLikeUpdateWithoutImageInput;
  where: ImageLikeWhereUniqueInput;
};

export type ImageLikeUpsertWithWhereUniqueWithoutUserInput = {
  create: ImageLikeCreateWithoutUserInput;
  update: ImageLikeUpdateWithoutUserInput;
  where: ImageLikeWhereUniqueInput;
};

export type ImageLikeWhereInput = {
  AND?: Maybe<Array<ImageLikeWhereInput>>;
  NOT?: Maybe<Array<ImageLikeWhereInput>>;
  OR?: Maybe<Array<ImageLikeWhereInput>>;
  createdAt?: Maybe<DateTimeFilter>;
  id?: Maybe<IntFilter>;
  image?: Maybe<ImageWhereInput>;
  imageId?: Maybe<IntFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
  user?: Maybe<UserWhereInput>;
  userId?: Maybe<IntFilter>;
};

export type ImageLikeWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
  likedImage?: Maybe<ImageLikeLikedImageCompoundUniqueInput>;
};

export type ImageListRelationFilter = {
  every?: Maybe<ImageWhereInput>;
  none?: Maybe<ImageWhereInput>;
  some?: Maybe<ImageWhereInput>;
};

export type ImageOrderByInput = {
  bytes?: Maybe<SortOrder>;
  caption?: Maybe<SortOrder>;
  createdAt?: Maybe<SortOrder>;
  faceScanDate?: Maybe<SortOrder>;
  faceScanRequestDate?: Maybe<SortOrder>;
  fileName?: Maybe<SortOrder>;
  hash?: Maybe<SortOrder>;
  height?: Maybe<SortOrder>;
  id?: Maybe<SortOrder>;
  ireneBotId?: Maybe<SortOrder>;
  isNsfw?: Maybe<SortOrder>;
  mimetype?: Maybe<SortOrder>;
  pHash?: Maybe<SortOrder>;
  palette?: Maybe<SortOrder>;
  public?: Maybe<SortOrder>;
  slug?: Maybe<SortOrder>;
  source?: Maybe<SortOrder>;
  updatedAt?: Maybe<SortOrder>;
  uploadType?: Maybe<SortOrder>;
  userId?: Maybe<SortOrder>;
  views?: Maybe<SortOrder>;
  width?: Maybe<SortOrder>;
};

export type ImageScalarWhereInput = {
  AND?: Maybe<Array<ImageScalarWhereInput>>;
  NOT?: Maybe<Array<ImageScalarWhereInput>>;
  OR?: Maybe<Array<ImageScalarWhereInput>>;
  bytes?: Maybe<IntFilter>;
  caption?: Maybe<StringNullableFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  faceScanDate?: Maybe<DateTimeNullableFilter>;
  faceScanRequestDate?: Maybe<DateTimeNullableFilter>;
  fileName?: Maybe<StringNullableFilter>;
  hash?: Maybe<StringFilter>;
  height?: Maybe<IntFilter>;
  id?: Maybe<IntFilter>;
  ireneBotId?: Maybe<IntNullableFilter>;
  isNsfw?: Maybe<BoolFilter>;
  mimetype?: Maybe<EnumMimeTypeFilter>;
  pHash?: Maybe<StringNullableFilter>;
  palette?: Maybe<IntNullableListFilter>;
  public?: Maybe<BoolFilter>;
  slug?: Maybe<StringFilter>;
  source?: Maybe<StringNullableFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
  uploadType?: Maybe<EnumUploadTypeFilter>;
  userId?: Maybe<IntNullableFilter>;
  views?: Maybe<IntFilter>;
  width?: Maybe<IntFilter>;
};

export type ImageUpdateManyMutationInput = {
  bytes?: Maybe<IntFieldUpdateOperationsInput>;
  caption?: Maybe<NullableStringFieldUpdateOperationsInput>;
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  faceScanDate?: Maybe<NullableDateTimeFieldUpdateOperationsInput>;
  faceScanRequestDate?: Maybe<NullableDateTimeFieldUpdateOperationsInput>;
  fileName?: Maybe<NullableStringFieldUpdateOperationsInput>;
  hash?: Maybe<StringFieldUpdateOperationsInput>;
  height?: Maybe<IntFieldUpdateOperationsInput>;
  ireneBotId?: Maybe<NullableIntFieldUpdateOperationsInput>;
  isNsfw?: Maybe<BoolFieldUpdateOperationsInput>;
  mimetype?: Maybe<EnumMimeTypeFieldUpdateOperationsInput>;
  pHash?: Maybe<NullableStringFieldUpdateOperationsInput>;
  palette?: Maybe<ImageUpdatepaletteInput>;
  public?: Maybe<BoolFieldUpdateOperationsInput>;
  slug?: Maybe<StringFieldUpdateOperationsInput>;
  source?: Maybe<NullableStringFieldUpdateOperationsInput>;
  updatedAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  uploadType?: Maybe<EnumUploadTypeFieldUpdateOperationsInput>;
  views?: Maybe<IntFieldUpdateOperationsInput>;
  width?: Maybe<IntFieldUpdateOperationsInput>;
};

export type ImageUpdateManyWithWhereWithoutUserInput = {
  data: ImageUpdateManyMutationInput;
  where: ImageScalarWhereInput;
};

export type ImageUpdateManyWithoutUserInput = {
  connect?: Maybe<Array<ImageWhereUniqueInput>>;
  connectOrCreate?: Maybe<Array<ImageCreateOrConnectWithoutUserInput>>;
  create?: Maybe<Array<ImageCreateWithoutUserInput>>;
  createMany?: Maybe<ImageCreateManyUserInputEnvelope>;
  delete?: Maybe<Array<ImageWhereUniqueInput>>;
  deleteMany?: Maybe<Array<ImageScalarWhereInput>>;
  disconnect?: Maybe<Array<ImageWhereUniqueInput>>;
  set?: Maybe<Array<ImageWhereUniqueInput>>;
  update?: Maybe<Array<ImageUpdateWithWhereUniqueWithoutUserInput>>;
  updateMany?: Maybe<Array<ImageUpdateManyWithWhereWithoutUserInput>>;
  upsert?: Maybe<Array<ImageUpsertWithWhereUniqueWithoutUserInput>>;
};

export type ImageUpdateOneRequiredWithoutAppearancesInput = {
  connect?: Maybe<ImageWhereUniqueInput>;
  connectOrCreate?: Maybe<ImageCreateOrConnectWithoutAppearancesInput>;
  create?: Maybe<ImageCreateWithoutAppearancesInput>;
  update?: Maybe<ImageUpdateWithoutAppearancesInput>;
  upsert?: Maybe<ImageUpsertWithoutAppearancesInput>;
};

export type ImageUpdateOneRequiredWithoutFacesInput = {
  connect?: Maybe<ImageWhereUniqueInput>;
  connectOrCreate?: Maybe<ImageCreateOrConnectWithoutFacesInput>;
  create?: Maybe<ImageCreateWithoutFacesInput>;
  update?: Maybe<ImageUpdateWithoutFacesInput>;
  upsert?: Maybe<ImageUpsertWithoutFacesInput>;
};

export type ImageUpdateOneRequiredWithoutLikesInput = {
  connect?: Maybe<ImageWhereUniqueInput>;
  connectOrCreate?: Maybe<ImageCreateOrConnectWithoutLikesInput>;
  create?: Maybe<ImageCreateWithoutLikesInput>;
  update?: Maybe<ImageUpdateWithoutLikesInput>;
  upsert?: Maybe<ImageUpsertWithoutLikesInput>;
};

export type ImageUpdateOneRequiredWithoutTagsInput = {
  connect?: Maybe<ImageWhereUniqueInput>;
  connectOrCreate?: Maybe<ImageCreateOrConnectWithoutTagsInput>;
  create?: Maybe<ImageCreateWithoutTagsInput>;
  update?: Maybe<ImageUpdateWithoutTagsInput>;
  upsert?: Maybe<ImageUpsertWithoutTagsInput>;
};

export type ImageUpdateOneWithoutAvatarOfInput = {
  connect?: Maybe<ImageWhereUniqueInput>;
  connectOrCreate?: Maybe<ImageCreateOrConnectWithoutAvatarOfInput>;
  create?: Maybe<ImageCreateWithoutAvatarOfInput>;
  delete?: Maybe<Scalars['Boolean']>;
  disconnect?: Maybe<Scalars['Boolean']>;
  update?: Maybe<ImageUpdateWithoutAvatarOfInput>;
  upsert?: Maybe<ImageUpsertWithoutAvatarOfInput>;
};

export type ImageUpdateOneWithoutBannerOfInput = {
  connect?: Maybe<ImageWhereUniqueInput>;
  connectOrCreate?: Maybe<ImageCreateOrConnectWithoutBannerOfInput>;
  create?: Maybe<ImageCreateWithoutBannerOfInput>;
  delete?: Maybe<Scalars['Boolean']>;
  disconnect?: Maybe<Scalars['Boolean']>;
  update?: Maybe<ImageUpdateWithoutBannerOfInput>;
  upsert?: Maybe<ImageUpsertWithoutBannerOfInput>;
};

export type ImageUpdateWithWhereUniqueWithoutUserInput = {
  data: ImageUpdateWithoutUserInput;
  where: ImageWhereUniqueInput;
};

export type ImageUpdateWithoutAppearancesInput = {
  avatarOf?: Maybe<GroupUpdateOneWithoutAvatarInput>;
  bannerOf?: Maybe<GroupUpdateOneWithoutBannerInput>;
  bytes?: Maybe<IntFieldUpdateOperationsInput>;
  caption?: Maybe<NullableStringFieldUpdateOperationsInput>;
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  faceScanDate?: Maybe<NullableDateTimeFieldUpdateOperationsInput>;
  faceScanRequestDate?: Maybe<NullableDateTimeFieldUpdateOperationsInput>;
  faces?: Maybe<FaceUpdateManyWithoutImageInput>;
  fileName?: Maybe<NullableStringFieldUpdateOperationsInput>;
  hash?: Maybe<StringFieldUpdateOperationsInput>;
  height?: Maybe<IntFieldUpdateOperationsInput>;
  ireneBotId?: Maybe<NullableIntFieldUpdateOperationsInput>;
  isNsfw?: Maybe<BoolFieldUpdateOperationsInput>;
  likes?: Maybe<ImageLikeUpdateManyWithoutImageInput>;
  mimetype?: Maybe<EnumMimeTypeFieldUpdateOperationsInput>;
  pHash?: Maybe<NullableStringFieldUpdateOperationsInput>;
  palette?: Maybe<ImageUpdatepaletteInput>;
  public?: Maybe<BoolFieldUpdateOperationsInput>;
  slug?: Maybe<StringFieldUpdateOperationsInput>;
  source?: Maybe<NullableStringFieldUpdateOperationsInput>;
  tags?: Maybe<TagUpdateManyWithoutImageInput>;
  updatedAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  uploadType?: Maybe<EnumUploadTypeFieldUpdateOperationsInput>;
  user?: Maybe<UserUpdateOneWithoutImagesInput>;
  views?: Maybe<IntFieldUpdateOperationsInput>;
  width?: Maybe<IntFieldUpdateOperationsInput>;
};

export type ImageUpdateWithoutAvatarOfInput = {
  appearances?: Maybe<AppearanceUpdateManyWithoutImageInput>;
  bannerOf?: Maybe<GroupUpdateOneWithoutBannerInput>;
  bytes?: Maybe<IntFieldUpdateOperationsInput>;
  caption?: Maybe<NullableStringFieldUpdateOperationsInput>;
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  faceScanDate?: Maybe<NullableDateTimeFieldUpdateOperationsInput>;
  faceScanRequestDate?: Maybe<NullableDateTimeFieldUpdateOperationsInput>;
  faces?: Maybe<FaceUpdateManyWithoutImageInput>;
  fileName?: Maybe<NullableStringFieldUpdateOperationsInput>;
  hash?: Maybe<StringFieldUpdateOperationsInput>;
  height?: Maybe<IntFieldUpdateOperationsInput>;
  ireneBotId?: Maybe<NullableIntFieldUpdateOperationsInput>;
  isNsfw?: Maybe<BoolFieldUpdateOperationsInput>;
  likes?: Maybe<ImageLikeUpdateManyWithoutImageInput>;
  mimetype?: Maybe<EnumMimeTypeFieldUpdateOperationsInput>;
  pHash?: Maybe<NullableStringFieldUpdateOperationsInput>;
  palette?: Maybe<ImageUpdatepaletteInput>;
  public?: Maybe<BoolFieldUpdateOperationsInput>;
  slug?: Maybe<StringFieldUpdateOperationsInput>;
  source?: Maybe<NullableStringFieldUpdateOperationsInput>;
  tags?: Maybe<TagUpdateManyWithoutImageInput>;
  updatedAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  uploadType?: Maybe<EnumUploadTypeFieldUpdateOperationsInput>;
  user?: Maybe<UserUpdateOneWithoutImagesInput>;
  views?: Maybe<IntFieldUpdateOperationsInput>;
  width?: Maybe<IntFieldUpdateOperationsInput>;
};

export type ImageUpdateWithoutBannerOfInput = {
  appearances?: Maybe<AppearanceUpdateManyWithoutImageInput>;
  avatarOf?: Maybe<GroupUpdateOneWithoutAvatarInput>;
  bytes?: Maybe<IntFieldUpdateOperationsInput>;
  caption?: Maybe<NullableStringFieldUpdateOperationsInput>;
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  faceScanDate?: Maybe<NullableDateTimeFieldUpdateOperationsInput>;
  faceScanRequestDate?: Maybe<NullableDateTimeFieldUpdateOperationsInput>;
  faces?: Maybe<FaceUpdateManyWithoutImageInput>;
  fileName?: Maybe<NullableStringFieldUpdateOperationsInput>;
  hash?: Maybe<StringFieldUpdateOperationsInput>;
  height?: Maybe<IntFieldUpdateOperationsInput>;
  ireneBotId?: Maybe<NullableIntFieldUpdateOperationsInput>;
  isNsfw?: Maybe<BoolFieldUpdateOperationsInput>;
  likes?: Maybe<ImageLikeUpdateManyWithoutImageInput>;
  mimetype?: Maybe<EnumMimeTypeFieldUpdateOperationsInput>;
  pHash?: Maybe<NullableStringFieldUpdateOperationsInput>;
  palette?: Maybe<ImageUpdatepaletteInput>;
  public?: Maybe<BoolFieldUpdateOperationsInput>;
  slug?: Maybe<StringFieldUpdateOperationsInput>;
  source?: Maybe<NullableStringFieldUpdateOperationsInput>;
  tags?: Maybe<TagUpdateManyWithoutImageInput>;
  updatedAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  uploadType?: Maybe<EnumUploadTypeFieldUpdateOperationsInput>;
  user?: Maybe<UserUpdateOneWithoutImagesInput>;
  views?: Maybe<IntFieldUpdateOperationsInput>;
  width?: Maybe<IntFieldUpdateOperationsInput>;
};

export type ImageUpdateWithoutFacesInput = {
  appearances?: Maybe<AppearanceUpdateManyWithoutImageInput>;
  avatarOf?: Maybe<GroupUpdateOneWithoutAvatarInput>;
  bannerOf?: Maybe<GroupUpdateOneWithoutBannerInput>;
  bytes?: Maybe<IntFieldUpdateOperationsInput>;
  caption?: Maybe<NullableStringFieldUpdateOperationsInput>;
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  faceScanDate?: Maybe<NullableDateTimeFieldUpdateOperationsInput>;
  faceScanRequestDate?: Maybe<NullableDateTimeFieldUpdateOperationsInput>;
  fileName?: Maybe<NullableStringFieldUpdateOperationsInput>;
  hash?: Maybe<StringFieldUpdateOperationsInput>;
  height?: Maybe<IntFieldUpdateOperationsInput>;
  ireneBotId?: Maybe<NullableIntFieldUpdateOperationsInput>;
  isNsfw?: Maybe<BoolFieldUpdateOperationsInput>;
  likes?: Maybe<ImageLikeUpdateManyWithoutImageInput>;
  mimetype?: Maybe<EnumMimeTypeFieldUpdateOperationsInput>;
  pHash?: Maybe<NullableStringFieldUpdateOperationsInput>;
  palette?: Maybe<ImageUpdatepaletteInput>;
  public?: Maybe<BoolFieldUpdateOperationsInput>;
  slug?: Maybe<StringFieldUpdateOperationsInput>;
  source?: Maybe<NullableStringFieldUpdateOperationsInput>;
  tags?: Maybe<TagUpdateManyWithoutImageInput>;
  updatedAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  uploadType?: Maybe<EnumUploadTypeFieldUpdateOperationsInput>;
  user?: Maybe<UserUpdateOneWithoutImagesInput>;
  views?: Maybe<IntFieldUpdateOperationsInput>;
  width?: Maybe<IntFieldUpdateOperationsInput>;
};

export type ImageUpdateWithoutLikesInput = {
  appearances?: Maybe<AppearanceUpdateManyWithoutImageInput>;
  avatarOf?: Maybe<GroupUpdateOneWithoutAvatarInput>;
  bannerOf?: Maybe<GroupUpdateOneWithoutBannerInput>;
  bytes?: Maybe<IntFieldUpdateOperationsInput>;
  caption?: Maybe<NullableStringFieldUpdateOperationsInput>;
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  faceScanDate?: Maybe<NullableDateTimeFieldUpdateOperationsInput>;
  faceScanRequestDate?: Maybe<NullableDateTimeFieldUpdateOperationsInput>;
  faces?: Maybe<FaceUpdateManyWithoutImageInput>;
  fileName?: Maybe<NullableStringFieldUpdateOperationsInput>;
  hash?: Maybe<StringFieldUpdateOperationsInput>;
  height?: Maybe<IntFieldUpdateOperationsInput>;
  ireneBotId?: Maybe<NullableIntFieldUpdateOperationsInput>;
  isNsfw?: Maybe<BoolFieldUpdateOperationsInput>;
  mimetype?: Maybe<EnumMimeTypeFieldUpdateOperationsInput>;
  pHash?: Maybe<NullableStringFieldUpdateOperationsInput>;
  palette?: Maybe<ImageUpdatepaletteInput>;
  public?: Maybe<BoolFieldUpdateOperationsInput>;
  slug?: Maybe<StringFieldUpdateOperationsInput>;
  source?: Maybe<NullableStringFieldUpdateOperationsInput>;
  tags?: Maybe<TagUpdateManyWithoutImageInput>;
  updatedAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  uploadType?: Maybe<EnumUploadTypeFieldUpdateOperationsInput>;
  user?: Maybe<UserUpdateOneWithoutImagesInput>;
  views?: Maybe<IntFieldUpdateOperationsInput>;
  width?: Maybe<IntFieldUpdateOperationsInput>;
};

export type ImageUpdateWithoutTagsInput = {
  appearances?: Maybe<AppearanceUpdateManyWithoutImageInput>;
  avatarOf?: Maybe<GroupUpdateOneWithoutAvatarInput>;
  bannerOf?: Maybe<GroupUpdateOneWithoutBannerInput>;
  bytes?: Maybe<IntFieldUpdateOperationsInput>;
  caption?: Maybe<NullableStringFieldUpdateOperationsInput>;
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  faceScanDate?: Maybe<NullableDateTimeFieldUpdateOperationsInput>;
  faceScanRequestDate?: Maybe<NullableDateTimeFieldUpdateOperationsInput>;
  faces?: Maybe<FaceUpdateManyWithoutImageInput>;
  fileName?: Maybe<NullableStringFieldUpdateOperationsInput>;
  hash?: Maybe<StringFieldUpdateOperationsInput>;
  height?: Maybe<IntFieldUpdateOperationsInput>;
  ireneBotId?: Maybe<NullableIntFieldUpdateOperationsInput>;
  isNsfw?: Maybe<BoolFieldUpdateOperationsInput>;
  likes?: Maybe<ImageLikeUpdateManyWithoutImageInput>;
  mimetype?: Maybe<EnumMimeTypeFieldUpdateOperationsInput>;
  pHash?: Maybe<NullableStringFieldUpdateOperationsInput>;
  palette?: Maybe<ImageUpdatepaletteInput>;
  public?: Maybe<BoolFieldUpdateOperationsInput>;
  slug?: Maybe<StringFieldUpdateOperationsInput>;
  source?: Maybe<NullableStringFieldUpdateOperationsInput>;
  updatedAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  uploadType?: Maybe<EnumUploadTypeFieldUpdateOperationsInput>;
  user?: Maybe<UserUpdateOneWithoutImagesInput>;
  views?: Maybe<IntFieldUpdateOperationsInput>;
  width?: Maybe<IntFieldUpdateOperationsInput>;
};

export type ImageUpdateWithoutUserInput = {
  appearances?: Maybe<AppearanceUpdateManyWithoutImageInput>;
  avatarOf?: Maybe<GroupUpdateOneWithoutAvatarInput>;
  bannerOf?: Maybe<GroupUpdateOneWithoutBannerInput>;
  bytes?: Maybe<IntFieldUpdateOperationsInput>;
  caption?: Maybe<NullableStringFieldUpdateOperationsInput>;
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  faceScanDate?: Maybe<NullableDateTimeFieldUpdateOperationsInput>;
  faceScanRequestDate?: Maybe<NullableDateTimeFieldUpdateOperationsInput>;
  faces?: Maybe<FaceUpdateManyWithoutImageInput>;
  fileName?: Maybe<NullableStringFieldUpdateOperationsInput>;
  hash?: Maybe<StringFieldUpdateOperationsInput>;
  height?: Maybe<IntFieldUpdateOperationsInput>;
  ireneBotId?: Maybe<NullableIntFieldUpdateOperationsInput>;
  isNsfw?: Maybe<BoolFieldUpdateOperationsInput>;
  likes?: Maybe<ImageLikeUpdateManyWithoutImageInput>;
  mimetype?: Maybe<EnumMimeTypeFieldUpdateOperationsInput>;
  pHash?: Maybe<NullableStringFieldUpdateOperationsInput>;
  palette?: Maybe<ImageUpdatepaletteInput>;
  public?: Maybe<BoolFieldUpdateOperationsInput>;
  slug?: Maybe<StringFieldUpdateOperationsInput>;
  source?: Maybe<NullableStringFieldUpdateOperationsInput>;
  tags?: Maybe<TagUpdateManyWithoutImageInput>;
  updatedAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  uploadType?: Maybe<EnumUploadTypeFieldUpdateOperationsInput>;
  views?: Maybe<IntFieldUpdateOperationsInput>;
  width?: Maybe<IntFieldUpdateOperationsInput>;
};

export type ImageUpdatepaletteInput = {
  push?: Maybe<Scalars['Int']>;
  set?: Maybe<Array<Scalars['Int']>>;
};

export type ImageUpsertWithWhereUniqueWithoutUserInput = {
  create: ImageCreateWithoutUserInput;
  update: ImageUpdateWithoutUserInput;
  where: ImageWhereUniqueInput;
};

export type ImageUpsertWithoutAppearancesInput = {
  create: ImageCreateWithoutAppearancesInput;
  update: ImageUpdateWithoutAppearancesInput;
};

export type ImageUpsertWithoutAvatarOfInput = {
  create: ImageCreateWithoutAvatarOfInput;
  update: ImageUpdateWithoutAvatarOfInput;
};

export type ImageUpsertWithoutBannerOfInput = {
  create: ImageCreateWithoutBannerOfInput;
  update: ImageUpdateWithoutBannerOfInput;
};

export type ImageUpsertWithoutFacesInput = {
  create: ImageCreateWithoutFacesInput;
  update: ImageUpdateWithoutFacesInput;
};

export type ImageUpsertWithoutLikesInput = {
  create: ImageCreateWithoutLikesInput;
  update: ImageUpdateWithoutLikesInput;
};

export type ImageUpsertWithoutTagsInput = {
  create: ImageCreateWithoutTagsInput;
  update: ImageUpdateWithoutTagsInput;
};

export type ImageWhereInput = {
  AND?: Maybe<Array<ImageWhereInput>>;
  NOT?: Maybe<Array<ImageWhereInput>>;
  OR?: Maybe<Array<ImageWhereInput>>;
  appearances?: Maybe<AppearanceListRelationFilter>;
  avatarOf?: Maybe<GroupWhereInput>;
  bannerOf?: Maybe<GroupWhereInput>;
  bytes?: Maybe<IntFilter>;
  caption?: Maybe<StringNullableFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  faceScanDate?: Maybe<DateTimeNullableFilter>;
  faceScanRequestDate?: Maybe<DateTimeNullableFilter>;
  faces?: Maybe<FaceListRelationFilter>;
  fileName?: Maybe<StringNullableFilter>;
  hash?: Maybe<StringFilter>;
  height?: Maybe<IntFilter>;
  id?: Maybe<IntFilter>;
  ireneBotId?: Maybe<IntNullableFilter>;
  isNsfw?: Maybe<BoolFilter>;
  likes?: Maybe<ImageLikeListRelationFilter>;
  mimetype?: Maybe<EnumMimeTypeFilter>;
  pHash?: Maybe<StringNullableFilter>;
  palette?: Maybe<IntNullableListFilter>;
  public?: Maybe<BoolFilter>;
  slug?: Maybe<StringFilter>;
  source?: Maybe<StringNullableFilter>;
  tags?: Maybe<TagListRelationFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
  uploadType?: Maybe<EnumUploadTypeFilter>;
  user?: Maybe<UserWhereInput>;
  userId?: Maybe<IntNullableFilter>;
  views?: Maybe<IntFilter>;
  width?: Maybe<IntFilter>;
};

export type ImageWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
  ireneBotId?: Maybe<Scalars['Int']>;
  slug?: Maybe<Scalars['String']>;
};

export type IntFieldUpdateOperationsInput = {
  decrement?: Maybe<Scalars['Int']>;
  divide?: Maybe<Scalars['Int']>;
  increment?: Maybe<Scalars['Int']>;
  multiply?: Maybe<Scalars['Int']>;
  set?: Maybe<Scalars['Int']>;
};

export type IntFilter = {
  equals?: Maybe<Scalars['Int']>;
  gt?: Maybe<Scalars['Int']>;
  gte?: Maybe<Scalars['Int']>;
  in?: Maybe<Array<Scalars['Int']>>;
  lt?: Maybe<Scalars['Int']>;
  lte?: Maybe<Scalars['Int']>;
  not?: Maybe<NestedIntFilter>;
  notIn?: Maybe<Array<Scalars['Int']>>;
};

export type IntNullableFilter = {
  equals?: Maybe<Scalars['Int']>;
  gt?: Maybe<Scalars['Int']>;
  gte?: Maybe<Scalars['Int']>;
  in?: Maybe<Array<Scalars['Int']>>;
  lt?: Maybe<Scalars['Int']>;
  lte?: Maybe<Scalars['Int']>;
  not?: Maybe<NestedIntNullableFilter>;
  notIn?: Maybe<Array<Scalars['Int']>>;
};

export type IntNullableListFilter = {
  equals?: Maybe<Array<Scalars['Int']>>;
  has?: Maybe<Scalars['Int']>;
  hasEvery?: Maybe<Array<Scalars['Int']>>;
  hasSome?: Maybe<Array<Scalars['Int']>>;
  isEmpty?: Maybe<Scalars['Boolean']>;
};

export enum MimeType {
  Avif = 'AVIF',
  Gif = 'GIF',
  Jpg = 'JPG',
  Mp4 = 'MP4',
  Png = 'PNG',
  Svg = 'SVG',
  Webm = 'WEBM',
  Webp = 'WEBP'
}

export type Mutation = {
  __typename?: 'Mutation';
  /** Add an appearance relation on an image. */
  addAppearance: Appearance;
  createOnePerson: Person;
  /** Add metadata labels to an existing image. Only available to bot accounts */
  labelImage?: Maybe<Image>;
  /** Attach an existing face to an apperance. */
  linkFace: Appearance;
  /** Removes an appearance from an image */
  removeAppearance: Appearance;
  /** Queue an image to get scanned for faces */
  scanFaces: QueueInfo;
  toggleLike: Image;
  /** Unlinks an existing face from an appearance. This dissociates the face from the appearance but does not remove the face data */
  unlinkFace: Scalars['Int'];
  upsertOneGroup: Group;
  upsertOnePerson: Person;
};


export type MutationAddAppearanceArgs = {
  imageId: Scalars['Int'];
  personId: Scalars['Int'];
};


export type MutationCreateOnePersonArgs = {
  data: PersonCreateInput;
};


export type MutationLabelImageArgs = {
  faces: Array<FaceInput>;
  ireneBotId?: Maybe<Scalars['Int']>;
  pHash?: Maybe<Scalars['String']>;
  palette: Array<Scalars['Int']>;
  personName?: Maybe<Scalars['String']>;
  replacePreviousScan?: Maybe<Scalars['Boolean']>;
  slug: Scalars['String'];
};


export type MutationLinkFaceArgs = {
  appearanceId: Scalars['Int'];
  faceId: Scalars['Int'];
};


export type MutationRemoveAppearanceArgs = {
  appearanceId: Scalars['Int'];
};


export type MutationScanFacesArgs = {
  slug: Scalars['String'];
};


export type MutationToggleLikeArgs = {
  imageId: Scalars['Int'];
};


export type MutationUnlinkFaceArgs = {
  appearanceId: Scalars['Int'];
  faceId: Scalars['Int'];
};


export type MutationUpsertOneGroupArgs = {
  create: GroupCreateInput;
  update: GroupUpdateInput;
  where: GroupWhereUniqueInput;
};


export type MutationUpsertOnePersonArgs = {
  create: PersonCreateInput;
  update: PersonUpdateInput;
  where: PersonWhereUniqueInput;
};

export type NestedBoolFilter = {
  equals?: Maybe<Scalars['Boolean']>;
  not?: Maybe<NestedBoolFilter>;
};

export type NestedDateTimeFilter = {
  equals?: Maybe<Scalars['DateTime']>;
  gt?: Maybe<Scalars['DateTime']>;
  gte?: Maybe<Scalars['DateTime']>;
  in?: Maybe<Array<Scalars['DateTime']>>;
  lt?: Maybe<Scalars['DateTime']>;
  lte?: Maybe<Scalars['DateTime']>;
  not?: Maybe<NestedDateTimeFilter>;
  notIn?: Maybe<Array<Scalars['DateTime']>>;
};

export type NestedDateTimeNullableFilter = {
  equals?: Maybe<Scalars['DateTime']>;
  gt?: Maybe<Scalars['DateTime']>;
  gte?: Maybe<Scalars['DateTime']>;
  in?: Maybe<Array<Scalars['DateTime']>>;
  lt?: Maybe<Scalars['DateTime']>;
  lte?: Maybe<Scalars['DateTime']>;
  not?: Maybe<NestedDateTimeNullableFilter>;
  notIn?: Maybe<Array<Scalars['DateTime']>>;
};

export type NestedEnumFaceSourceFilter = {
  equals?: Maybe<FaceSource>;
  in?: Maybe<Array<FaceSource>>;
  not?: Maybe<NestedEnumFaceSourceFilter>;
  notIn?: Maybe<Array<FaceSource>>;
};

export type NestedEnumMimeTypeFilter = {
  equals?: Maybe<MimeType>;
  in?: Maybe<Array<MimeType>>;
  not?: Maybe<NestedEnumMimeTypeFilter>;
  notIn?: Maybe<Array<MimeType>>;
};

export type NestedEnumTagSourceFilter = {
  equals?: Maybe<TagSource>;
  in?: Maybe<Array<TagSource>>;
  not?: Maybe<NestedEnumTagSourceFilter>;
  notIn?: Maybe<Array<TagSource>>;
};

export type NestedEnumUploadTypeFilter = {
  equals?: Maybe<UploadType>;
  in?: Maybe<Array<UploadType>>;
  not?: Maybe<NestedEnumUploadTypeFilter>;
  notIn?: Maybe<Array<UploadType>>;
};

export type NestedFloatFilter = {
  equals?: Maybe<Scalars['Float']>;
  gt?: Maybe<Scalars['Float']>;
  gte?: Maybe<Scalars['Float']>;
  in?: Maybe<Array<Scalars['Float']>>;
  lt?: Maybe<Scalars['Float']>;
  lte?: Maybe<Scalars['Float']>;
  not?: Maybe<NestedFloatFilter>;
  notIn?: Maybe<Array<Scalars['Float']>>;
};

export type NestedIntFilter = {
  equals?: Maybe<Scalars['Int']>;
  gt?: Maybe<Scalars['Int']>;
  gte?: Maybe<Scalars['Int']>;
  in?: Maybe<Array<Scalars['Int']>>;
  lt?: Maybe<Scalars['Int']>;
  lte?: Maybe<Scalars['Int']>;
  not?: Maybe<NestedIntFilter>;
  notIn?: Maybe<Array<Scalars['Int']>>;
};

export type NestedIntNullableFilter = {
  equals?: Maybe<Scalars['Int']>;
  gt?: Maybe<Scalars['Int']>;
  gte?: Maybe<Scalars['Int']>;
  in?: Maybe<Array<Scalars['Int']>>;
  lt?: Maybe<Scalars['Int']>;
  lte?: Maybe<Scalars['Int']>;
  not?: Maybe<NestedIntNullableFilter>;
  notIn?: Maybe<Array<Scalars['Int']>>;
};

export type NestedStringFilter = {
  contains?: Maybe<Scalars['String']>;
  endsWith?: Maybe<Scalars['String']>;
  equals?: Maybe<Scalars['String']>;
  gt?: Maybe<Scalars['String']>;
  gte?: Maybe<Scalars['String']>;
  in?: Maybe<Array<Scalars['String']>>;
  lt?: Maybe<Scalars['String']>;
  lte?: Maybe<Scalars['String']>;
  not?: Maybe<NestedStringFilter>;
  notIn?: Maybe<Array<Scalars['String']>>;
  startsWith?: Maybe<Scalars['String']>;
};

export type NestedStringNullableFilter = {
  contains?: Maybe<Scalars['String']>;
  endsWith?: Maybe<Scalars['String']>;
  equals?: Maybe<Scalars['String']>;
  gt?: Maybe<Scalars['String']>;
  gte?: Maybe<Scalars['String']>;
  in?: Maybe<Array<Scalars['String']>>;
  lt?: Maybe<Scalars['String']>;
  lte?: Maybe<Scalars['String']>;
  not?: Maybe<NestedStringNullableFilter>;
  notIn?: Maybe<Array<Scalars['String']>>;
  startsWith?: Maybe<Scalars['String']>;
};

export type NullableDateTimeFieldUpdateOperationsInput = {
  set?: Maybe<Scalars['DateTime']>;
};

export type NullableIntFieldUpdateOperationsInput = {
  decrement?: Maybe<Scalars['Int']>;
  divide?: Maybe<Scalars['Int']>;
  increment?: Maybe<Scalars['Int']>;
  multiply?: Maybe<Scalars['Int']>;
  set?: Maybe<Scalars['Int']>;
};

export type NullableStringFieldUpdateOperationsInput = {
  set?: Maybe<Scalars['String']>;
};

export type Person = {
  __typename?: 'Person';
  aliases: Array<Alias>;
  appearances: Array<Appearance>;
  createdAt: Scalars['DateTime'];
  faces: Array<Face>;
  id: Scalars['Int'];
  memberOf: Array<GroupMember>;
  name: Scalars['String'];
  preferredAlias?: Maybe<Alias>;
  updatedAt: Scalars['DateTime'];
};


export type PersonAliasesArgs = {
  cursor?: Maybe<AliasWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  take?: Maybe<Scalars['Int']>;
};


export type PersonAppearancesArgs = {
  cursor?: Maybe<AppearanceWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  take?: Maybe<Scalars['Int']>;
};


export type PersonFacesArgs = {
  cursor?: Maybe<FaceWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  take?: Maybe<Scalars['Int']>;
};


export type PersonMemberOfArgs = {
  cursor?: Maybe<GroupMemberWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  take?: Maybe<Scalars['Int']>;
};

export type PersonCreateInput = {
  aliases?: Maybe<AliasCreateNestedManyWithoutPersonInput>;
  appearances?: Maybe<AppearanceCreateNestedManyWithoutPersonInput>;
  appearsIn?: Maybe<FaceCreateNestedManyWithoutPersonInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  description?: Maybe<Scalars['String']>;
  ireneBotId?: Maybe<Scalars['Int']>;
  memberOf?: Maybe<GroupMemberCreateNestedManyWithoutPersonInput>;
  name: Scalars['String'];
  preferredAlias?: Maybe<AliasCreateNestedOneWithoutPreferredAliasOfInput>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type PersonCreateNestedOneWithoutAliasesInput = {
  connect?: Maybe<PersonWhereUniqueInput>;
  connectOrCreate?: Maybe<PersonCreateOrConnectWithoutAliasesInput>;
  create?: Maybe<PersonCreateWithoutAliasesInput>;
};

export type PersonCreateNestedOneWithoutAppearancesInput = {
  connect?: Maybe<PersonWhereUniqueInput>;
  connectOrCreate?: Maybe<PersonCreateOrConnectWithoutAppearancesInput>;
  create?: Maybe<PersonCreateWithoutAppearancesInput>;
};

export type PersonCreateNestedOneWithoutMemberOfInput = {
  connect?: Maybe<PersonWhereUniqueInput>;
  connectOrCreate?: Maybe<PersonCreateOrConnectWithoutMemberOfInput>;
  create?: Maybe<PersonCreateWithoutMemberOfInput>;
};

export type PersonCreateNestedOneWithoutPreferredAliasInput = {
  connect?: Maybe<PersonWhereUniqueInput>;
  connectOrCreate?: Maybe<PersonCreateOrConnectWithoutPreferredAliasInput>;
  create?: Maybe<PersonCreateWithoutPreferredAliasInput>;
};

export type PersonCreateOrConnectWithoutAliasesInput = {
  create: PersonCreateWithoutAliasesInput;
  where: PersonWhereUniqueInput;
};

export type PersonCreateOrConnectWithoutAppearancesInput = {
  create: PersonCreateWithoutAppearancesInput;
  where: PersonWhereUniqueInput;
};

export type PersonCreateOrConnectWithoutAppearsInInput = {
  create: PersonCreateWithoutAppearsInInput;
  where: PersonWhereUniqueInput;
};

export type PersonCreateOrConnectWithoutMemberOfInput = {
  create: PersonCreateWithoutMemberOfInput;
  where: PersonWhereUniqueInput;
};

export type PersonCreateOrConnectWithoutPreferredAliasInput = {
  create: PersonCreateWithoutPreferredAliasInput;
  where: PersonWhereUniqueInput;
};

export type PersonCreateWithoutAliasesInput = {
  appearances?: Maybe<AppearanceCreateNestedManyWithoutPersonInput>;
  appearsIn?: Maybe<FaceCreateNestedManyWithoutPersonInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  description?: Maybe<Scalars['String']>;
  ireneBotId?: Maybe<Scalars['Int']>;
  memberOf?: Maybe<GroupMemberCreateNestedManyWithoutPersonInput>;
  name: Scalars['String'];
  preferredAlias?: Maybe<AliasCreateNestedOneWithoutPreferredAliasOfInput>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type PersonCreateWithoutAppearancesInput = {
  aliases?: Maybe<AliasCreateNestedManyWithoutPersonInput>;
  appearsIn?: Maybe<FaceCreateNestedManyWithoutPersonInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  description?: Maybe<Scalars['String']>;
  ireneBotId?: Maybe<Scalars['Int']>;
  memberOf?: Maybe<GroupMemberCreateNestedManyWithoutPersonInput>;
  name: Scalars['String'];
  preferredAlias?: Maybe<AliasCreateNestedOneWithoutPreferredAliasOfInput>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type PersonCreateWithoutAppearsInInput = {
  aliases?: Maybe<AliasCreateNestedManyWithoutPersonInput>;
  appearances?: Maybe<AppearanceCreateNestedManyWithoutPersonInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  description?: Maybe<Scalars['String']>;
  ireneBotId?: Maybe<Scalars['Int']>;
  memberOf?: Maybe<GroupMemberCreateNestedManyWithoutPersonInput>;
  name: Scalars['String'];
  preferredAlias?: Maybe<AliasCreateNestedOneWithoutPreferredAliasOfInput>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type PersonCreateWithoutMemberOfInput = {
  aliases?: Maybe<AliasCreateNestedManyWithoutPersonInput>;
  appearances?: Maybe<AppearanceCreateNestedManyWithoutPersonInput>;
  appearsIn?: Maybe<FaceCreateNestedManyWithoutPersonInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  description?: Maybe<Scalars['String']>;
  ireneBotId?: Maybe<Scalars['Int']>;
  name: Scalars['String'];
  preferredAlias?: Maybe<AliasCreateNestedOneWithoutPreferredAliasOfInput>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type PersonCreateWithoutPreferredAliasInput = {
  aliases?: Maybe<AliasCreateNestedManyWithoutPersonInput>;
  appearances?: Maybe<AppearanceCreateNestedManyWithoutPersonInput>;
  appearsIn?: Maybe<FaceCreateNestedManyWithoutPersonInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  description?: Maybe<Scalars['String']>;
  ireneBotId?: Maybe<Scalars['Int']>;
  memberOf?: Maybe<GroupMemberCreateNestedManyWithoutPersonInput>;
  name: Scalars['String'];
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type PersonUpdateInput = {
  aliases?: Maybe<AliasUpdateManyWithoutPersonInput>;
  appearances?: Maybe<AppearanceUpdateManyWithoutPersonInput>;
  appearsIn?: Maybe<FaceUpdateManyWithoutPersonInput>;
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  description?: Maybe<NullableStringFieldUpdateOperationsInput>;
  ireneBotId?: Maybe<NullableIntFieldUpdateOperationsInput>;
  memberOf?: Maybe<GroupMemberUpdateManyWithoutPersonInput>;
  name?: Maybe<StringFieldUpdateOperationsInput>;
  preferredAlias?: Maybe<AliasUpdateOneWithoutPreferredAliasOfInput>;
  updatedAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
};

export type PersonUpdateOneRequiredWithoutAliasesInput = {
  connect?: Maybe<PersonWhereUniqueInput>;
  connectOrCreate?: Maybe<PersonCreateOrConnectWithoutAliasesInput>;
  create?: Maybe<PersonCreateWithoutAliasesInput>;
  update?: Maybe<PersonUpdateWithoutAliasesInput>;
  upsert?: Maybe<PersonUpsertWithoutAliasesInput>;
};

export type PersonUpdateOneRequiredWithoutAppearancesInput = {
  connect?: Maybe<PersonWhereUniqueInput>;
  connectOrCreate?: Maybe<PersonCreateOrConnectWithoutAppearancesInput>;
  create?: Maybe<PersonCreateWithoutAppearancesInput>;
  update?: Maybe<PersonUpdateWithoutAppearancesInput>;
  upsert?: Maybe<PersonUpsertWithoutAppearancesInput>;
};

export type PersonUpdateOneRequiredWithoutMemberOfInput = {
  connect?: Maybe<PersonWhereUniqueInput>;
  connectOrCreate?: Maybe<PersonCreateOrConnectWithoutMemberOfInput>;
  create?: Maybe<PersonCreateWithoutMemberOfInput>;
  update?: Maybe<PersonUpdateWithoutMemberOfInput>;
  upsert?: Maybe<PersonUpsertWithoutMemberOfInput>;
};

export type PersonUpdateOneWithoutAppearsInInput = {
  connect?: Maybe<PersonWhereUniqueInput>;
  connectOrCreate?: Maybe<PersonCreateOrConnectWithoutAppearsInInput>;
  create?: Maybe<PersonCreateWithoutAppearsInInput>;
  delete?: Maybe<Scalars['Boolean']>;
  disconnect?: Maybe<Scalars['Boolean']>;
  update?: Maybe<PersonUpdateWithoutAppearsInInput>;
  upsert?: Maybe<PersonUpsertWithoutAppearsInInput>;
};

export type PersonUpdateOneWithoutPreferredAliasInput = {
  connect?: Maybe<PersonWhereUniqueInput>;
  connectOrCreate?: Maybe<PersonCreateOrConnectWithoutPreferredAliasInput>;
  create?: Maybe<PersonCreateWithoutPreferredAliasInput>;
  delete?: Maybe<Scalars['Boolean']>;
  disconnect?: Maybe<Scalars['Boolean']>;
  update?: Maybe<PersonUpdateWithoutPreferredAliasInput>;
  upsert?: Maybe<PersonUpsertWithoutPreferredAliasInput>;
};

export type PersonUpdateWithoutAliasesInput = {
  appearances?: Maybe<AppearanceUpdateManyWithoutPersonInput>;
  appearsIn?: Maybe<FaceUpdateManyWithoutPersonInput>;
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  description?: Maybe<NullableStringFieldUpdateOperationsInput>;
  ireneBotId?: Maybe<NullableIntFieldUpdateOperationsInput>;
  memberOf?: Maybe<GroupMemberUpdateManyWithoutPersonInput>;
  name?: Maybe<StringFieldUpdateOperationsInput>;
  preferredAlias?: Maybe<AliasUpdateOneWithoutPreferredAliasOfInput>;
  updatedAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
};

export type PersonUpdateWithoutAppearancesInput = {
  aliases?: Maybe<AliasUpdateManyWithoutPersonInput>;
  appearsIn?: Maybe<FaceUpdateManyWithoutPersonInput>;
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  description?: Maybe<NullableStringFieldUpdateOperationsInput>;
  ireneBotId?: Maybe<NullableIntFieldUpdateOperationsInput>;
  memberOf?: Maybe<GroupMemberUpdateManyWithoutPersonInput>;
  name?: Maybe<StringFieldUpdateOperationsInput>;
  preferredAlias?: Maybe<AliasUpdateOneWithoutPreferredAliasOfInput>;
  updatedAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
};

export type PersonUpdateWithoutAppearsInInput = {
  aliases?: Maybe<AliasUpdateManyWithoutPersonInput>;
  appearances?: Maybe<AppearanceUpdateManyWithoutPersonInput>;
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  description?: Maybe<NullableStringFieldUpdateOperationsInput>;
  ireneBotId?: Maybe<NullableIntFieldUpdateOperationsInput>;
  memberOf?: Maybe<GroupMemberUpdateManyWithoutPersonInput>;
  name?: Maybe<StringFieldUpdateOperationsInput>;
  preferredAlias?: Maybe<AliasUpdateOneWithoutPreferredAliasOfInput>;
  updatedAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
};

export type PersonUpdateWithoutMemberOfInput = {
  aliases?: Maybe<AliasUpdateManyWithoutPersonInput>;
  appearances?: Maybe<AppearanceUpdateManyWithoutPersonInput>;
  appearsIn?: Maybe<FaceUpdateManyWithoutPersonInput>;
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  description?: Maybe<NullableStringFieldUpdateOperationsInput>;
  ireneBotId?: Maybe<NullableIntFieldUpdateOperationsInput>;
  name?: Maybe<StringFieldUpdateOperationsInput>;
  preferredAlias?: Maybe<AliasUpdateOneWithoutPreferredAliasOfInput>;
  updatedAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
};

export type PersonUpdateWithoutPreferredAliasInput = {
  aliases?: Maybe<AliasUpdateManyWithoutPersonInput>;
  appearances?: Maybe<AppearanceUpdateManyWithoutPersonInput>;
  appearsIn?: Maybe<FaceUpdateManyWithoutPersonInput>;
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  description?: Maybe<NullableStringFieldUpdateOperationsInput>;
  ireneBotId?: Maybe<NullableIntFieldUpdateOperationsInput>;
  memberOf?: Maybe<GroupMemberUpdateManyWithoutPersonInput>;
  name?: Maybe<StringFieldUpdateOperationsInput>;
  updatedAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
};

export type PersonUpsertWithoutAliasesInput = {
  create: PersonCreateWithoutAliasesInput;
  update: PersonUpdateWithoutAliasesInput;
};

export type PersonUpsertWithoutAppearancesInput = {
  create: PersonCreateWithoutAppearancesInput;
  update: PersonUpdateWithoutAppearancesInput;
};

export type PersonUpsertWithoutAppearsInInput = {
  create: PersonCreateWithoutAppearsInInput;
  update: PersonUpdateWithoutAppearsInInput;
};

export type PersonUpsertWithoutMemberOfInput = {
  create: PersonCreateWithoutMemberOfInput;
  update: PersonUpdateWithoutMemberOfInput;
};

export type PersonUpsertWithoutPreferredAliasInput = {
  create: PersonCreateWithoutPreferredAliasInput;
  update: PersonUpdateWithoutPreferredAliasInput;
};

export type PersonWhereInput = {
  AND?: Maybe<Array<PersonWhereInput>>;
  NOT?: Maybe<Array<PersonWhereInput>>;
  OR?: Maybe<Array<PersonWhereInput>>;
  aliases?: Maybe<AliasListRelationFilter>;
  appearances?: Maybe<AppearanceListRelationFilter>;
  appearsIn?: Maybe<FaceListRelationFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  description?: Maybe<StringNullableFilter>;
  id?: Maybe<IntFilter>;
  ireneBotId?: Maybe<IntNullableFilter>;
  memberOf?: Maybe<GroupMemberListRelationFilter>;
  name?: Maybe<StringFilter>;
  preferredAlias?: Maybe<AliasWhereInput>;
  preferredAliasId?: Maybe<IntNullableFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type PersonWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
  ireneBotId?: Maybe<Scalars['Int']>;
};

export type Query = {
  __typename?: 'Query';
  /** Find a single image by its slug. */
  image?: Maybe<Image>;
  imageConnections?: Maybe<ImageConnections>;
  images: Array<Image>;
  me?: Maybe<User>;
  people: Array<Person>;
  person?: Maybe<Person>;
  user?: Maybe<User>;
};


export type QueryImageArgs = {
  slug: Scalars['String'];
};


export type QueryImageConnectionsArgs = {
  depth?: Scalars['Int'];
  slug: Scalars['String'];
};


export type QueryImagesArgs = {
  cursor?: Maybe<ImageWhereUniqueInput>;
  orderBy?: Maybe<Array<ImageOrderByInput>>;
  skip?: Maybe<Scalars['Int']>;
  take?: Maybe<Scalars['Int']>;
  where?: Maybe<ImageWhereInput>;
};


export type QueryPeopleArgs = {
  cursor?: Maybe<PersonWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  take?: Maybe<Scalars['Int']>;
  where?: Maybe<PersonWhereInput>;
};


export type QueryPersonArgs = {
  where: PersonWhereUniqueInput;
};


export type QueryUserArgs = {
  id?: Maybe<Scalars['Int']>;
};

export enum QueryMode {
  Default = 'default',
  Insensitive = 'insensitive'
}

export type QueueInfo = {
  __typename?: 'QueueInfo';
  queueSize: Scalars['Int'];
};

export type Role = {
  __typename?: 'Role';
  createdAt: Scalars['DateTime'];
  name: Scalars['String'];
};

export type RoleCreateManyUserInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  name: Scalars['String'];
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type RoleCreateManyUserInputEnvelope = {
  data?: Maybe<Array<RoleCreateManyUserInput>>;
  skipDuplicates?: Maybe<Scalars['Boolean']>;
};

export type RoleCreateNestedManyWithoutUserInput = {
  connect?: Maybe<Array<RoleWhereUniqueInput>>;
  connectOrCreate?: Maybe<Array<RoleCreateOrConnectWithoutUserInput>>;
  create?: Maybe<Array<RoleCreateWithoutUserInput>>;
  createMany?: Maybe<RoleCreateManyUserInputEnvelope>;
};

export type RoleCreateOrConnectWithoutUserInput = {
  create: RoleCreateWithoutUserInput;
  where: RoleWhereUniqueInput;
};

export type RoleCreateWithoutUserInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type RoleListRelationFilter = {
  every?: Maybe<RoleWhereInput>;
  none?: Maybe<RoleWhereInput>;
  some?: Maybe<RoleWhereInput>;
};

export type RoleScalarWhereInput = {
  AND?: Maybe<Array<RoleScalarWhereInput>>;
  NOT?: Maybe<Array<RoleScalarWhereInput>>;
  OR?: Maybe<Array<RoleScalarWhereInput>>;
  createdAt?: Maybe<DateTimeFilter>;
  id?: Maybe<IntFilter>;
  name?: Maybe<StringFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
  userId?: Maybe<IntFilter>;
};

export type RoleUpdateManyMutationInput = {
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  name?: Maybe<StringFieldUpdateOperationsInput>;
  updatedAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
};

export type RoleUpdateManyWithWhereWithoutUserInput = {
  data: RoleUpdateManyMutationInput;
  where: RoleScalarWhereInput;
};

export type RoleUpdateManyWithoutUserInput = {
  connect?: Maybe<Array<RoleWhereUniqueInput>>;
  connectOrCreate?: Maybe<Array<RoleCreateOrConnectWithoutUserInput>>;
  create?: Maybe<Array<RoleCreateWithoutUserInput>>;
  createMany?: Maybe<RoleCreateManyUserInputEnvelope>;
  delete?: Maybe<Array<RoleWhereUniqueInput>>;
  deleteMany?: Maybe<Array<RoleScalarWhereInput>>;
  disconnect?: Maybe<Array<RoleWhereUniqueInput>>;
  set?: Maybe<Array<RoleWhereUniqueInput>>;
  update?: Maybe<Array<RoleUpdateWithWhereUniqueWithoutUserInput>>;
  updateMany?: Maybe<Array<RoleUpdateManyWithWhereWithoutUserInput>>;
  upsert?: Maybe<Array<RoleUpsertWithWhereUniqueWithoutUserInput>>;
};

export type RoleUpdateWithWhereUniqueWithoutUserInput = {
  data: RoleUpdateWithoutUserInput;
  where: RoleWhereUniqueInput;
};

export type RoleUpdateWithoutUserInput = {
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  name?: Maybe<StringFieldUpdateOperationsInput>;
  updatedAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
};

export type RoleUpsertWithWhereUniqueWithoutUserInput = {
  create: RoleCreateWithoutUserInput;
  update: RoleUpdateWithoutUserInput;
  where: RoleWhereUniqueInput;
};

export type RoleUserRoleCompoundUniqueInput = {
  name: Scalars['String'];
  userId: Scalars['Int'];
};

export type RoleWhereInput = {
  AND?: Maybe<Array<RoleWhereInput>>;
  NOT?: Maybe<Array<RoleWhereInput>>;
  OR?: Maybe<Array<RoleWhereInput>>;
  createdAt?: Maybe<DateTimeFilter>;
  id?: Maybe<IntFilter>;
  name?: Maybe<StringFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
  user?: Maybe<UserWhereInput>;
  userId?: Maybe<IntFilter>;
};

export type RoleWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
  userRole?: Maybe<RoleUserRoleCompoundUniqueInput>;
};

export enum SortOrder {
  Asc = 'asc',
  Desc = 'desc'
}

export type StringFieldUpdateOperationsInput = {
  set?: Maybe<Scalars['String']>;
};

export type StringFilter = {
  contains?: Maybe<Scalars['String']>;
  endsWith?: Maybe<Scalars['String']>;
  equals?: Maybe<Scalars['String']>;
  gt?: Maybe<Scalars['String']>;
  gte?: Maybe<Scalars['String']>;
  in?: Maybe<Array<Scalars['String']>>;
  lt?: Maybe<Scalars['String']>;
  lte?: Maybe<Scalars['String']>;
  mode?: Maybe<QueryMode>;
  not?: Maybe<NestedStringFilter>;
  notIn?: Maybe<Array<Scalars['String']>>;
  startsWith?: Maybe<Scalars['String']>;
};

export type StringNullableFilter = {
  contains?: Maybe<Scalars['String']>;
  endsWith?: Maybe<Scalars['String']>;
  equals?: Maybe<Scalars['String']>;
  gt?: Maybe<Scalars['String']>;
  gte?: Maybe<Scalars['String']>;
  in?: Maybe<Array<Scalars['String']>>;
  lt?: Maybe<Scalars['String']>;
  lte?: Maybe<Scalars['String']>;
  mode?: Maybe<QueryMode>;
  not?: Maybe<NestedStringNullableFilter>;
  notIn?: Maybe<Array<Scalars['String']>>;
  startsWith?: Maybe<Scalars['String']>;
};

export type Tag = {
  __typename?: 'Tag';
  addedBy?: Maybe<User>;
  createdAt: Scalars['DateTime'];
  name: Scalars['String'];
  source: TagSource;
};

export type TagCreateManyAddedByInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  imageId: Scalars['Int'];
  name: Scalars['String'];
  source: TagSource;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type TagCreateManyAddedByInputEnvelope = {
  data?: Maybe<Array<TagCreateManyAddedByInput>>;
  skipDuplicates?: Maybe<Scalars['Boolean']>;
};

export type TagCreateManyImageInput = {
  addedById?: Maybe<Scalars['Int']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  id?: Maybe<Scalars['Int']>;
  name: Scalars['String'];
  source: TagSource;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type TagCreateManyImageInputEnvelope = {
  data?: Maybe<Array<TagCreateManyImageInput>>;
  skipDuplicates?: Maybe<Scalars['Boolean']>;
};

export type TagCreateNestedManyWithoutAddedByInput = {
  connect?: Maybe<Array<TagWhereUniqueInput>>;
  connectOrCreate?: Maybe<Array<TagCreateOrConnectWithoutAddedByInput>>;
  create?: Maybe<Array<TagCreateWithoutAddedByInput>>;
  createMany?: Maybe<TagCreateManyAddedByInputEnvelope>;
};

export type TagCreateNestedManyWithoutImageInput = {
  connect?: Maybe<Array<TagWhereUniqueInput>>;
  connectOrCreate?: Maybe<Array<TagCreateOrConnectWithoutImageInput>>;
  create?: Maybe<Array<TagCreateWithoutImageInput>>;
  createMany?: Maybe<TagCreateManyImageInputEnvelope>;
};

export type TagCreateOrConnectWithoutAddedByInput = {
  create: TagCreateWithoutAddedByInput;
  where: TagWhereUniqueInput;
};

export type TagCreateOrConnectWithoutImageInput = {
  create: TagCreateWithoutImageInput;
  where: TagWhereUniqueInput;
};

export type TagCreateWithoutAddedByInput = {
  createdAt?: Maybe<Scalars['DateTime']>;
  image: ImageCreateNestedOneWithoutTagsInput;
  name: Scalars['String'];
  source: TagSource;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type TagCreateWithoutImageInput = {
  addedBy?: Maybe<UserCreateNestedOneWithoutCratedTagsInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  name: Scalars['String'];
  source: TagSource;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type TagListRelationFilter = {
  every?: Maybe<TagWhereInput>;
  none?: Maybe<TagWhereInput>;
  some?: Maybe<TagWhereInput>;
};

export type TagScalarWhereInput = {
  AND?: Maybe<Array<TagScalarWhereInput>>;
  NOT?: Maybe<Array<TagScalarWhereInput>>;
  OR?: Maybe<Array<TagScalarWhereInput>>;
  addedById?: Maybe<IntNullableFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  id?: Maybe<IntFilter>;
  imageId?: Maybe<IntFilter>;
  name?: Maybe<StringFilter>;
  source?: Maybe<EnumTagSourceFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export enum TagSource {
  User = 'USER'
}

export type TagUpdateManyMutationInput = {
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  name?: Maybe<StringFieldUpdateOperationsInput>;
  source?: Maybe<EnumTagSourceFieldUpdateOperationsInput>;
  updatedAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
};

export type TagUpdateManyWithWhereWithoutAddedByInput = {
  data: TagUpdateManyMutationInput;
  where: TagScalarWhereInput;
};

export type TagUpdateManyWithWhereWithoutImageInput = {
  data: TagUpdateManyMutationInput;
  where: TagScalarWhereInput;
};

export type TagUpdateManyWithoutAddedByInput = {
  connect?: Maybe<Array<TagWhereUniqueInput>>;
  connectOrCreate?: Maybe<Array<TagCreateOrConnectWithoutAddedByInput>>;
  create?: Maybe<Array<TagCreateWithoutAddedByInput>>;
  createMany?: Maybe<TagCreateManyAddedByInputEnvelope>;
  delete?: Maybe<Array<TagWhereUniqueInput>>;
  deleteMany?: Maybe<Array<TagScalarWhereInput>>;
  disconnect?: Maybe<Array<TagWhereUniqueInput>>;
  set?: Maybe<Array<TagWhereUniqueInput>>;
  update?: Maybe<Array<TagUpdateWithWhereUniqueWithoutAddedByInput>>;
  updateMany?: Maybe<Array<TagUpdateManyWithWhereWithoutAddedByInput>>;
  upsert?: Maybe<Array<TagUpsertWithWhereUniqueWithoutAddedByInput>>;
};

export type TagUpdateManyWithoutImageInput = {
  connect?: Maybe<Array<TagWhereUniqueInput>>;
  connectOrCreate?: Maybe<Array<TagCreateOrConnectWithoutImageInput>>;
  create?: Maybe<Array<TagCreateWithoutImageInput>>;
  createMany?: Maybe<TagCreateManyImageInputEnvelope>;
  delete?: Maybe<Array<TagWhereUniqueInput>>;
  deleteMany?: Maybe<Array<TagScalarWhereInput>>;
  disconnect?: Maybe<Array<TagWhereUniqueInput>>;
  set?: Maybe<Array<TagWhereUniqueInput>>;
  update?: Maybe<Array<TagUpdateWithWhereUniqueWithoutImageInput>>;
  updateMany?: Maybe<Array<TagUpdateManyWithWhereWithoutImageInput>>;
  upsert?: Maybe<Array<TagUpsertWithWhereUniqueWithoutImageInput>>;
};

export type TagUpdateWithWhereUniqueWithoutAddedByInput = {
  data: TagUpdateWithoutAddedByInput;
  where: TagWhereUniqueInput;
};

export type TagUpdateWithWhereUniqueWithoutImageInput = {
  data: TagUpdateWithoutImageInput;
  where: TagWhereUniqueInput;
};

export type TagUpdateWithoutAddedByInput = {
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  image?: Maybe<ImageUpdateOneRequiredWithoutTagsInput>;
  name?: Maybe<StringFieldUpdateOperationsInput>;
  source?: Maybe<EnumTagSourceFieldUpdateOperationsInput>;
  updatedAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
};

export type TagUpdateWithoutImageInput = {
  addedBy?: Maybe<UserUpdateOneWithoutCratedTagsInput>;
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  name?: Maybe<StringFieldUpdateOperationsInput>;
  source?: Maybe<EnumTagSourceFieldUpdateOperationsInput>;
  updatedAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
};

export type TagUpsertWithWhereUniqueWithoutAddedByInput = {
  create: TagCreateWithoutAddedByInput;
  update: TagUpdateWithoutAddedByInput;
  where: TagWhereUniqueInput;
};

export type TagUpsertWithWhereUniqueWithoutImageInput = {
  create: TagCreateWithoutImageInput;
  update: TagUpdateWithoutImageInput;
  where: TagWhereUniqueInput;
};

export type TagWhereInput = {
  AND?: Maybe<Array<TagWhereInput>>;
  NOT?: Maybe<Array<TagWhereInput>>;
  OR?: Maybe<Array<TagWhereInput>>;
  addedBy?: Maybe<UserWhereInput>;
  addedById?: Maybe<IntNullableFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  id?: Maybe<IntFilter>;
  image?: Maybe<ImageWhereInput>;
  imageId?: Maybe<IntFilter>;
  name?: Maybe<StringFilter>;
  source?: Maybe<EnumTagSourceFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type TagWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
};

/** Preview urls of an image */
export type Thumbnail = {
  __typename?: 'Thumbnail';
  large: Scalars['String'];
  medium: Scalars['String'];
  small: Scalars['String'];
};

export enum UploadType {
  Token = 'TOKEN',
  Website = 'WEBSITE'
}

export type User = {
  __typename?: 'User';
  avatar?: Maybe<Scalars['String']>;
  bot: Scalars['Boolean'];
  id: Scalars['Int'];
  images: Array<Image>;
  name?: Maybe<Scalars['String']>;
  roles: Array<Role>;
};


export type UserImagesArgs = {
  cursor?: Maybe<ImageWhereUniqueInput>;
  orderBy?: Maybe<Array<ImageOrderByInput>>;
  skip?: Maybe<Scalars['Int']>;
  take?: Maybe<Scalars['Int']>;
  where?: Maybe<ImageWhereInput>;
};


export type UserRolesArgs = {
  cursor?: Maybe<RoleWhereUniqueInput>;
  skip?: Maybe<Scalars['Int']>;
  take?: Maybe<Scalars['Int']>;
};

export type UserCreateNestedOneWithoutCratedTagsInput = {
  connect?: Maybe<UserWhereUniqueInput>;
  connectOrCreate?: Maybe<UserCreateOrConnectWithoutCratedTagsInput>;
  create?: Maybe<UserCreateWithoutCratedTagsInput>;
};

export type UserCreateNestedOneWithoutImageLikesInput = {
  connect?: Maybe<UserWhereUniqueInput>;
  connectOrCreate?: Maybe<UserCreateOrConnectWithoutImageLikesInput>;
  create?: Maybe<UserCreateWithoutImageLikesInput>;
};

export type UserCreateNestedOneWithoutImagesInput = {
  connect?: Maybe<UserWhereUniqueInput>;
  connectOrCreate?: Maybe<UserCreateOrConnectWithoutImagesInput>;
  create?: Maybe<UserCreateWithoutImagesInput>;
};

export type UserCreateNestedOneWithoutTaggedAppearancesInput = {
  connect?: Maybe<UserWhereUniqueInput>;
  connectOrCreate?: Maybe<UserCreateOrConnectWithoutTaggedAppearancesInput>;
  create?: Maybe<UserCreateWithoutTaggedAppearancesInput>;
};

export type UserCreateOrConnectWithoutCratedTagsInput = {
  create: UserCreateWithoutCratedTagsInput;
  where: UserWhereUniqueInput;
};

export type UserCreateOrConnectWithoutImageLikesInput = {
  create: UserCreateWithoutImageLikesInput;
  where: UserWhereUniqueInput;
};

export type UserCreateOrConnectWithoutImagesInput = {
  create: UserCreateWithoutImagesInput;
  where: UserWhereUniqueInput;
};

export type UserCreateOrConnectWithoutMarkedFacesInput = {
  create: UserCreateWithoutMarkedFacesInput;
  where: UserWhereUniqueInput;
};

export type UserCreateOrConnectWithoutTaggedAppearancesInput = {
  create: UserCreateWithoutTaggedAppearancesInput;
  where: UserWhereUniqueInput;
};

export type UserCreateWithoutCratedTagsInput = {
  bot?: Maybe<Scalars['Boolean']>;
  createdAt?: Maybe<Scalars['DateTime']>;
  email?: Maybe<Scalars['String']>;
  emailVerified?: Maybe<Scalars['DateTime']>;
  image?: Maybe<Scalars['String']>;
  imageLikes?: Maybe<ImageLikeCreateNestedManyWithoutUserInput>;
  images?: Maybe<ImageCreateNestedManyWithoutUserInput>;
  markedFaces?: Maybe<FaceCreateNestedManyWithoutAddedByInput>;
  name?: Maybe<Scalars['String']>;
  roles?: Maybe<RoleCreateNestedManyWithoutUserInput>;
  taggedAppearances?: Maybe<AppearanceCreateNestedManyWithoutAddedByInput>;
  token?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type UserCreateWithoutImageLikesInput = {
  bot?: Maybe<Scalars['Boolean']>;
  cratedTags?: Maybe<TagCreateNestedManyWithoutAddedByInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  email?: Maybe<Scalars['String']>;
  emailVerified?: Maybe<Scalars['DateTime']>;
  image?: Maybe<Scalars['String']>;
  images?: Maybe<ImageCreateNestedManyWithoutUserInput>;
  markedFaces?: Maybe<FaceCreateNestedManyWithoutAddedByInput>;
  name?: Maybe<Scalars['String']>;
  roles?: Maybe<RoleCreateNestedManyWithoutUserInput>;
  taggedAppearances?: Maybe<AppearanceCreateNestedManyWithoutAddedByInput>;
  token?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type UserCreateWithoutImagesInput = {
  bot?: Maybe<Scalars['Boolean']>;
  cratedTags?: Maybe<TagCreateNestedManyWithoutAddedByInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  email?: Maybe<Scalars['String']>;
  emailVerified?: Maybe<Scalars['DateTime']>;
  image?: Maybe<Scalars['String']>;
  imageLikes?: Maybe<ImageLikeCreateNestedManyWithoutUserInput>;
  markedFaces?: Maybe<FaceCreateNestedManyWithoutAddedByInput>;
  name?: Maybe<Scalars['String']>;
  roles?: Maybe<RoleCreateNestedManyWithoutUserInput>;
  taggedAppearances?: Maybe<AppearanceCreateNestedManyWithoutAddedByInput>;
  token?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type UserCreateWithoutMarkedFacesInput = {
  bot?: Maybe<Scalars['Boolean']>;
  cratedTags?: Maybe<TagCreateNestedManyWithoutAddedByInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  email?: Maybe<Scalars['String']>;
  emailVerified?: Maybe<Scalars['DateTime']>;
  image?: Maybe<Scalars['String']>;
  imageLikes?: Maybe<ImageLikeCreateNestedManyWithoutUserInput>;
  images?: Maybe<ImageCreateNestedManyWithoutUserInput>;
  name?: Maybe<Scalars['String']>;
  roles?: Maybe<RoleCreateNestedManyWithoutUserInput>;
  taggedAppearances?: Maybe<AppearanceCreateNestedManyWithoutAddedByInput>;
  token?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type UserCreateWithoutTaggedAppearancesInput = {
  bot?: Maybe<Scalars['Boolean']>;
  cratedTags?: Maybe<TagCreateNestedManyWithoutAddedByInput>;
  createdAt?: Maybe<Scalars['DateTime']>;
  email?: Maybe<Scalars['String']>;
  emailVerified?: Maybe<Scalars['DateTime']>;
  image?: Maybe<Scalars['String']>;
  imageLikes?: Maybe<ImageLikeCreateNestedManyWithoutUserInput>;
  images?: Maybe<ImageCreateNestedManyWithoutUserInput>;
  markedFaces?: Maybe<FaceCreateNestedManyWithoutAddedByInput>;
  name?: Maybe<Scalars['String']>;
  roles?: Maybe<RoleCreateNestedManyWithoutUserInput>;
  token?: Maybe<Scalars['String']>;
  updatedAt?: Maybe<Scalars['DateTime']>;
};

export type UserUpdateOneRequiredWithoutImageLikesInput = {
  connect?: Maybe<UserWhereUniqueInput>;
  connectOrCreate?: Maybe<UserCreateOrConnectWithoutImageLikesInput>;
  create?: Maybe<UserCreateWithoutImageLikesInput>;
  update?: Maybe<UserUpdateWithoutImageLikesInput>;
  upsert?: Maybe<UserUpsertWithoutImageLikesInput>;
};

export type UserUpdateOneRequiredWithoutTaggedAppearancesInput = {
  connect?: Maybe<UserWhereUniqueInput>;
  connectOrCreate?: Maybe<UserCreateOrConnectWithoutTaggedAppearancesInput>;
  create?: Maybe<UserCreateWithoutTaggedAppearancesInput>;
  update?: Maybe<UserUpdateWithoutTaggedAppearancesInput>;
  upsert?: Maybe<UserUpsertWithoutTaggedAppearancesInput>;
};

export type UserUpdateOneWithoutCratedTagsInput = {
  connect?: Maybe<UserWhereUniqueInput>;
  connectOrCreate?: Maybe<UserCreateOrConnectWithoutCratedTagsInput>;
  create?: Maybe<UserCreateWithoutCratedTagsInput>;
  delete?: Maybe<Scalars['Boolean']>;
  disconnect?: Maybe<Scalars['Boolean']>;
  update?: Maybe<UserUpdateWithoutCratedTagsInput>;
  upsert?: Maybe<UserUpsertWithoutCratedTagsInput>;
};

export type UserUpdateOneWithoutImagesInput = {
  connect?: Maybe<UserWhereUniqueInput>;
  connectOrCreate?: Maybe<UserCreateOrConnectWithoutImagesInput>;
  create?: Maybe<UserCreateWithoutImagesInput>;
  delete?: Maybe<Scalars['Boolean']>;
  disconnect?: Maybe<Scalars['Boolean']>;
  update?: Maybe<UserUpdateWithoutImagesInput>;
  upsert?: Maybe<UserUpsertWithoutImagesInput>;
};

export type UserUpdateOneWithoutMarkedFacesInput = {
  connect?: Maybe<UserWhereUniqueInput>;
  connectOrCreate?: Maybe<UserCreateOrConnectWithoutMarkedFacesInput>;
  create?: Maybe<UserCreateWithoutMarkedFacesInput>;
  delete?: Maybe<Scalars['Boolean']>;
  disconnect?: Maybe<Scalars['Boolean']>;
  update?: Maybe<UserUpdateWithoutMarkedFacesInput>;
  upsert?: Maybe<UserUpsertWithoutMarkedFacesInput>;
};

export type UserUpdateWithoutCratedTagsInput = {
  bot?: Maybe<BoolFieldUpdateOperationsInput>;
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  email?: Maybe<NullableStringFieldUpdateOperationsInput>;
  emailVerified?: Maybe<NullableDateTimeFieldUpdateOperationsInput>;
  image?: Maybe<NullableStringFieldUpdateOperationsInput>;
  imageLikes?: Maybe<ImageLikeUpdateManyWithoutUserInput>;
  images?: Maybe<ImageUpdateManyWithoutUserInput>;
  markedFaces?: Maybe<FaceUpdateManyWithoutAddedByInput>;
  name?: Maybe<NullableStringFieldUpdateOperationsInput>;
  roles?: Maybe<RoleUpdateManyWithoutUserInput>;
  taggedAppearances?: Maybe<AppearanceUpdateManyWithoutAddedByInput>;
  token?: Maybe<NullableStringFieldUpdateOperationsInput>;
  updatedAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
};

export type UserUpdateWithoutImageLikesInput = {
  bot?: Maybe<BoolFieldUpdateOperationsInput>;
  cratedTags?: Maybe<TagUpdateManyWithoutAddedByInput>;
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  email?: Maybe<NullableStringFieldUpdateOperationsInput>;
  emailVerified?: Maybe<NullableDateTimeFieldUpdateOperationsInput>;
  image?: Maybe<NullableStringFieldUpdateOperationsInput>;
  images?: Maybe<ImageUpdateManyWithoutUserInput>;
  markedFaces?: Maybe<FaceUpdateManyWithoutAddedByInput>;
  name?: Maybe<NullableStringFieldUpdateOperationsInput>;
  roles?: Maybe<RoleUpdateManyWithoutUserInput>;
  taggedAppearances?: Maybe<AppearanceUpdateManyWithoutAddedByInput>;
  token?: Maybe<NullableStringFieldUpdateOperationsInput>;
  updatedAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
};

export type UserUpdateWithoutImagesInput = {
  bot?: Maybe<BoolFieldUpdateOperationsInput>;
  cratedTags?: Maybe<TagUpdateManyWithoutAddedByInput>;
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  email?: Maybe<NullableStringFieldUpdateOperationsInput>;
  emailVerified?: Maybe<NullableDateTimeFieldUpdateOperationsInput>;
  image?: Maybe<NullableStringFieldUpdateOperationsInput>;
  imageLikes?: Maybe<ImageLikeUpdateManyWithoutUserInput>;
  markedFaces?: Maybe<FaceUpdateManyWithoutAddedByInput>;
  name?: Maybe<NullableStringFieldUpdateOperationsInput>;
  roles?: Maybe<RoleUpdateManyWithoutUserInput>;
  taggedAppearances?: Maybe<AppearanceUpdateManyWithoutAddedByInput>;
  token?: Maybe<NullableStringFieldUpdateOperationsInput>;
  updatedAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
};

export type UserUpdateWithoutMarkedFacesInput = {
  bot?: Maybe<BoolFieldUpdateOperationsInput>;
  cratedTags?: Maybe<TagUpdateManyWithoutAddedByInput>;
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  email?: Maybe<NullableStringFieldUpdateOperationsInput>;
  emailVerified?: Maybe<NullableDateTimeFieldUpdateOperationsInput>;
  image?: Maybe<NullableStringFieldUpdateOperationsInput>;
  imageLikes?: Maybe<ImageLikeUpdateManyWithoutUserInput>;
  images?: Maybe<ImageUpdateManyWithoutUserInput>;
  name?: Maybe<NullableStringFieldUpdateOperationsInput>;
  roles?: Maybe<RoleUpdateManyWithoutUserInput>;
  taggedAppearances?: Maybe<AppearanceUpdateManyWithoutAddedByInput>;
  token?: Maybe<NullableStringFieldUpdateOperationsInput>;
  updatedAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
};

export type UserUpdateWithoutTaggedAppearancesInput = {
  bot?: Maybe<BoolFieldUpdateOperationsInput>;
  cratedTags?: Maybe<TagUpdateManyWithoutAddedByInput>;
  createdAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
  email?: Maybe<NullableStringFieldUpdateOperationsInput>;
  emailVerified?: Maybe<NullableDateTimeFieldUpdateOperationsInput>;
  image?: Maybe<NullableStringFieldUpdateOperationsInput>;
  imageLikes?: Maybe<ImageLikeUpdateManyWithoutUserInput>;
  images?: Maybe<ImageUpdateManyWithoutUserInput>;
  markedFaces?: Maybe<FaceUpdateManyWithoutAddedByInput>;
  name?: Maybe<NullableStringFieldUpdateOperationsInput>;
  roles?: Maybe<RoleUpdateManyWithoutUserInput>;
  token?: Maybe<NullableStringFieldUpdateOperationsInput>;
  updatedAt?: Maybe<DateTimeFieldUpdateOperationsInput>;
};

export type UserUpsertWithoutCratedTagsInput = {
  create: UserCreateWithoutCratedTagsInput;
  update: UserUpdateWithoutCratedTagsInput;
};

export type UserUpsertWithoutImageLikesInput = {
  create: UserCreateWithoutImageLikesInput;
  update: UserUpdateWithoutImageLikesInput;
};

export type UserUpsertWithoutImagesInput = {
  create: UserCreateWithoutImagesInput;
  update: UserUpdateWithoutImagesInput;
};

export type UserUpsertWithoutMarkedFacesInput = {
  create: UserCreateWithoutMarkedFacesInput;
  update: UserUpdateWithoutMarkedFacesInput;
};

export type UserUpsertWithoutTaggedAppearancesInput = {
  create: UserCreateWithoutTaggedAppearancesInput;
  update: UserUpdateWithoutTaggedAppearancesInput;
};

export type UserWhereInput = {
  AND?: Maybe<Array<UserWhereInput>>;
  NOT?: Maybe<Array<UserWhereInput>>;
  OR?: Maybe<Array<UserWhereInput>>;
  bot?: Maybe<BoolFilter>;
  cratedTags?: Maybe<TagListRelationFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  email?: Maybe<StringNullableFilter>;
  emailVerified?: Maybe<DateTimeNullableFilter>;
  id?: Maybe<IntFilter>;
  image?: Maybe<StringNullableFilter>;
  imageLikes?: Maybe<ImageLikeListRelationFilter>;
  images?: Maybe<ImageListRelationFilter>;
  markedFaces?: Maybe<FaceListRelationFilter>;
  name?: Maybe<StringNullableFilter>;
  roles?: Maybe<RoleListRelationFilter>;
  taggedAppearances?: Maybe<AppearanceListRelationFilter>;
  token?: Maybe<StringNullableFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type UserWhereUniqueInput = {
  email?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
  token?: Maybe<Scalars['String']>;
};

export type GetBackendImageQueryVariables = Exact<{
  slug: Scalars['String'];
}>;


export type GetBackendImageQuery = (
  { __typename?: 'Query' }
  & { image?: Maybe<(
    { __typename?: 'Image' }
    & Pick<Image, 'id' | 'width' | 'height' | 'rawUrl' | 'mimetype' | 'faceScanDate'>
  )> }
);

export type LabelImageMutationVariables = Exact<{
  slug: Scalars['String'];
  faces: Array<FaceInput> | FaceInput;
  ireneBotId?: Maybe<Scalars['Int']>;
  pHash?: Maybe<Scalars['String']>;
  palette: Array<Scalars['Int']> | Scalars['Int'];
}>;


export type LabelImageMutation = (
  { __typename?: 'Mutation' }
  & { labelImage?: Maybe<(
    { __typename?: 'Image' }
    & Pick<Image, 'id'>
  )> }
);


export const GetBackendImageDocument = gql`
    query getBackendImage($slug: String!) {
  image(slug: $slug) {
    id
    width
    height
    rawUrl
    mimetype
    faceScanDate
  }
}
    `;
export const LabelImageDocument = gql`
    mutation labelImage($slug: String!, $faces: [FaceInput!]!, $ireneBotId: Int, $pHash: String, $palette: [Int!]!) {
  labelImage(
    slug: $slug
    replacePreviousScan: true
    faces: $faces
    ireneBotId: $ireneBotId
    pHash: $pHash
    palette: $palette
  ) {
    id
  }
}
    `;

export type SdkFunctionWrapper = <T>(action: () => Promise<T>) => Promise<T>;


const defaultWrapper: SdkFunctionWrapper = sdkFunction => sdkFunction();

export function getSdk(client: GraphQLClient, withWrapper: SdkFunctionWrapper = defaultWrapper) {
  return {
    getBackendImage(variables: GetBackendImageQueryVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<GetBackendImageQuery> {
      return withWrapper(() => client.request<GetBackendImageQuery>(GetBackendImageDocument, variables, requestHeaders));
    },
    labelImage(variables: LabelImageMutationVariables, requestHeaders?: Dom.RequestInit["headers"]): Promise<LabelImageMutation> {
      return withWrapper(() => client.request<LabelImageMutation>(LabelImageDocument, variables, requestHeaders));
    }
  };
}
export type Sdk = ReturnType<typeof getSdk>;