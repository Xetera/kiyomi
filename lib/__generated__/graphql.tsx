/* DO NOT EDIT! this file was generated by graphql-codegen */
/* eslint-disable */
import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
const defaultOptions =  {}
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  DateTime: any;
};

export type User = {
  __typename?: 'User';
  id: Scalars['Int'];
  name?: Maybe<Scalars['String']>;
  avatar?: Maybe<Scalars['String']>;
  images: Array<Image>;
};


export type UserImagesArgs = {
  where?: Maybe<ImageWhereInput>;
  take?: Maybe<Scalars['Int']>;
  skip?: Maybe<Scalars['Int']>;
  cursor?: Maybe<ImageWhereUniqueInput>;
};

export type Image = {
  __typename?: 'Image';
  id: Scalars['Int'];
  /** Width of the image in pixels. */
  width?: Maybe<Scalars['Int']>;
  /** Height of the image in pixels. */
  height?: Maybe<Scalars['Int']>;
  uploadType: UploadType;
  /** SHA256 checksum of the image. */
  hash: Scalars['String'];
  /** The name the image file was uploaded with. */
  fileName?: Maybe<Scalars['String']>;
  /** Block hash of the image, useful for doing reverse search with hamming distance. */
  pHash?: Maybe<Scalars['String']>;
  /** Dominant colors in the image in decimal format, sorted by frequency. */
  palette: Array<Scalars['Int']>;
  isNsfw: Scalars['Boolean'];
  /** The url the image was taken from (if applicable). Not guaranteed to be a direct image url. */
  source?: Maybe<Scalars['String']>;
  uploadedBy?: Maybe<User>;
  tags: Array<Tag>;
  /** The unique url identifier of the image. */
  slug: Scalars['String'];
  /** The visibility status of the image. */
  public: Scalars['Boolean'];
  caption?: Maybe<Scalars['String']>;
  views: Scalars['Int'];
  /** The IANA media type of the image. */
  mimetype: MimeType;
  bytes: Scalars['Int'];
  appearances: Array<Appearance>;
  createdAt: Scalars['DateTime'];
  /** Link to the image on the site */
  url: Scalars['String'];
  /** Direct link to the image on the CDN */
  rawUrl: Scalars['String'];
  unknownFaces: Array<Face>;
};


export type ImageTagsArgs = {
  take?: Maybe<Scalars['Int']>;
  skip?: Maybe<Scalars['Int']>;
  cursor?: Maybe<TagWhereUniqueInput>;
};


export type ImageAppearancesArgs = {
  take?: Maybe<Scalars['Int']>;
  skip?: Maybe<Scalars['Int']>;
  cursor?: Maybe<AppearanceWhereUniqueInput>;
};

export type Tag = {
  __typename?: 'Tag';
  name: Scalars['String'];
  addedBy?: Maybe<User>;
  source: TagSource;
  createdAt: Scalars['DateTime'];
};

export type Face = {
  __typename?: 'Face';
  id: Scalars['Int'];
  x: Scalars['Float'];
  y: Scalars['Float'];
  height: Scalars['Float'];
  width: Scalars['Float'];
  addedBy?: Maybe<User>;
  appearance?: Maybe<Appearance>;
  image: Image;
  score: Scalars['Float'];
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
};

export type Appearance = {
  __typename?: 'Appearance';
  id: Scalars['Int'];
  person: Person;
  addedBy: User;
  faces: Array<Face>;
  createdAt: Scalars['DateTime'];
  updatedAt: Scalars['DateTime'];
};


export type AppearanceFacesArgs = {
  take?: Maybe<Scalars['Int']>;
  skip?: Maybe<Scalars['Int']>;
  cursor?: Maybe<FaceWhereUniqueInput>;
};

export type Person = {
  __typename?: 'Person';
  id: Scalars['Int'];
  name: Scalars['String'];
  updatedAt: Scalars['DateTime'];
  createdAt: Scalars['DateTime'];
};

export type ImageWhereInput = {
  AND?: Maybe<Array<ImageWhereInput>>;
  OR?: Maybe<Array<ImageWhereInput>>;
  NOT?: Maybe<Array<ImageWhereInput>>;
  slug?: Maybe<StringFilter>;
  width?: Maybe<IntNullableFilter>;
  height?: Maybe<IntNullableFilter>;
  fileName?: Maybe<StringNullableFilter>;
  uploadType?: Maybe<EnumUploadTypeFilter>;
  mimetype?: Maybe<EnumMimeTypeFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
  userId?: Maybe<IntNullableFilter>;
  id?: Maybe<IntFilter>;
  hash?: Maybe<StringFilter>;
  pHash?: Maybe<StringNullableFilter>;
  public?: Maybe<BoolFilter>;
  palette?: Maybe<IntNullableListFilter>;
  caption?: Maybe<StringNullableFilter>;
  views?: Maybe<IntFilter>;
  isNsfw?: Maybe<BoolFilter>;
  source?: Maybe<StringNullableFilter>;
  bytes?: Maybe<IntFilter>;
  user?: Maybe<UserWhereInput>;
  appearances?: Maybe<AppearanceListRelationFilter>;
  tags?: Maybe<TagListRelationFilter>;
  faces?: Maybe<FaceListRelationFilter>;
};

export type ImageWhereUniqueInput = {
  slug?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['Int']>;
};

export enum UploadType {
  Website = 'WEBSITE',
  Token = 'TOKEN'
}

export type TagWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
};

export enum MimeType {
  Png = 'PNG',
  Jpg = 'JPG',
  Svg = 'SVG',
  Webp = 'WEBP',
  Webm = 'WEBM',
  Avif = 'AVIF',
  Gif = 'GIF',
  Mp4 = 'MP4'
}

export type AppearanceWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
  unique_image_person?: Maybe<AppearanceUnique_Image_PersonCompoundUniqueInput>;
};


export enum TagSource {
  User = 'USER'
}

export type FaceWhereUniqueInput = {
  id?: Maybe<Scalars['Int']>;
};

export type StringFilter = {
  equals?: Maybe<Scalars['String']>;
  in?: Maybe<Array<Scalars['String']>>;
  notIn?: Maybe<Array<Scalars['String']>>;
  lt?: Maybe<Scalars['String']>;
  lte?: Maybe<Scalars['String']>;
  gt?: Maybe<Scalars['String']>;
  gte?: Maybe<Scalars['String']>;
  contains?: Maybe<Scalars['String']>;
  startsWith?: Maybe<Scalars['String']>;
  endsWith?: Maybe<Scalars['String']>;
  mode?: Maybe<QueryMode>;
  not?: Maybe<NestedStringFilter>;
};

export type IntNullableFilter = {
  equals?: Maybe<Scalars['Int']>;
  in?: Maybe<Array<Scalars['Int']>>;
  notIn?: Maybe<Array<Scalars['Int']>>;
  lt?: Maybe<Scalars['Int']>;
  lte?: Maybe<Scalars['Int']>;
  gt?: Maybe<Scalars['Int']>;
  gte?: Maybe<Scalars['Int']>;
  not?: Maybe<NestedIntNullableFilter>;
};

export type StringNullableFilter = {
  equals?: Maybe<Scalars['String']>;
  in?: Maybe<Array<Scalars['String']>>;
  notIn?: Maybe<Array<Scalars['String']>>;
  lt?: Maybe<Scalars['String']>;
  lte?: Maybe<Scalars['String']>;
  gt?: Maybe<Scalars['String']>;
  gte?: Maybe<Scalars['String']>;
  contains?: Maybe<Scalars['String']>;
  startsWith?: Maybe<Scalars['String']>;
  endsWith?: Maybe<Scalars['String']>;
  mode?: Maybe<QueryMode>;
  not?: Maybe<NestedStringNullableFilter>;
};

export type EnumUploadTypeFilter = {
  equals?: Maybe<UploadType>;
  in?: Maybe<Array<UploadType>>;
  notIn?: Maybe<Array<UploadType>>;
  not?: Maybe<NestedEnumUploadTypeFilter>;
};

export type EnumMimeTypeFilter = {
  equals?: Maybe<MimeType>;
  in?: Maybe<Array<MimeType>>;
  notIn?: Maybe<Array<MimeType>>;
  not?: Maybe<NestedEnumMimeTypeFilter>;
};

export type DateTimeFilter = {
  equals?: Maybe<Scalars['DateTime']>;
  in?: Maybe<Array<Scalars['DateTime']>>;
  notIn?: Maybe<Array<Scalars['DateTime']>>;
  lt?: Maybe<Scalars['DateTime']>;
  lte?: Maybe<Scalars['DateTime']>;
  gt?: Maybe<Scalars['DateTime']>;
  gte?: Maybe<Scalars['DateTime']>;
  not?: Maybe<NestedDateTimeFilter>;
};

export type IntFilter = {
  equals?: Maybe<Scalars['Int']>;
  in?: Maybe<Array<Scalars['Int']>>;
  notIn?: Maybe<Array<Scalars['Int']>>;
  lt?: Maybe<Scalars['Int']>;
  lte?: Maybe<Scalars['Int']>;
  gt?: Maybe<Scalars['Int']>;
  gte?: Maybe<Scalars['Int']>;
  not?: Maybe<NestedIntFilter>;
};

export type BoolFilter = {
  equals?: Maybe<Scalars['Boolean']>;
  not?: Maybe<NestedBoolFilter>;
};

export type IntNullableListFilter = {
  equals?: Maybe<Array<Scalars['Int']>>;
  has?: Maybe<Scalars['Int']>;
  hasEvery?: Maybe<Array<Scalars['Int']>>;
  hasSome?: Maybe<Array<Scalars['Int']>>;
  isEmpty?: Maybe<Scalars['Boolean']>;
};

export type UserWhereInput = {
  AND?: Maybe<Array<UserWhereInput>>;
  OR?: Maybe<Array<UserWhereInput>>;
  NOT?: Maybe<Array<UserWhereInput>>;
  id?: Maybe<IntFilter>;
  name?: Maybe<StringNullableFilter>;
  email?: Maybe<StringNullableFilter>;
  emailVerified?: Maybe<DateTimeNullableFilter>;
  image?: Maybe<StringNullableFilter>;
  token?: Maybe<StringNullableFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
  images?: Maybe<ImageListRelationFilter>;
  cratedTags?: Maybe<TagListRelationFilter>;
  bot?: Maybe<BoolFilter>;
  Appearance?: Maybe<AppearanceListRelationFilter>;
  Face?: Maybe<FaceListRelationFilter>;
};

export type AppearanceListRelationFilter = {
  every?: Maybe<AppearanceWhereInput>;
  some?: Maybe<AppearanceWhereInput>;
  none?: Maybe<AppearanceWhereInput>;
};

export type TagListRelationFilter = {
  every?: Maybe<TagWhereInput>;
  some?: Maybe<TagWhereInput>;
  none?: Maybe<TagWhereInput>;
};

export type FaceListRelationFilter = {
  every?: Maybe<FaceWhereInput>;
  some?: Maybe<FaceWhereInput>;
  none?: Maybe<FaceWhereInput>;
};

export type AppearanceUnique_Image_PersonCompoundUniqueInput = {
  personId: Scalars['Int'];
  imageId: Scalars['Int'];
};

export enum QueryMode {
  Default = 'default',
  Insensitive = 'insensitive'
}

export type NestedStringFilter = {
  equals?: Maybe<Scalars['String']>;
  in?: Maybe<Array<Scalars['String']>>;
  notIn?: Maybe<Array<Scalars['String']>>;
  lt?: Maybe<Scalars['String']>;
  lte?: Maybe<Scalars['String']>;
  gt?: Maybe<Scalars['String']>;
  gte?: Maybe<Scalars['String']>;
  contains?: Maybe<Scalars['String']>;
  startsWith?: Maybe<Scalars['String']>;
  endsWith?: Maybe<Scalars['String']>;
  not?: Maybe<NestedStringFilter>;
};

export type NestedIntNullableFilter = {
  equals?: Maybe<Scalars['Int']>;
  in?: Maybe<Array<Scalars['Int']>>;
  notIn?: Maybe<Array<Scalars['Int']>>;
  lt?: Maybe<Scalars['Int']>;
  lte?: Maybe<Scalars['Int']>;
  gt?: Maybe<Scalars['Int']>;
  gte?: Maybe<Scalars['Int']>;
  not?: Maybe<NestedIntNullableFilter>;
};

export type NestedStringNullableFilter = {
  equals?: Maybe<Scalars['String']>;
  in?: Maybe<Array<Scalars['String']>>;
  notIn?: Maybe<Array<Scalars['String']>>;
  lt?: Maybe<Scalars['String']>;
  lte?: Maybe<Scalars['String']>;
  gt?: Maybe<Scalars['String']>;
  gte?: Maybe<Scalars['String']>;
  contains?: Maybe<Scalars['String']>;
  startsWith?: Maybe<Scalars['String']>;
  endsWith?: Maybe<Scalars['String']>;
  not?: Maybe<NestedStringNullableFilter>;
};

export type NestedEnumUploadTypeFilter = {
  equals?: Maybe<UploadType>;
  in?: Maybe<Array<UploadType>>;
  notIn?: Maybe<Array<UploadType>>;
  not?: Maybe<NestedEnumUploadTypeFilter>;
};

export type NestedEnumMimeTypeFilter = {
  equals?: Maybe<MimeType>;
  in?: Maybe<Array<MimeType>>;
  notIn?: Maybe<Array<MimeType>>;
  not?: Maybe<NestedEnumMimeTypeFilter>;
};

export type NestedDateTimeFilter = {
  equals?: Maybe<Scalars['DateTime']>;
  in?: Maybe<Array<Scalars['DateTime']>>;
  notIn?: Maybe<Array<Scalars['DateTime']>>;
  lt?: Maybe<Scalars['DateTime']>;
  lte?: Maybe<Scalars['DateTime']>;
  gt?: Maybe<Scalars['DateTime']>;
  gte?: Maybe<Scalars['DateTime']>;
  not?: Maybe<NestedDateTimeFilter>;
};

export type NestedIntFilter = {
  equals?: Maybe<Scalars['Int']>;
  in?: Maybe<Array<Scalars['Int']>>;
  notIn?: Maybe<Array<Scalars['Int']>>;
  lt?: Maybe<Scalars['Int']>;
  lte?: Maybe<Scalars['Int']>;
  gt?: Maybe<Scalars['Int']>;
  gte?: Maybe<Scalars['Int']>;
  not?: Maybe<NestedIntFilter>;
};

export type NestedBoolFilter = {
  equals?: Maybe<Scalars['Boolean']>;
  not?: Maybe<NestedBoolFilter>;
};

export type DateTimeNullableFilter = {
  equals?: Maybe<Scalars['DateTime']>;
  in?: Maybe<Array<Scalars['DateTime']>>;
  notIn?: Maybe<Array<Scalars['DateTime']>>;
  lt?: Maybe<Scalars['DateTime']>;
  lte?: Maybe<Scalars['DateTime']>;
  gt?: Maybe<Scalars['DateTime']>;
  gte?: Maybe<Scalars['DateTime']>;
  not?: Maybe<NestedDateTimeNullableFilter>;
};

export type ImageListRelationFilter = {
  every?: Maybe<ImageWhereInput>;
  some?: Maybe<ImageWhereInput>;
  none?: Maybe<ImageWhereInput>;
};

export type AppearanceWhereInput = {
  AND?: Maybe<Array<AppearanceWhereInput>>;
  OR?: Maybe<Array<AppearanceWhereInput>>;
  NOT?: Maybe<Array<AppearanceWhereInput>>;
  id?: Maybe<IntFilter>;
  person?: Maybe<PersonWhereInput>;
  personId?: Maybe<IntFilter>;
  faces?: Maybe<FaceListRelationFilter>;
  addedBy?: Maybe<UserWhereInput>;
  addedById?: Maybe<IntFilter>;
  image?: Maybe<ImageWhereInput>;
  imageId?: Maybe<IntFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
  Face?: Maybe<FaceListRelationFilter>;
};

export type TagWhereInput = {
  AND?: Maybe<Array<TagWhereInput>>;
  OR?: Maybe<Array<TagWhereInput>>;
  NOT?: Maybe<Array<TagWhereInput>>;
  id?: Maybe<IntFilter>;
  name?: Maybe<StringFilter>;
  source?: Maybe<EnumTagSourceFilter>;
  imageId?: Maybe<IntFilter>;
  addedById?: Maybe<IntNullableFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
  addedBy?: Maybe<UserWhereInput>;
  image?: Maybe<ImageWhereInput>;
};

export type FaceWhereInput = {
  AND?: Maybe<Array<FaceWhereInput>>;
  OR?: Maybe<Array<FaceWhereInput>>;
  NOT?: Maybe<Array<FaceWhereInput>>;
  id?: Maybe<IntFilter>;
  x?: Maybe<FloatFilter>;
  y?: Maybe<FloatFilter>;
  height?: Maybe<FloatFilter>;
  width?: Maybe<FloatFilter>;
  appearanceId?: Maybe<IntNullableFilter>;
  addedBy?: Maybe<UserWhereInput>;
  addedById?: Maybe<IntNullableFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
  score?: Maybe<FloatFilter>;
  appearance?: Maybe<AppearanceWhereInput>;
  image?: Maybe<ImageWhereInput>;
  imageId?: Maybe<IntFilter>;
  Person?: Maybe<PersonWhereInput>;
  personId?: Maybe<IntNullableFilter>;
  Appearance?: Maybe<AppearanceWhereInput>;
};

export type NestedDateTimeNullableFilter = {
  equals?: Maybe<Scalars['DateTime']>;
  in?: Maybe<Array<Scalars['DateTime']>>;
  notIn?: Maybe<Array<Scalars['DateTime']>>;
  lt?: Maybe<Scalars['DateTime']>;
  lte?: Maybe<Scalars['DateTime']>;
  gt?: Maybe<Scalars['DateTime']>;
  gte?: Maybe<Scalars['DateTime']>;
  not?: Maybe<NestedDateTimeNullableFilter>;
};

export type PersonWhereInput = {
  AND?: Maybe<Array<PersonWhereInput>>;
  OR?: Maybe<Array<PersonWhereInput>>;
  NOT?: Maybe<Array<PersonWhereInput>>;
  id?: Maybe<IntFilter>;
  description?: Maybe<StringNullableFilter>;
  name?: Maybe<StringFilter>;
  aliases?: Maybe<AliasListRelationFilter>;
  appearsIn?: Maybe<FaceListRelationFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
  Appearance?: Maybe<AppearanceListRelationFilter>;
};

export type EnumTagSourceFilter = {
  equals?: Maybe<TagSource>;
  in?: Maybe<Array<TagSource>>;
  notIn?: Maybe<Array<TagSource>>;
  not?: Maybe<NestedEnumTagSourceFilter>;
};

export type FloatFilter = {
  equals?: Maybe<Scalars['Float']>;
  in?: Maybe<Array<Scalars['Float']>>;
  notIn?: Maybe<Array<Scalars['Float']>>;
  lt?: Maybe<Scalars['Float']>;
  lte?: Maybe<Scalars['Float']>;
  gt?: Maybe<Scalars['Float']>;
  gte?: Maybe<Scalars['Float']>;
  not?: Maybe<NestedFloatFilter>;
};

export type AliasListRelationFilter = {
  every?: Maybe<AliasWhereInput>;
  some?: Maybe<AliasWhereInput>;
  none?: Maybe<AliasWhereInput>;
};

export type NestedEnumTagSourceFilter = {
  equals?: Maybe<TagSource>;
  in?: Maybe<Array<TagSource>>;
  notIn?: Maybe<Array<TagSource>>;
  not?: Maybe<NestedEnumTagSourceFilter>;
};

export type NestedFloatFilter = {
  equals?: Maybe<Scalars['Float']>;
  in?: Maybe<Array<Scalars['Float']>>;
  notIn?: Maybe<Array<Scalars['Float']>>;
  lt?: Maybe<Scalars['Float']>;
  lte?: Maybe<Scalars['Float']>;
  gt?: Maybe<Scalars['Float']>;
  gte?: Maybe<Scalars['Float']>;
  not?: Maybe<NestedFloatFilter>;
};

export type AliasWhereInput = {
  AND?: Maybe<Array<AliasWhereInput>>;
  OR?: Maybe<Array<AliasWhereInput>>;
  NOT?: Maybe<Array<AliasWhereInput>>;
  id?: Maybe<IntFilter>;
  name?: Maybe<StringFilter>;
  person?: Maybe<PersonWhereInput>;
  personId?: Maybe<IntFilter>;
  createdAt?: Maybe<DateTimeFilter>;
  updatedAt?: Maybe<DateTimeFilter>;
};

export type Query = {
  __typename?: 'Query';
  user?: Maybe<User>;
  me?: Maybe<User>;
  image?: Maybe<Image>;
};


export type QueryUserArgs = {
  id?: Maybe<Scalars['Int']>;
};


export type QueryImageArgs = {
  slug: Scalars['String'];
};

export type OneImageQueryVariables = Exact<{
  slug: Scalars['String'];
}>;


export type OneImageQuery = (
  { __typename?: 'Query' }
  & { image?: Maybe<(
    { __typename?: 'Image' }
    & { unknownFaces: Array<(
      { __typename?: 'Face' }
      & { appearance?: Maybe<(
        { __typename?: 'Appearance' }
        & AppearanceDataFragment
      )> }
      & FaceDataFragment
    )>, appearances: Array<(
      { __typename?: 'Appearance' }
      & Pick<Appearance, 'id'>
      & { person: (
        { __typename?: 'Person' }
        & Pick<Person, 'id' | 'name'>
      ), faces: Array<(
        { __typename?: 'Face' }
        & FaceDataFragment
      )> }
    )> }
    & ImageDataFragment
  )> }
);

export type AppearanceDataFragment = (
  { __typename?: 'Appearance' }
  & Pick<Appearance, 'id'>
  & { person: (
    { __typename?: 'Person' }
    & Pick<Person, 'id' | 'name'>
  ) }
);

export type FaceDataFragment = (
  { __typename?: 'Face' }
  & Pick<Face, 'id' | 'x' | 'y' | 'width' | 'height' | 'score'>
);

export type ImageDataFragment = (
  { __typename?: 'Image' }
  & Pick<Image, 'id' | 'height' | 'width' | 'isNsfw' | 'url' | 'rawUrl' | 'createdAt' | 'caption' | 'public' | 'source' | 'slug' | 'bytes' | 'mimetype' | 'palette'>
  & { uploadedBy?: Maybe<(
    { __typename?: 'User' }
    & UserDataFragment
  )>, tags: Array<(
    { __typename?: 'Tag' }
    & Pick<Tag, 'name'>
  )> }
);

export type MeQueryVariables = Exact<{ [key: string]: never; }>;


export type MeQuery = (
  { __typename?: 'Query' }
  & { me?: Maybe<(
    { __typename?: 'User' }
    & { images: Array<(
      { __typename?: 'Image' }
      & ImageDataFragment
    )> }
    & UserDataFragment
  )> }
);

export type UserDataFragment = (
  { __typename?: 'User' }
  & Pick<User, 'id' | 'name' | 'avatar'>
);

export const AppearanceDataFragmentDoc = gql`
    fragment AppearanceData on Appearance {
  id
  person {
    id
    name
  }
}
    `;
export const FaceDataFragmentDoc = gql`
    fragment FaceData on Face {
  id
  x
  y
  width
  height
  score
}
    `;
export const UserDataFragmentDoc = gql`
    fragment UserData on User {
  id
  name
  avatar
}
    `;
export const ImageDataFragmentDoc = gql`
    fragment ImageData on Image {
  id
  height
  width
  isNsfw
  url
  rawUrl
  createdAt
  caption
  public
  source
  slug
  bytes
  mimetype
  palette
  uploadedBy {
    ...UserData
  }
  tags {
    name
  }
}
    ${UserDataFragmentDoc}`;
export const OneImageDocument = gql`
    query OneImage($slug: String!) {
  image(slug: $slug) {
    unknownFaces {
      ...FaceData
      appearance {
        ...AppearanceData
      }
    }
    appearances {
      id
      person {
        id
        name
      }
      faces {
        ...FaceData
      }
    }
    ...ImageData
  }
}
    ${FaceDataFragmentDoc}
${AppearanceDataFragmentDoc}
${ImageDataFragmentDoc}`;

/**
 * __useOneImageQuery__
 *
 * To run a query within a React component, call `useOneImageQuery` and pass it any options that fit your needs.
 * When your component renders, `useOneImageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useOneImageQuery({
 *   variables: {
 *      slug: // value for 'slug'
 *   },
 * });
 */
export function useOneImageQuery(baseOptions: Apollo.QueryHookOptions<OneImageQuery, OneImageQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<OneImageQuery, OneImageQueryVariables>(OneImageDocument, options);
      }
export function useOneImageLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<OneImageQuery, OneImageQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<OneImageQuery, OneImageQueryVariables>(OneImageDocument, options);
        }
export type OneImageQueryHookResult = ReturnType<typeof useOneImageQuery>;
export type OneImageLazyQueryHookResult = ReturnType<typeof useOneImageLazyQuery>;
export type OneImageQueryResult = Apollo.QueryResult<OneImageQuery, OneImageQueryVariables>;
export const MeDocument = gql`
    query Me {
  me {
    ...UserData
    images {
      ...ImageData
    }
  }
}
    ${UserDataFragmentDoc}
${ImageDataFragmentDoc}`;

/**
 * __useMeQuery__
 *
 * To run a query within a React component, call `useMeQuery` and pass it any options that fit your needs.
 * When your component renders, `useMeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMeQuery({
 *   variables: {
 *   },
 * });
 */
export function useMeQuery(baseOptions?: Apollo.QueryHookOptions<MeQuery, MeQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MeQuery, MeQueryVariables>(MeDocument, options);
      }
export function useMeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MeQuery, MeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MeQuery, MeQueryVariables>(MeDocument, options);
        }
export type MeQueryHookResult = ReturnType<typeof useMeQuery>;
export type MeLazyQueryHookResult = ReturnType<typeof useMeLazyQuery>;
export type MeQueryResult = Apollo.QueryResult<MeQuery, MeQueryVariables>;